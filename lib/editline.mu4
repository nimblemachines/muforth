( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2013 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

-- loading Command-line history editing

( Need tty support.)
.ifndef tty
   ld lib/tty.mu4
.then

comment ansi-sequences

These sequences are generated by my (Linux) console:
Up     ESC [   A
Down   ESC [   B
Right  ESC [   C
Left   ESC [   D
Home   ESC [ 1 ~
Ins    ESC [ 2 ~
Del    ESC [ 3 ~
End    ESC [ 4 ~
PgUp   ESC [ 5 ~
PgDn   ESC [ 6 ~

Backspace key could generate DEL rather than BS, so be prepared for this. ;-)

When output, BS and cursor motions do _not_ go past screen edges; we need
to do this ourselves. What ANSI sequences move the cursor quickly, eg to
EOL?

Cursor movement
Insert  ESC [ <n> @        <n> is count of blanks to insert; def to 1
Del     ESC [ <n> P        <n> is count of char to delete; def to 1
Up      ESC [ <n> A        <n> is rows/colums to move; defaults to 1
Down    ESC [ <n> B
Right   ESC [ <n> C
Left    ESC [ <n> D

DownCR  ESC [ <n> E     like B, but also go to column 1
UpCR    ESC [ <n> F     like A, but also go to column 1

Go      ESC [       <col> G     defaults to col 1
GoYX    ESC [ <row> <col> H     origin at (1,1); both default to 1

Erase (ie, _replace with blanks_); cursor stays put
erase-chars     ESC [ <n> X   <n> can be omitted; defaults to 1
erase-to-eol    ESC [   K
erase-from-bol  ESC [ 1 K
erase-line      ESC [ 2 K

erase-to-eos    ESC [   J     erase from cursor to end of screen
erase-from-bos  ESC [ 1 J     erase start of screen to cursor
erase-screen    ESC [ 2 J

On Linux, console_codes(4) has all the details. It should be interesting to
see where OSX and BSD console drivers diverge (to say nothing of xterms,
etc). Should I be using (n)curses? Probably. ;-)

ansi-sequences

: curs-bol         #CR emit ;
: curs-to-x        ." ["  radix preserve decimal  (u.) type  char G emit ;
: curs-eol         ( len idx - len idx)  over 1+ curs-to-x ;
: curs-ins         ." [@" ;
: curs-del         ." [P" ;
: curs-right       ." [C" ;
: curs-left        ." [D" ;
: curs-erase-eol   ." [K" ;

256 buffer cl  ( One line only! Generously making it 256 bytes for wide ttys!)

( Make space in cl for one char at idx, then store char there.)
: cl-ins  ( len idx ch - len+1 idx+1)
   push   2dup - ( count)  push  dup cl +  dup dup 1+ pop cmove
   pop swap c!  1 1 v+ ;
   
( Remove char at idx from cl.)
( NOTE: len > idx, otherwise: BOOM!)
: cl-del  ( len idx - len-1 idx)
   -1 u+  2dup - push ( count)  dup cl +  dup 1+ swap pop cmove ;

stderr >width @  constant cl-width

create cl-root  here dup , ,  0 ,  ( prev/next point to cl-root, initially)

variable cl-cur   ( points to cl that we're editing)

( We're about to evaluate it; link cl into history)

: cl>history  ( len)
   =if
      here  dup  cl-root @ , ( prev=root.prev)  cl-root , ( next=root)
      cl-root !  ( root.prev=new)
      dup @ cell+ ! ( new.prev.next=new)
      cl swap _string  ( z")
   then  drop ;

: >cl  ( 'cl - len)
   [ 3 cells ] +  count  ( a len)  tuck  cl swap  cmove ;

: cl-show  ( len - len idx)
   curs-bol  curs-erase-eol  cl over type  dup ;

: cl-left?   ( len idx - len idx flag)  ( can we move left?)     dup ;
: cl-right?  ( len idx - len idx flag)  ( can we move right?)   2dup swap u< ;

: cl-left   ( len idx - len idx-1)  curs-left  1- ;
: cl-right  ( len idx - len idx+1)  curs-right 1+ ;

: cl-key-left   ( len idx - len' idx')  cl-left?  if  cl-left   then ;
: cl-key-right  ( len idx - len' idx')  cl-right? if  cl-right  then ;

: cl-key-up  ( len idx - len' 0)
   2drop  cl-cur @        @ ( prev)  dup cl-cur !  >cl  cl-show ;

: cl-key-dn  ( len idx - len' 0)
   2drop  cl-cur @  cell+ @ ( next)  dup cl-cur !  >cl  cl-show ;

: cl-key-del  ( len idx - len' idx')  ( ^D)
   cl-right? if  curs-del  cl-del  then ;

: cl-key-bs   ( len idx - len' idx')  ( ^H or DEL)
   cl-left? if  cl-left  cl-key-del  then ;

: cl-key-home  ( len idx - len idx)  curs-bol  drop 0 ;
: cl-key-end   ( len idx - len idx)  curs-eol  drop dup ;

: cl-key-ret  ( len idx - addr len)
   curs-eol  space  drop
   dup 1+ [ stderr >col ] !
   dup cl>history  cl swap ;

: cl-key-add  ( len idx ch - len' idx')
   push  over cl-width 1- u< if
      curs-ins  r@ emit  pop cl-ins  ^  then
   shunt ;

: read-esc-seq   key
   char [ = if  key
      dup char A = if  ( cursor up)     drop  cl-key-up     ^ then
      dup char B = if  ( cursor down)   drop  cl-key-dn     ^ then
      dup char C = if  ( cursor right)  drop  cl-key-right  ^ then
      dup char D = if  ( cursor left)   drop  cl-key-left   ^ then
      digit> dup 10 u< if  key  char ~ = if
         dup 1 = if  ( Home)  drop  cl-key-home  ^  then
         dup 4 = if  ( End)   drop  cl-key-end   ^  then
      then  then  drop
   then ;

: process-key   ( len idx - len' idx')  key
    dup #ESC =     if  drop  read-esc-seq  0 ^  then
    dup #BS  =
   over #DEL = or  if  drop  cl-key-bs    0 ^  then
    dup ctrl D =   if  drop  cl-key-del   0 ^  then
    dup #CR  =     if  drop  cl-key-ret  -1 ^  then
    31 over  u<    if        cl-key-add   0 ^  then
   drop  ( default)  0 ;

: editline  ( - addr len)
   cl-root cl-cur !
   0 0  begin  process-key  until ;

: typing  ( - addr len)
   <stdin  >stderr  tty user-raw  editline  tty cooked ;
