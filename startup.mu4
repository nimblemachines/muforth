here
   .forth. ,

token current  .forth.  (linked-name)
   <:> -]   (lit)  [  ,  -]  ^ [

token (new)  current @  (linked-name)
   <:> -]
      nope
      current @  (linked-name)
   ^ [

token new  (new)
   <:> -]
      token (new)
   ^ [

new :
   <:> -]
      new <:> -]
   ^ [

: definitions  current !  ^ [
: forth        .forth. definitions  ^ [
: compiler  .compiler. definitions  ^ [

: literal   (lit)  (lit)  ,  ,   ^ [

: ]   literal -]  ^ [

compiler
: ;   [  token ^    .forth. find huh?  ]  ,
      [  token [ .compiler. find huh?     ,  -]  ^ [
forth

: char   token  drop  c@ ;
: (    [ char ) ]  parse  2drop ;

( Phew! now we can have comments!)

( This file is part of muFORTH: http://muforth.nimblemachines.com/

  Copyright 2002-2012 David Frech. All rights reserved, and all wrongs
  reversed. (See the file COPYRIGHT for details.)

( This file is muforth/startup.mu4. It contains high-level Forth code
  necessary to the useful execution of Forth. This file is loaded and
  interpreted when Forth starts up.

  The idea is to move as much code as possible -out- of the Forth kernel.
  Hence the name: "mu" is the Greek letter often used in engineering to
  represent "micro".

  This file exemplifies a Forth strength - shared by Lisp and Smalltalk,
  among other interpretive/compiled languages - that I like to call
  "writing the reader"; the reader being, in this case, the Forth
  interpreter/compiler.

  As defined in the kernel, the interpreter/compiler is very simple; it
  only knows how to do the following things:

  1. create a new colon word, making a dictionary entry for it;

  2. compile a "call" to an already-defined word [Forth lingo for
     "named piece of code"], by appending its execution address to the end
     of the colon word we are compiling.

  That's it!

  In this file, in Forth, we need to extend the interpreter/compiler to do
  the following:

  1. compile control structures: if/then, for/next, begin/while/repeat;

  2. compile data structures: variables, constants, create/does words;

  3. read and write numbers - an interesting exercise since muforth starts
     life not even knowing the constants 0 or 1;

  4. read and write strings.

  Once these are complete we will have a useful Forth for doing real work.

  The order of business will sometimes seem haphazard; words can only be
  defined after the words they depend on have been defined, so we end up
  jumping around a bit in the "semantics" of the language.

  Hopefully the reader will find this an interesting exercise in
  bootstrapping, which was precisely my intention.

  So, here goes; now we start extending the language, bit by bit.)


( !! NOTE !! Do -NOT- change this part of the file without thinking VERY
  hard first. Make changes below the line marked `Add changes below this
  line', otherwise it may be difficult to diagnose problems added by new
  code.)


( Stack manipulations.)
: rot    >r swap  r> swap ;  ( a b c - b c a)  ( fig!)
: -rot   swap >r  swap r> ;  ( a b c - c a b)
: tuck   swap over ;           ( a b - b a b)

( First, we need compiler versions of ( and char. Since we no longer hide
  words as they are being defined, we need to be careful about how we do
  this. So let's define some words that are useful for searching specific
  dictionary chains and compiling words from them.)

( Roll tokenizing and searching into one.)
: token'   token  rot  find ;   ( chain - a u F | body T)

( Compiling from specific chains. Note that `\' is an elaboration of the
  basic scheme of `\chain'. These words will be handy in the assembler
  and target compiler.)

( Tick)
: chain'  token'  huh?  ;
: \chain  chain'  ,  ;

( 28-apr-2000. Do we ever -really- want to search anything other than .forth.?)
: '   .forth.  chain'  ;
( : '   current @  chain'  ;  ( XXX)

compiler
( XXX: should this and ' do the same thing?)
( : [']  .forth. chain' literal ;)
: [']  ' literal ;

( XXX: is this useful? Here? Maybe in a target compiler...)
: \f     .forth. \chain ;
: \c  .compiler. \chain ;  ( until we have \ ; we need this for "if")

( Ok, now we can define our compiler comment char, ( .)
: (    \f ( ;
forth


( We don't even have any constants yet! So we make the easiest one first...)
: 0   [ dup dup xor ] ;
: -1  [ 0 invert ] ;
: 1   [ -1 negate ] ;
: 2   [ 1 2* ] ;


: bl  [ 2 2* 2* 2* 2* ] ;  ( space character)

: ctrl   char  [ bl 2* ( 64) ]  xor ;  ( how you get ^? = 127.)
compiler
: char   \f char literal ;
: ctrl   \f ctrl literal ;
forth

( A nice way to do full-line comments with no trailing delimiter.)
: --  parsed drop 2 + c@  ctrl J negate  + 0=  first +!
      ctrl J parse  2drop ;  ( throw away until a newline)
compiler
: --  \f -- ;
forth

( Before I figured out the trick above, which yields the correct answer for
  ctrl ?, I defined ctrl thus:)
-- : ctrl   char  [ bl 1- ( 31) ]  and ;  ( elliptical, but it works :-)


( Some useful tidbits.)
: -   negate + ;
: u+  ( a b c - a+c b)  rot +  swap ;  ( "under-plus")
: v+  ( x1 y1 x2 y2 - x1+x2 y1+y2)  push u+ pop + ;  ( add 2-vectors)

: 1+   1 + ;  ( these are common)
: 1-  -1 + ;

: cell   [ 1 cells ] ;
: cell+  [ cell ] + ;
: cell-  [ cell negate ] + ;

( XXX keep these?)
: @+  ( a - n a+)  dup @  swap cell+ ;
: !+  ( n a - a+)  tuck !  cell+ ;

( Double-length words.)
: 2@  @+ @  swap ;  ( cell at lower address to TOP)
: 2!  !+ ! ;

: 2dup  over over ;
: 2swap  rot push  rot pop ;

: 2push  ( a b -> R: a b)  swap  pop -rot  push push      push ;
: 2pop   ( R: a b -> a b)        pop       pop pop    rot push  swap ;

: =    xor 0= ;
: not      0= ;  ( warning! this is NOT 1's complement)
: bic  invert and ;
: @execute  @ execute ;

( jump allows jumping thru a table of addresses; you are responsible for
  making sure the index is within range! It must be used at the end of a
  word. Common usage looks like this:  jump  nope  do1  do2  do3  [

  That example assumes the top of stack has a number from 0 to 3.

  Since no UNNEST needs to be compiled, use of [ rather than ; to end the
  word is common.)

: jump  ( which)  cells pop + @execute ;


( Mark a branch source for later fixup.)
: >mark  ( - src)  here  0 , ;

( Resolve a forward or backward jump, from src to dest.)
( When using absolute branch addresses, this is easy: just store dest at src.)
: <resolve  ( dest src)  ! ;
: >resolve  ( src dest)  swap <resolve ;

( Going back to fig-FORTH!)
: compile   pop  dup cell+  push  @ , ;

compiler
: =if   ( - src)        compile (=0branch)  >mark ;
: if    ( - src)        compile  (0branch)  >mark ;
: then  ( src)          here >resolve ;
: else  ( src0 - src1)  compile   (branch)  >mark  swap  \c then ;

: begin   ( - dest)  here ;
: =until  ( dest -)       \c =if  <resolve ;
: until   ( dest -)        \c if  <resolve ;
: again   ( dest -)     compile   (branch)  >mark  <resolve ;
: =while  ( dest - src dest)  \c =if  swap ;
: while   ( dest - src dest)   \c if  swap ;
: repeat  ( src dest -)   \c again  \c then ;

( n for .. next         goes n times; 2^wordsize if n=0 )
( n ?for .. next then   goes n times; 0 if n=0 )

: for     ( - dest)      compile push           \c begin ;
: ?for    ( - src dest)  compile (?for)  >mark  \c begin ;
: next    ( dest -)      compile (next)  >mark  <resolve ;

( do, loop, +loop)
: do      ( - src dest)   compile (do)     >mark  \c begin ;
: loop    ( src dest -)   compile (loop)   >mark  <resolve  \c then ;
: +loop   ( src dest -)   compile (+loop)  >mark  <resolve  \c then ;

( make \ more like ANS-Forth's POSTPONE)
( Now, the confusion happens because we need to write code _in this word_
  that will compile the above code into _other_ words. How about that?)

( Read a token out of the input stream. If the token is on the compiler
  chain, postpone its execution until the word we're compiling executes. If
  the token is on the forth chain, postpone its compilation until the word
  that we're compiling executes. Got that? ;-)

: \   .compiler. token'  if , ^ then
         .forth. find  huh?  literal  ['] ,  , ;

forth


( Defining words are next. Right now we only `know' how to make `colon'
  definitions. We need some structural help first.)

( I wanted to gain a little of the clarity that Chuck Moore's colorForth
  gains by getting rid of "[ <calculate something here> ] literal". He
  replaces the whole construct with colored words that are executed or
  compiled depending on their color, but with a little added twist: when
  switching from executed to compiled words -- yellow to green --
  colorForth assumes that the yellow words calculated a literal; just
  before starting to compile the first green word after the transition,
  colorForth compiles a literal.

  Even though we don't have color in muFORTH, we can make things a bit
  cleaner by assuming -- unlike traditional Forth -- that between  [  and
  ]  we will calculate a literal.

  How does it work? Simple.  ]  _always_ compiles a literal before
  restarting the colon compiler. To restart it _without_ compiling a
  literal, use  -]  .)


( "nameless" colon words.)
: -:  here <:> -] ;

( For comparison, the regular : compiler is defined thus:
:  :   new <:> -] ; )

 
( Dictionary structure words. Remember that link fields point to the last
  cell - suffix - of a name, which precedes the link field. Roughly, a
  dictionary entry is the following cell-sized things: suffix, link, code;
  where suffix is the last 3 [32-bit] or 7 [64-bit] characters of the name,
  followed by its byte-sized length.)

: link>name    ( 'link - a u)  1- dup  c@  tuck -  swap ;
: suffix>link  ( 'suffix - 'link)  cell+ ;

( These words all assume we're calculating to or from a code field
  address.)

: >link   ( 'code - 'link)  cell- ;
: >name   ( 'code - a u)   >link  link>name  ;
: >body   ( 'code - 'body)  cell+  cell+ ;


( create and does>. Everything old is new again. ;-)

( 2010-nov-30. After many iterations, I have finally arrived at fig-forth's
  implementation of create/does>.  The only difference is the names of the
  words.)

( In fig, there are several kinds of words:
    * CODE words, whose code field points to machine code
    * COLON words, whose code field points to docolon, and whose bodies
      contain a list of execution tokens
    * CONSTANTS, whose code field points to doconst, and whose body
      contains a value
    * VARIABLES, whose code field points to dovar, and whose body contains
      a value
    * DOES words, whose code field points to dodoes, and whose body
      contains an IP pointer, followed optionally by data.

  In muforth there are only three kinds of words:
    * CODE words - primitives defined in C whose code field points to the C
      code implementation
    * COLON words, whose code field points to docolon; body contains a list
      of execution tokens
    * DOES words, whose code field points to dodoes; body starts with IP
      pointer - to parent's Forth code - followed optionally by data.

  fig and muforth share this inefficient but simple implementation. In the
  case of fig, it was because they didn't know any better. In my case, I
  knew better but in the interest of avoiding machine-code dependencies -
  the efficient way of compiling does> words essentially being a form of
  DTC [direct-threaded code] - I had no choice.

  If you want a threaded-code implementation using only pure pointers, you
  need two pointers in each "child" word defined with create/does: one to
  point to C [dodoes] and one to point to Forth [the body of the parent
  defining word].)


( last contains the address of the does ip of the last <does> word defined)
here 0 ,
: last  [ ] ;  ( make the variable by hand!)

( does> fixes up the does ip of the last <does> word to point to the code
  after "does>" in the caller.)

: does>  pop  last @  ! ;


( The underlying engine for all "create/does>" words. It allocates no data
  space in the word. This version does not consume a token from the input
  stream, instead expecting one on the stack. This is particularly useful
  if we are meta-compiling another Forth and want to compile heads into the
  image, since we have to process the token - the name of the new word -
  twice.)

: (create)   ( a u)
   (new) <does>
   here last !  0 , ( placeholder for does ip)
   does> ;

( Everything is defined in terms of `create'.)
: create   token (create) ;

: (constant)  ( con a u)  (create) , ( compile the constant)  does> @ ;
: constant  token (constant) ;

( An array with every cell set to a default value.)
: defarray   ( default cells)  create  ?for dup , next then  drop ;
: array      ( cells)  0 swap  defarray ;

( A byte array; length is rounded up to cell boundary.)
: buffer   ( bytes)  aligned  ( round up)  cell/  array ;

( A self-indexing array with every cell set to a default value.)
: defarray+  ( default cells)  defarray  does>  ( i - a)  swap cells + ;
: array+     ( cells)  0 swap  defarray+ ;

: variable    create  0 , ;
: 2variable   variable  0 , ;


( To bracket comments in a flexible way. If you've bracketed some text
  using comment, changing "comment" to "uncomment" will interpret the
  bracketed text - the delimiter becomes a noop.)

: (comment)  ( a u)
   begin  2dup token  =while  string= until  2drop ^ then
          2drop 2drop 2drop ;
: comment  token  (comment) ;
: uncomment  new <:> \ ^ ;  ( create a noop word)


( How about a really cool word that makes self-parsing comment words? In
  other words, like using "comment" - defined above - but instead of having
  to say "comment **foobar** <commented text> **foobar**", you define
  **foobar** to skip tokens until it comes to a matching **foobar**!!)

comment no-self-comments
: make-comment  create  does>  body> >name  (comment) ;

( Here is one to get you started - good for block comments. It's 75
  characters long:)

make-comment
===========================================================================
no-self-comments

( I guess we can have deferred words, even though they are, in some ways,
  inelegant. The alternative - creating a variable and a colon word that
  calls through that variable, for _every_ deferred word - is also in some
  ways inelegant - and clumsy.

  Actually, the way we define this is exactly equivalent to what we would
  have to do with variables; the difference is that instead of two named
  objects - the variable and the colon word that calls thru it - we have
  one - the deferred word - and we need an extra mechanism to get to its
  value to change it.

  The main argument _against_ deferred words is that they aren't orthogonal
  w.r.t. _user_ variables. The way we are defining them here they are
  implemented using a global, system variable. On muforth, we don't care,
  because we don't _have_ user variables; but on a properly multithreaded
  target machine things are different. There we probably wouldn't implement
  deferred words at all, using instead the "<variable> @execute" idiom; or,
  indeed, we could have all deferred use _user_ variables instead of
  globals. But that's what the fuss is.

  That and that "vectoring" them isn't strictly postfix. And it requires
  architecture-specific code!)

variable undeferred  ' nope undeferred !
: defer  create  undeferred @ ,  does> @execute ;

( Syntactic sugar - from Rod Crawford's 4ARM.)
: now   '  ;
: is    ' >body !  ;   ( as in `now host-interpret is interpret')

compiler
: now  '        literal ;
: is   ' >body  literal  \ ! ;
forth


( Trying out, after all these years, the techniques that Klaus Schleisiek
  presented in 1984 [at FORML] and that I read about in 1993.

  The basic idea is that, in addition to return address pointers [saved
  IPs], there are stack frames on the return stack. These can be for any
  purpose, but we're interested here the following: local variable storage,
  "fluid" rebinding of variables - aka dynamic scoping, and
  cleanup-on-return - eg, to close a file that we opened.)

( Here is a picture of the return stack, with high memory towards the top of
  the page, and low memory further down:

  ^   |                    |
  |   +--------------------+
  |   |  prev return addr  |
  |   +--------------------+
  |   |        ...         |   several cells could be here; depends on the
  |   +--------------------+   type of frame
  |   |        ...         |
  |   +--------------------+
  |   |   cfa of cleanup   |
  |   +--------------------+
  +---+     prev frame     |<--- fp
      +--------------------+
      |    ip of remove    |<--- rp      remove just calls unlink
      +--------------------+                                          )

variable fp    ( the "top" - most recently pushed - frame)
               ( fp points to a frame ptr, which pts to a frame ptr...)

( link creates a new frame. It fetches the cfa of the following word and
  pushes it onto the return stack. This is the cleanup routine. Then it
  links this frame into the list rooted at fp, and then returns to its
  caller, skipping the following cfa. link is called by a word that builds
  a new stack frame.)

: link     r> dup @  >r       ( fetch following cfa & push to r)
           fp @ >r  rp@ fp !  ( link this frame to previous)
           cell+ >r           ( skip fetched cfa) ;

( unlink undoes what link did. It unlinks the frame from the list rooted at
  fp, and then runs the cleanup routine, which will do whatever is
  necessary to de-allocate the frame and undo any state changes made by the
  word that called link.)

: unlink   r>  ( save return address)
           fp @ rp!  r> fp !  ( unlink frame)
           r> execute         ( execute cleanup word)
           >r  ( restore return address) ;

( unwind is useful in the context of exceptions. It starts at fp and
  unlinks each frame in turn until fp points to a frame with a zero link.)

: unwind   r>  ( save return address)
           -- begin  fp @ @  while  unlink  repeat
           begin  fp @  while  unlink  repeat
           >r  ( restore return address) ;


create remove  -]  unlink ;   ( remove pushes IP when executed!)


( Now some interesting applications.)

-- -----------------------------------------------------------------------
-- Fluid binding (dynamically-scoped variables)
-- -----------------------------------------------------------------------
( Restore saved value of a variable.)
: restore
   r> ( ra)   r> r>  ( value addr) !   >r ( ra) ;

( Preserve the value of a variable for the duration of the execution of the
  calling word.)

: preserve  ( addr)  ( address of variable)
   r> ( ra)
   over ( addr) >r  swap @  ( value)  >r
   link restore  ( push cleanup)
   remove >r     ( normal return - unlink and cleanup)
   >r ( ra) ;


-- -----------------------------------------------------------------------
-- Cleanup on return
-- -----------------------------------------------------------------------
: cleanup
   r> ( ra)   r> ( value)  r>  ( cfa) execute   >r ( ra) ;

( Push value and following cfa to R stack; on exit or unwind, execute cfa
  with value on the stack.)

: on-exit  ( value)
   r> ( ra)
   dup @  >r       ( fetch following cfa & push to r)
   swap >r         ( push value)
   link cleanup    ( push code to undo whatever needs undoing)
   remove >r       ( normal return - unlink and cleanup)
   cell+ >r ( ra)  ( skip fetched cfa) ;


-- -----------------------------------------------------------------------
-- Local variable frames
-- -----------------------------------------------------------------------
( Deallocate local variables.)
: unroom
   r> ( ra)
   r> ( #cells)  rp+!  ( rp+! takes cell count!)
   >r ( ra) ;

( Allocate space for local variables.)
( NOTE: do -not- try to use a for loop to push cells! It doesn't work! The
  return stack is being used to store the loop index, but you're busy
  pushing stuff there! All hell breaks loose! If you absolutely want to
  zero locals as they are allocated, do a begin/until loop with the count
  on the data stack.)

: room  ( #cells)
   r> ( ra)

   ( choose one! mark, zero, allocate)
   -- swap dup  begin  "55aa55aa >r  1-  dup 0= until  drop  ( mark)
   -- swap dup  begin          0 >r  1-  dup 0= until  drop  ( zero)
   swap dup  negate rp+!  ( allocate)

   ( #cells)  >r
   link unroom
   remove >r  ( normal return - unlink and cleanup)
   >r ( ra) ;


-- -----------------------------------------------------------------------
-- End of fancy R-stack goodies, and back to pedestrian Forth.
-- -----------------------------------------------------------------------

( Number input)
variable dpl    ( location of , or . )
variable radix

: radixer  constant  does> @  radix ! ;

2 2* 2* dup 2* ( 16!)  radixer hex
dup            (  8!)  radixer octal
2 +            ( 10!)  radixer decimal
2                      radixer binary

decimal
( On and off)
: on  -1 swap !  ;
: off  0 swap !  ;

( Punctuation in numbers: sign, radix, decimal point, separators.)

( 2006-mar-26. Ok, so this *totally* sucks. The presence of these bits of
  punctuation can mask a word not being found in the dictionary. A bare /,
  for instance, with no digits to keep it company, is happily parsed as a
  number. The number? 0. Urgh.)

: punct  ( a1 u1 ch - a2 u2 matched)
   over if ( still chars to process)  swap push  over c@  xor if
   ( no match)  pop 0 ^ then
   ( match)  pop 1 -1 v+  -1 ^  then
   ( end of input)  drop 0 ;

: ?sign  ( a1 u1 - a2 u2 neg) char - punct  if  -1 ^  then  0 ;

( I wanted to add Michael Pruemm's '0' as a hex specifier, but it's not as
  simple as adding it to this list. It will match a bare 0, which won't be
  matched as a number.)

: ?radix  ( a1 u1 - a2 u2)
(   char 0 punct  if  hex ^  then )
   char " punct  if  hex ^  then
   char # punct  if  decimal ^  then
   char ' punct  if  octal ^  then
   char % punct  if  binary ^  then ;

( . resets dpl; others leave it unchanged; this means that embedding . in a
  number causes a double number to be pushed, and dpl set to the count of
  digits _after_ the _last_ . in the number.)
: ?dot  ( a1 u1 - a2 u2)
   char . punct  if  dpl off ^  then
   char , punct  if   ^  then
   char - punct  if   ^  then
   char / punct  if   ^  then
   char : punct  if   ^  then
   char _ punct  if   ^  then   drop complain ;

( This is scary.  We need a bunch of literals for `digit?'.)

: digit?    ( ch - digit T | junk F)
   char 0 -  [ 2 2* 2* 1+ ]  ( 9)   over u< if  ( !decimal)
          [ 2 2* 2* 2* 1+ ]  ( 17)  -
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, UPPERCASE)
          [ 2 2* 2* 2* 2* ]  ( 32)  -
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, lowercase)
      ( junk)  0 ^
   then  then  ( hex) [ 2 2* 1+ 2* ]  ( 10) +  then  ( decimal)
   dup radix @  u<  ;

: @digit?   ( a - a digit T | a junk F)   dup c@  digit?  ;

: *digit  ( u a digit - u*base+digit a)
   swap push ( a)  swap ( dig u)  radix @ * +  pop  dpl @ 0< 1+  dpl +!  ;

( 2002-mar-23. I still don't like how number parsing works. On the one
  hand, we know ahead of time exactly how many characters we have [in the
  token we are trying to convert]; on the other, the way the prefix [sign
  and radix] and embedded [. , - : /] characters work, we can't simply put
  them in a loop: there should be at most one sign and one radix at the
  beginning. Right now I have >number [which converts digits] and punct
  words _both_ checking if there are any characters left to process. This
  seems clumsy.

  And that "dpl!" in ?dot bugs me, too.)

( ANS compatible! - or at least it was when it converting with double numbers.)
: >number  ( u1 a1 c1 - u2 a2 c2)  ( a2 is first unconvertible char)
   =if  for  @digit?  while  *digit 1+ next  0 ^  then   drop  pop  then  ;

( If >number can't convert any digits, complain.)
: digits   ( u1 a1 c1 - u2 a2 c2 u3)
   dup push ( chars left)  >number  pop over - ( count of digits converted)
   0= if  drop complain  then ;

( XXX 2009-sep-01. The following doesn't make sense, and it's a lie as
  well, since 'number,' doesn't exist any more:

  Now some help for the colon compiler. Note that the colon compiler now
  calls `number,' to convert-and-compile and calls `number' when interpreting.
  This is so that `number,' or `number' can reset dpl when they're done. We do
  this so that constants don't screw up fixed-point arithmetic conversion.
  Without this code, if you were to use a fixed-point number, 3.1415 eg, dpl
  would be set to 4. Then `0' pushes 0 on the stack but doesn't affect dpl,
  so Forth tries to convert it, and BOOM.)

: number  ( a u - n)
   radix preserve ( always reset the radix, even in case of error)
   2push  0  2pop  ?sign push  ?radix  dpl on
   begin  digits  =while ( still chars)  ?dot  repeat
   2drop  pop  if negate then  ;


( Ok, folks, now that we have number parsing code we can redefine the
  interpreter and compiler, which up till this point have simply complained
  if they saw something not in the dictionary.)

( Let's define a word to create new modes. This is mostly useful for
  meta-compilers.)

: mode   create  ( prompt token-consumer)  ,  ,  does>  state ! ;


( To set the compiler consumer, we need a sneaky word to get the value of
  state while compiling - we use the same trick later to set the compiler
  prompt.)

compiler
: 'compiler-mode  state @ ;
forth

( Redefine, and then set the forth "consume".)
-:   ( interpret one token)
      .forth. find  if  execute ^  then  number ;     state @  !

( Now set the compiler "consumer". To get access to the value of state at
  compile time, we turn on the compiler, but don't compile anything!)

-:   ( compile one token)
   .compiler. find  if  execute ^  then
      .forth. find  if  ,       ^  then  number literal ;
                                      -]  'compiler-mode [  !


: >    swap <  ;
: <=   > 0= ;
: >=   < 0= ;

: min   2dup >  if swap then  drop  ;
: max   2dup <  if swap then  drop  ;


( Basic character i/o.)

: channel  create , ( fd)  0 , ( column)  , ( width) ;

           0 0 channel stdin
1 tty-width  1 channel stdout
2 tty-width  2 channel stderr

: >col  ( 'channel - 'col)  cell+ ;
: >width  ( 'channel - 'width)  cell+ cell+ ;

: reset-tty-width  ( channel)
   dup @ ( fd) tty-width  swap >width ! ;

( Call when we receive a SIGWINCH - a notification that the "window size"
  of a terminal has changed.)

: handle-sigwinch
   stdout reset-tty-width  stderr reset-tty-width ;

variable in-channel    ( these point to channels)
variable out-channel

: writes  out-channel ! ;
: reads   in-channel  ! ;
: <stdin   stdin reads  ;
: >stdout  stdout writes ;
: >stderr  stderr writes ;  <stdin  >stderr  ( sanity)

variable charbuf  ( for >emit and <key)

( XXX handle #CR and #BS _here_ instead of in separate words?)
: >emit  ( char channel)
   1 over >col +!  ( increment column count)
   swap charbuf c!  @ ( fd)  charbuf 1 write ;

: emit   ( char)  out-channel @  >emit ;

ctrl J  constant #LF   --  10
ctrl M  constant #CR   --  13

: space      bl emit ;
: cr        #LF emit  ( emit newline; assumes OPOST)
            out-channel @  >col off ( clear column) ;

: type   ( a u)
   out-channel @  2dup ( u channel)  >col +! ( incr column by count)
   @ ( fd)  -rot  write ;

( Third parameter is the value to use to calculate whether to wrap.)
: typewrap  ( a u uwrap)
   out-channel @ push
   r@ >col @ +  pop >width @  >=  if cr then  type ;


( Go forth and multiply ... and divide.

  As of r438 - 2006-mar-26 - there are no double-length numbers!

  Our new primitives are:
      * : n1 n2 - n3 [single-length product]
   /mod : n1 n2 - mod quot
  u/mod : u1 u2 - umod uquot

  Any word whose name starts with 'u' is unsigned, both in its arguments
  and its results; the others are signed.

  */ and */mod no longer calculate a double-length intermediate product,
  so beware!)

:  /      ( n1 n2 - quot)    /mod  nip ;
: u/      ( u1 u2 - uquot)  u/mod  nip ;

:  mod    ( n1 n2 - mod)     /mod  drop ;
: umod    ( u1 u2 - umod)   u/mod  drop ;

: */mod   ( n1 n2 n3 - mod quot)   push  *  pop  /mod ;
: */      ( n1 n2 n3 - n1*n2/n3)   */mod  nip ;


( Pictured numeric output.)
: /digit   ( u - uquot umod)  radix @  u/mod swap ;

: >digit   ( n - ch)  ( convert 1 binary digit to char; hex to lowercase)
   9 over u<  39 and +  char 0 +  ;

: abs   ( n - |n|)   dup 0<  if  negate then ;

: spaces  ( n)  0 max  ?for  space  next  then  ;

( pad is where we convert numbers to ASCII. A number is 1 cell - could be
  64 bits! - and in binary would take 64 characters to represent, plus a
  character for the sign. pad returns the address of the _end_ of the
  buffer, since conversion occurs right-to-left.)

( Since we're putting "thousands" separations in here as well, I thought I
  might increase the size to an over-generous 128 bytes.)

128 allot  here constant pad   ( 64 digits + sign + alignment)

variable hld
: hold   -1 hld +!  hld @ c! ;
: held   ( - #chars)  pad  hld @ - ;
: <#     pad hld !  ;
: #>     ( u - a #)  drop  hld @  pad over - ;
: sign   ( n -)   0< if  char - hold  then  ;

: #     ( u - u')   /digit  >digit  hold  ;

( For base-10 numbers, insert a "," every three digits; for other
  bases, insert a "_" every four digits.)

: ?sep  radix @ 10 = if  held 4 mod  3 = if  char , hold  then  ^  then
                         held 5 mod  4 = if  char _ hold  then ;
defer #s
-: ( #,s)   ( u - 0)  begin  #  =while  ?sep  repeat ;
: +sep  [ ]  is #s ;  +sep

-: ( #s)    ( u - 0)  begin  #  dup 0= until  ;
: -sep  [ ]  is #s ;

: (u.)    ( u - a #)   <# #s #> ;
: u.      ( u -)       (u.)  type  space  ;

: (.)     ( n - a #)   dup push ( sign)  abs  <# #s  pop sign  #> ;
: .       ( n -)       (.)  type  space ;

( This should truncate to field length. Actually, it shouldn't. Does it?)
: truncating-field   ( a c field - a' field)   tuck swap -  ( a field field-c)
   dup 0< if  drop ^  then  ?for  bl hold  next then  #>  ;

( Non-truncating field.)
: field   ( a c field - a c)  over - spaces  ;

:  (.r)   ( n field - a #)   push  (.)   pop  field  ;
:   .r    (.r)  type  ;

: (u.r)   ( u field - a #)   push  (u.)  pop  field  ;
:  u.r    (u.r)  type  ;

( Useful.)
: ?  @ .  ;

: bits/cell  [ cell 8 * ] ;
: rotate  ( rotates _right_; without =if/then, rotates by 0 break on x86.)
  =if  2dup u>> push  negate bits/cell +  <<  pop xor ^ then drop ;


( String primitives.)

( 2010-feb-27. In converting to a single dictionary space I was forced to
  "revert" to having strings compiled inline. Now we have to jump over
  their bodies again.

  The single string literal primitive is called (")

( It jumps over the inline, cell-count-prefixed string, and pushes the
  address of its first character and its length on the stack. Because all
  strings are compiled with zero-terminators, it is possible to pass the
  address of the first character to a C function, and it will work.

  I use z" to identify this kind of address. It suggests a zero-terminated
  string.)

( Copy string; return a counted string [addr of first character;
  prefix count cell _precedes_ first character of string].
  This does _not_ allot space in the dictionary!)

: scrabble  ( a u - z")
   here cell+ push ( z")
   dup here ! ( prefix cell-sized length)
   tuck ( u a u)  r@ swap cmove  ( copy string)
   r@ + 0 swap c! ( zero terminator)  pop ;

( all compiled strings have a zero terminator.)
: count  ( z" - a u)  dup  cell- @ ;
: (")    ( - a u)  pop  cell+ count ( a u)  2dup + 1+ aligned push ;

: _string      ( - z")  scrabble  count cell+ 1+  allot ;
: string,   ( ch - z")  parse  _string ;
: token,       ( - z")  token  _string ;

( Compiled strings.)
compiler
:  "   ( - a c)   \ (")  char " string,  drop ;
: z"   ( - z")    \ "  \ drop ;   ( z means zero-terminated)
: ."              \ "  \ type ;
: error"         \ z"  \ abort ;  ( compile a C-style string for abort)

( Interpreted strings. Strings that return an address always get compiled!)
forth
: z"  ( - z")   char "  string, ;
:  "  ( - a c)  \f z" count  ;  ( ANS)
: ."    char " parse ( a #)  type  ;  ( not compiled)

( Words that do something with each word being defined.)
( hook into (new) ( by rewriting its first cell!)
: being-defined  constant  does> @  [ ' (new) cell+ ]  ! ;

( To warn of re-defining a word.)
-: ( a u)  2dup current @ find if  out-channel preserve  >stderr
     drop  2dup type ."  again.  "  ^  then  2drop ;
being-defined -redef
 -redef

( A useful list of words as they're being defined.)
-: ( a u)   radix preserve hex  [ ' #s >body ] preserve -sep
   out-channel preserve >stderr
   out-channel @ >col @ if cr then
   depth . current @ ( chain) u. here u.  2dup type cr ;
being-defined -v  ( be verbose)
-- -v

( You can only do one of these at a time! Is there an easy way to hook
  the hook?)


( Now that we have strings, let's make a more useful definition of
  undeferred, so that defer'ed words that never get set to anything will
  complain when used.)

-:  error" undefined deferred word" ;  undeferred !


( !!!!-------------------- Add changes below this line -------------------!!!!)

( Undefine a word by setting high bit of length.)
: undef   current @  chain'  >link 1- ( len)  dup c@  128 or  swap c! ;

: ?hidden  ( 'suffix - counted?)
   suffix>link  dup  1- c@  ( len)  128 and
   if  ( hidden)  drop 0 ^  then  link>name  dup 2 +  typewrap space space  1 ;

( Word listing. Putting this in as soon as possible. Needs `space'.)
: words   0  current @  ( count 'suffix)
  begin  suffix>link @  =while  dup ?hidden  u+  repeat
  drop  cr  ." ("  . ." words)" ;

( XXX: should be primitive?)
: fill        ( a u n)  -rot  ?for  2dup c!    1+  next  then  2drop ;
: cell-fill   ( a u n)  -rot  ?for  2dup  ! cell+  next  then  2drop ;

: erase  ( a u)   0 fill  ;   ( easy, what?)
: blank  ( a u)  bl fill  ;


( Within.)
: within  ( n lo hi - lo <= n < hi)  over - push  - pop u<  ;


( Character classifications - useful for ASCII dumps and keyboard input.)
: letter?         32 127 within  ;  ( excludes ctrls & DEL)
: graphic?  dup  160 256 within  if  drop -1 ^  then  letter? ;


( Useful stack dump.)
: .s  ( stack)
   depth 1 <  if ^ then  ( don't print empty or underflowed stack!!)
   depth  1-  0 swap do  i nth .  -1 +loop ;


( Defining new dictionary chains.)

( These used to be in an array but are now independent of each other. They
  are structures that look just like a name entry in the dictionary - a
  name-suffix followed by a link field.

  The name is hidden - currently by setting the high bit of the name's
  length - so that dictionary searches and word listings won't see it.

  The link field points to the name entry - suffix - of the last word
  defined on the chain.

  chain consumes a token, creates a new hidden name entry structure and
  then creates a constant with the same name, which returns this hidden
  name entry, addressed by its suffix.)

: chain   token 2dup 2push -1 (name)  2pop (constant) ;

: sealed           0  chain ;  ( create an independent vocab chain)
: chained  current @  chain ;  ( chain to the current vocab)

( It's also possible to chain to an -arbitrary- vocab by simply doing this:

  .arbitrary. chain .new-is-chained-to-arbitrary. )


( Conditional compilation.)

sealed .conditional.
: conditional   .conditional. definitions ;

( eat consumes tokens until it either consumes all the input - in which
  case the while loop will exit - or an execute'd word shunt's to exit the
  containing loop. ?toss processes each token. If it exists in
  .conditional. , it executes it; otherwise, it throws it away.)

: ?toss   .conditional. find  if  execute ^  then  2drop  0 ;
: eat   0 ( nesting)  begin  token  =while  ?toss  until  drop ( nesting) ^
                                    then  2drop ( token)  drop ( nesting) ;

compiler
: .if     0= if  eat  then ;
: .else   eat ;
: .then   ;

( Consume a token, search .forth., and return only the "found or not" flag.)
: .def  .forth. token' nip  =if ^ then  nip ;

: .ifdef   \ .def      \ .if ;
: .ifndef  \ .def  0=  \ .if ;

conditional
( nesting - nesting exitflag)
: .if       1+       0 ;  ( .if nests, never exits)
: .else         dup 0= ;  ( .else doesn't nest, exits if nesting at 0)
: .then     1-  dup 0< ;  ( .then unnests, exits if nesting -was- at 0)

: .ifdef    1+       0 ;  ( these are like .if)
: .ifndef   1+       0 ;

forth
: .if     \ .if ;
: .else   \ .else ;
: .then   ;

: .def     \ .def ;
: .ifdef   \ .ifdef ;
: .ifndef  \ .ifndef ;


( IEC standard binary prefixes:
  http://physics.nist.gov/cuu/Units/binary.html)

: Ki   10 << ;  ( "Kibi", or "kilobinary": 2^10.)
: Mi   Ki Ki ;  ( "Mebi", or "megabinary": 2^20.)
: Gi   Mi Ki ;  ( "Gibi", or "gigabinary": 2^30.)
: Ti   Gi Ki ;  ( "Tebi", or "terabinary": 2^40.)

( I've left out the SI prefixes:
  http://physics.nist.gov/cuu/Units/prefixes.html)
  
( I'm not sure how useful they are for muforth, and I want to prevent the
  possible confusion of using "M" thinking it means 2^20 rather than 10^6.)


.ifdef clock

( Time, timestamp.)
: "hold  ( a n)  dup negate  hld +!  hld @  swap cmove  ;
: ##     ( n)   # #  drop  ;

( Separators)
: ":   char : hold  ;
: "-   char - hold  ;
: ".   char . hold  ;
: ||   bl hold  ;  ( a space)

: month"  ( n - a n)  ( n is 0--11)
   3 *  z" janfebmaraprmayjunjulaugsepoctnovdec" +  3 ;

( clock returns a count of seconds since 1970-jan-01 00:00:00 UTC,
  the Unix "epoch".)

( leaves a 0 which is consumed by #>)
: <date>   ( year month mday yday - 0)
   [ ' #s >body ] preserve  -sep  ( don't want separators in the year!)
   drop  ## "-  month" "hold "-  #s ( year) ;

: <hh:mm:ss>  ( hms)        ## ":  ## ":  ## ;
: <hh:mm>     ( hms)  drop ( sec)  ## ":  ## ;

: (time")  ( year month mday yday hour min sec 'zone #zone - a #)
   radix preserve  decimal  <#  "hold  ( zone)  ||  <hh:mm:ss>  ||  <date>  #> ;

: (short-time")  ( year month mday yday hour min sec 'zone #zone - a #)
   radix preserve  decimal  <#  2drop ( zone)  <hh:mm>  ||  <date>  #> ; 

: (date")  ( year month mday yday hour min sec 'zone #zone - a #)
   radix preserve  decimal  <#  2drop 2drop drop  <date>  #> ;

: date    ( epoch - y m d yday)  local-time  2drop 2drop drop ;

: utc"    ( epoch - a n)         utc  (time") ;
: date"   ( epoch - a n)  local-time  (date") ;
: time"   ( epoch - a n)  local-time  (time") ;
: short-time"
          ( epoch - a n)  local-time  (short-time") ;

( Better primitives? More elegant, certainly.)
: s->sm    ( s - s m)    60 u/mod ;
: s->smh   ( s - s m h)  s->sm  s->sm ;
: s->smhd  ( s - s m h d)  s->smh  24 u/mod ;
: sm->s    60 * + ;
: smh->s   sm->s  sm->s ;
: smhd->s  24 * +  smh->s ;

( If anyone had any idea how long a year really is, we could also define
  s->smhdy and smhdy->s. ;-)

: smhq->s  6 * +  smh->s ;  ( sec min hr quarter-day)
: smhdy->s  [ 365 3 * 366 + ] * ( quarter-days/yr)  push 4 * pop +  smhq->s ;

.then ( time support)


( show ` Ok' then sub-prompt)
: prompt   ."  Ok"   state @  cell+  @execute ;

( set prompt in compile mode)
-: ."  (compiling)"  'compiler-mode  ;  cell+ !  ( bwa ha ha!)

defer ?show-stack

: ?stack
   depth 0< if  sp-reset  error" tried to pop an empty stack"  then
   depth [ 4096 64 - ] > if   ." too many items on the stack"  then
   ?show-stack ;

( Toggle-able "stack status" display, showing the top four items on the
  stack every time ?stack is executed.)

-:  radix preserve  hex  [ ' #s >body ] preserve -sep
   out-channel preserve >stderr
   out-channel @ >col @ if cr then  ."   --"
   0 3 do  i nth  18 u.r  -1 +loop  cr ;

: +stack       [ ]  is ?show-stack ;
: -stack  now nope  is ?show-stack ;


( Forth re-implementation of C interpret; semantics are exactly the same!)
: interpret
   begin  token =while  consume  ?stack  repeat  2drop ;

: evaluate  ( a u)
   start preserve  end preserve  ( save input source)
   first preserve                ( save our place in the input)
   over first !
   over start !  + end !
   interpret ;

variable zloading    ( C-string name of file being loaded)

( check-depth only prints anything out if depth has changed since the file
  started loading _and_ zloading is non-zero - ie, we're loading a file.)

: check-depth  ( saved-depth)
   depth swap -  2 - ( seems to always be 2!)
      =if  zloading @ =if
      ."  [ "  zcount type  ." : +depth " .  ." ]" ^  then  drop  then  drop ;

: show-depths  ( saved)   .  depth . ;

( XXX I was hoping to use on-exit to check stack depths, but I can't seem
  to get them to reconcile. More research is indicated. ;-)

: load-file  ( z")
   depth  on-exit check-depth
   -- depth  on-exit show-depths
   dup open-file-ro ( fd)  dup on-exit close-file
   zloading preserve  swap zloading !
   line preserve  1 line !
   radix preserve  decimal
   out-channel preserve  >stderr
   [ ' ?show-stack >body ] preserve  -stack
   read-file ( a u)  evaluate ;

( Consumes a token - a filename - and loads it.)
: ld  token, load-file ;

( how much dictionary space was consumed?)
: show-consumed  ( here)
   radix preserve  decimal
   out-channel preserve  >stderr
   here swap - .  ." bytes ))" ;

( Print some descriptive text and the amount of dictionary space consumed
  by loading. Consumes and prints the rest of the command line.)

: loading
   cr ." (( "  #LF parse type  space
   here  on-exit show-consumed  interpret ;

( Define words for use with the conditional compilation words.  No matter
  what chain we are compiling into, define the word in .forth.)

: -d   current preserve  forth  -1 constant ;
: -f   ( load file)  ld ;


: settings  ."
Display of the top four stack items is on by default. Use
   -stack   to turn it off,
   +stack   to turn it back on.

Digit separators (in number output) are on by default. Use
   -sep     to turn them off,
   +sep     to turn them back on.

Dictionary searches (via 'find') are case-sensitive by default.
   -case    makes them case-insensitive,
   +case    makes them case-sensitive again.

These defaults can be easily changed either by overriding them on the
command line, or by editing startup.mu4. Look for the word 'warm' near
the end of the file.
" ;


.ifdef old-banners

: banner-oldest
   ." muFORTH/ITC "
   cell 8 = if ." (64-bit) " then
   .ifdef clock
      build-time ( seconds since epoch)  time"
   .else
      build-time ( pushes a string!)
   .then  type  ."


Copyright (c) 2002-2012 David Frech. All rights reserved.
muFORTH is free software; see the file COPYRIGHT for details.

Type 'settings' to see a few of muFORTH's tweakable behaviours.
" ;

: banner-older
   ." muFORTH "
   cell 8 = if ." 64-bit " else ." 32-bit " then
   .ifdef clock
      build-time ( seconds since epoch)  time"
   .else
      build-time ( pushes a string!)
   .then  type
   build-commit  if  ( empty if not a checkout)
      ."  ("  16  type  ." ) "
   else drop ( empty string) then
   ."

Copyright (c) 2002-2012 David Frech. http://muforth.nimblemachines.com/

Type 'settings' to see a few of muFORTH's tweakable behaviours.
" ;

.then


( Print banner.)
: banner
   ." muFORTH "
   build-commit  if  ( empty if not a checkout)
      ." ("  8  type  ." ) "
   else drop ( empty string) then
   .ifdef clock
      build-time ( seconds since epoch)  short-time"
   .else
      build-time ( pushes a string!)
   .then  type
   ."  (http://muforth.nimblemachines.com/)
Copyright (c) 2002-2012 David Frech (see the COPYRIGHT file for details)

Type 'settings' to see a few of muFORTH's tweakable behaviours.
" ;

( Don't print file & lineno if interactive - ie, zloading is zero)
: .where
   zloading @  =if  zcount type  ." , line "
   @line  radix preserve decimal u.  ." : "  ^  then
   drop ;

-: ( z")
   >stderr  cr  .where  parsed type space  zcount type  cr  unwind ;   'abort !

: quit
   begin  cr  <stdin  typing evaluate  >stderr  prompt  again  [
   ( infinite loop, until error... )

: warm
   decimal \ [
   >stderr banner
   1 line !  ( so it's "correct" for interactive!)
   +stack +sep +case ( defaults - reset these how you like)
   command-line count  evaluate
   begin  quit  again  [

( Shortcut to load the memory dumper.)
.ifdef get-termios  ( useless without tty support)
: $see
   " ld lib/tty.mu4  ld lib/terminal.mu4  ld lib/see.mu4" evaluate ;
.then

( Identify ourselves.)
-d  muFORTH
