( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

-- loading Core memory

( NOTE: Before loading this code, define the following values that
  describe the target:

    cell-bytes  -- number of bytes in a cell
    addr-bits   -- number of bits in an address
    big-endian or little-endian  -- target's endianness

  *After* loading this code, the deferred word "choose-image" [see below]
  must be set to code specific to the target machine and its architecture.)

( Utility words for address and image sizes.)
: log2  ( n - exp mant)
   0 swap  begin  dup 1 and 0= while  1 u+  u2/  repeat ;

: power-of-two?  ( n)  log2 nip  1 = ;

( We are separating the notion of memory *images* and *regions*. An image
  has a size and an address; a region has an origin pointer, a current
  pointer, and an associated image.

  It is useful to have, eg, app, bootloader, signature, and vector
  *regions* in the flash *image*.)

( Regions have an origin pointer, a "current" pointer [what  here
  returns], and an associated image. When a region is created, it stores a
  pointer to the image's first byte in its body, before the here and origin
  pointers.)

( XXX This should probably be called r instead, but there is a *lot* of
  code that does "h preserve" that would have to change... I guess that
  qualifies as a leaky abstraction.)

variable h    ( dictionary pointer pointer; points to current *region*)
: dp   h @ ;  ( dictionary pointer)
: make-region  ( 'image)
   create  ,  0 , 0 ,  ( image, ptr, origin)
   does> cell+ h ! ;  ( h points to ptr cell)

-: ( tell us which region is current)
   dp ?if  ."  ("  cell- body> >name type  ." )"  then ;  is .extra-prompt

( Memory images should be stored in the dictionary like strings: prefixed
  by their length. When we push an image, we push the address of its first
  byte, but the previous cell countains the count, if we want to do bounds
  checking or address wrapping.

  Images are unnamed! They are "addressable" only as a by-product of a
  *region* that points into an image.)

( Create an image and leave a pointer to it.)
: make-image  ( #bytes - 'image)
   aligned  dup power-of-two?  0= if  error" image size not a power of 2"  then
   dup ,  here  swap allot ;

: 'image  dp cell- @ ;      ( image address is stored in region)
: #image  'image cell- @ ;  ( image size)

( Wrap an address to "fit" into the current image.)
: wrap   #image 1-  and ;

( Target can be a von Neumann or Harvard architecture machine, so we let
  the user decide how to handle choosing an image based on a target
  address.

  On a von Neumann machine we have multiple images, but we assume that they
  exist in a single address space. Given a target address, choose-image will
  figure out which image it resides in and set that as the current image.

  On a Harvard machine we can have multiple addresss spaces that contain
  the same addresses, so there is no way to choose an image based on the
  target address. In this case, choose-image will probably do nothing, and
  the user has to choose the image that they are interested in.)

( XXX This should maybe be called choose-region, since the images are
  nameless, and any region that points to a particular image will work.)

defer choose-image  ( target)
: image+  ( target - host)
   h preserve ( choose-image might change it)  dup choose-image
   wrap 'image + ;

: image-c@   image+ c@ ;
: image-c!   image+ c! ;

( After each definition of image-@ we use ' to leave on the stack the
  address of the correct word for du to use for that target.)

.ifdef little-endian
   cell-bytes 4 = .if  ( 32-bit target)
      : image-h@   image+ leh@ ;
      : image-h!   image+ leh! ;

      : image-@    image+ lew@ ;  ' lew@
      : image-!    image+ lew! ;
   .else cell-bytes 2 = .if  ( 8- or 16-bit target)
      : image-@    image+ leh@ ;  ' leh@
      : image-!    image+ leh! ;
   .then .then

.else .ifdef big-endian
   cell-bytes 4 = .if  ( 32-bit target)
      : image-h@   image+ beh@ ;
      : image-h!   image+ beh! ;

      : image-@    image+ bew@ ;  ' bew@
      : image-!    image+ bew! ;
   .else cell-bytes 2 = .if  ( 8- or 16-bit target)
      : image-@    image+ beh@ ;  ' beh@
      : image-!    image+ beh! ;
   .then .then

.else  error" You must define big-endian or little-endian."

.then .then

( The above mess left the address of a "cell@" word on the stack.)
: du-target
   [ #]    is |cell@
   addr-bits  |addr !
   cell-bytes |cell ! ;

-: ( buf a u)  swap image+ -rot  cmove ;  ( read from image)
: >image
   [ #]    is |read
   du-target ;

>image  ( default to image; this can change once we are chatting with target.)

meta
cell-bytes constant cell
: cells  \m cell * ;
: cell/  \m cell / ;
: cell+  \m cell + ;
: cell-  \m cell - ;

: here    ( - a)  dp       @ ;
: origin  ( - a)  dp cell+ @ ;  ( "region drop" also works)

: goto   ( a)    dp ! ;   ( set region pointer to a)
: allot  ( n)    dp +! ;

: c,    ( ch)   \m here image-c!       1 \m allot ;
: ,     ( w)    ( \m align)   \m here image-!  \m cell \m allot ;

forth
( Align an offset to an arbitrary power-of-2 alignment.)
: aligned-by  ( offset alignment - offset')  push  r@ 1- +  pop negate and ;
: mask-align,  ( b mask)  \m here  negate and  for  dup \m c,  next  drop ;

meta
: aligned         \m cell    aligned-by ;  ( cell aligned)
: align,    ( b)  \m cell 1- mask-align, ;
: align       0   \m align, ;

cell-bytes 4 = .if  ( only define "halfword" words for 32-bit targets)

: haligned                 2 aligned-by ;  ( halfword aligned)
: halign,   ( b)           1 mask-align, ;
: halign      0   \m halign, ;
: h,    ( h)    ( \m halign)  \m here image-h!       2 \m allot ;

.then

forth
( Return the start address and number of bytes in current region.)
: region   ( - a u)       dp 2@  ( start end)  over - ;

( Set both pointer [end] and origin [start] to the same value.)
: region!  ( start)   dup dp 2! ;
