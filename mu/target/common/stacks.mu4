| This file is part of muforth: https://muforth.dev/
|
| Copyright 2002-2025 David Frech. (Read the LICENSE for details.)

| Copying stacks between host and target.
|
| This is just one part of the interact code that needs to be standardized.
| Ideally, every target would use *exactly* the same interact code (perhaps
| excepting its dumping and disasming code).
|
| But this is a move in the right direction. This is a (slightly) tricky
| piece of code, and there were several not-quite-identical versions
| floating around, none of which was very readable.
|
| This file defines three words:
|
|   depth    return the depth, in target cells, of the target's data stack
|   stack>   copy some or all of the host's stack to the target
|   stack<   copy some or all of the target's stack to the host
|
| stack> *first* builds a local image of the target stack - in the RAM
| image - and *then* copies it, in one chunk, to the target.
|
| stack< *first* copies the target stack, in one chunk, to the host's RAM
| image, and *then* pulls the values out and pushes them onto the host's
| stack.
|
| In both directions, copying is limited to a small number of items to
| prevent crashing the target or the host.
|
| I tried to make the code as simple and readable as possible, and because
| it uses \m words for anything related to target cells, it should work
| unmodified for all targets.
|
| Users of this code should define three values before loading this file:
|
|   stack-cell       | the size (in bytes) of a stack value
|   stack-sentinel   | the *value* to be used; or leave undefined
|   dp0              | address of bottom of data stack memory
|
| If you don't want a stack sentinel - read on to find out what this is and
| why it's (sometimes) necessary - just leave it undefined; no space will
| be allocated for it on the stack.
|
| Users must also define four words for reading and writing the target's
| stack. The first two are simply synonyms for the words for reading and
| writing the target's RAM:
|
|   stack-read   ( buf a u)
|   stack-write  ( buf a u)
|
| The other two are synonyms for fetching and storing a single stack item
| to or from the host's ram image of the target's stack:
|
|   stack@  ( addr - value)
|   stack!  ( value addr)
|
| In both cases, addr is a *host* address; it has already been "converted"
| by image+ .
|
| stack@ and stack! used to be synonyms for image-@ and image-! (with the
| caveat that the code below let them do the image+ mapping for each item,
| instead of doing it once at the beginning of the stack copy); however,
| I'm experimenting with an oddball idea: an 8-bit machine, with 16-bit
| "cells" (in particular, instruction memory is cell-aligned), but with
| a 24-bit stack! Hence the separate stack-cell, stack@, and stack! words.
|
| This code *should* be trivially simple, but there is a twist: some
| targets require a *stack sentinel*, and this sentinel must be ignored by
| depth, added to the stack image by stack>, and skipped by stack<.
|
| What is a stack sentinel, and why do some targets require one?
|
| A simple and common optimization for Forth systems is to cache the top of
| the data stack in a register, commonly called "t" or "top". This makes
| both unary and binary operations much more efficient. With top in
| a register, an increment, complement, or negate operation (for example)
| can change the value in the register without touching memory. For
| a binary operation - an add, for example - the second operand is popped,
| top and second are added, and the result is put into the top register.
|
| In contrast, without top in a register, a unary operation requires a pop
| and a push, and a binary operation requires two pops and two pushes. It's
| easy to see that this is going to be slower and require more code.
|
| For the host to execute a piece of code on a target that caches the top
| of the stack in a register, the following steps must occur:
|
|   - the host creates a memory image of its stack and copies it to the target
|   - the target pops the top of the in-memory stack into its "top" register
|   - the target executes the code
|   - the target pushes top back to the in-memory stack
|   - the host copies the memory image of the target stack back to itself,
|     and pushes the results on its own stack
|
| If the stack that is copied to the target is empty, when the target pops
| the top of the stack into its "top" register to begin code execution it
| will underflow the stack and read garbage. If instead the stack always
| has a sentinel as its bottom-most value, a target started with an "empty"
| stack (consisting only of a sentinel value) will begin code execution
| with the sentinel value in its "top" register, and the stack will not
| have underflowed.
|
| When the host calculates the depth of the target stack, and when it
| copies the stack image back to itself, it has to make sure to skip the
| sentinel; but when creating a stack image for the target, the host makes
| sure to push a "fresh" sentinel and copy it to the target. This way if
| the target ends up underflowing the stack or otherwise pushing
| a "garbage" value onto it, the next time that code gets executed - using
| the above multi-step process - that garbage value is replaced by
| a recognizable sentinel.
|
| It's not complicated, but it *is* a bit subtle, and it takes some
| thinking about to get a solid mental picture of what's going on.
|
| To make the following code easier to read - whether or not a sentinel
| value is involved - we use the following constants:
|
|   dp-sentinel      | data stack bottom, *including* sentinel, if any
|   dp-empty         | data stack bottom, *excluding* sentinel, if any
|
| If no sentinel value is defined for a target, the two values will be
| *equal*; if there *is* a sentinel, dp-empty will point one target cell
| *lower* in memory (the stack is growing *down*).

dp0 dup constant dp-sentinel  .ifdef stack-sentinel  stack-cell -  .then
        constant dp-empty

variable dp          | target data stack pointer; points to *top* of stack
: dp!   dp ! ;       | XXX Are these useful, ugly, and/or pointless?
: dp@   dp @ ;

meta
: depth  dp-empty  dp@ -  stack-cell / ;
forth

| stack> *first* builds a local image of the target stack - in the RAM
| image - and *then* copies it, in one chunk, to the target.

| Move a stack item from the host stack to the target stack image.
: item>  ( cell a - a+)  tuck stack!  stack-cell + ;

: stack>  ( "push" stack to target)
   h preserve ram  ( make sure we are creating the stack in the ram image!)
   depth 0 max 32 min
   dp-empty  over stack-cell * -  dup dp! ( top of D stack)
   image+  swap for  item>  next  ( copy each item to D stack)
.ifdef stack-sentinel  stack-sentinel swap stack!  .else  drop  .then
   | Write stack image to target, *including* sentinel, if any)
   dp@ image+  dp@  dp-sentinel  over -  ( buf a u)  stack-write ;

| By default, we want numbers that the target would consider negative to be
| negative on the host stack as well. But we want this to be configurable
| by the user.
|
|   starget  (the default) turns on sign-extension;
|   utarget  turns it off.
|
| Since we want to be able to turn sign-extension off and on, let's make
| a defer'd word that acts on a target value as it gets copied from the
| target stack to the host stack.

defer t>h  ( target - host)    | "target to host" conversion

| Sign extend stack values when they come back from the target.
|
| We calculate the location of the sign bit from the size (in bytes) of
| a stack cell.

-: ( sign-extend target value)
   dup  [ 1  stack-cell 8 * 1-  <<  ( sign bit) #] and  2* - ;

   | NOTE: the following also works, but it's better suited to
   | assembly-language implemenations:
   |
   | [ 64 stack-cell 8 * - #] tuck <<  swap >> ;

: starget  ( set target stack to *signed*; sign-extension occurs)
   [ #]      is t>h ;  ( sign extend value)

starget  ( set default)

: utarget  ( set target stack to *unsigned*; no sign-extension occurs)
   ['] nope  is t>h ;  ( leave the value alone)

| Move a stack item from the target stack image to the host stack.
: item<  ( a - cell a-)  stack-cell - dup  stack@ t>h  swap ;

| stack< *first* copies the target stack, in one chunk, to the host's RAM
| image, and *then* pulls the values out and pushes them onto the host's
| stack.

: stack<  ( "pop" stack from target)
   h preserve ram  ( make sure we are copying the stack to the ram image!)
   \m depth 0 max 32 min  =if  dup  stack-cell *  ( #cells #bytes)
   | Read stack image from target, *excluding* sentinel, if any.
   dp@  2dup image+ -rot  ( buf a u)  stack-read
   dp@  + image+  swap for  item<  next  drop  ^  then  drop ;
