( V25 Kernel!
  Copyright 1995-1998 David A. Frech.

              ** IMPORTANT NOTE **
Following are register conventions for all V25 code:

 CS = CODE;  DS = WORDS.  Both in ROM.
 SS = RAM  **ALWAYS**; ES = IO-SEG **ALWAYS**
 AX, CX, DX = scratch  [AX used in NEXT, but so what]
 BX = t = top, sometimes in CODE routines is scratch
 SI = i = ip
 SP = s = Data stack pointer
 BP = r = Return stack pointer
 DI = w = Word pointer [in NEXT], but can be used as scratch

14-sep-1998. Changed to use still newer segment register conventions.
27-apr-2000. Changed to use new metacompiler.)

cr s" Kernel "  \ file[

( Start target code )

[with] debug   [if]    ." -*- DEBUG -*- "
               [else]  ." -!- EPROM -!- "  [then]

( Basic defining words.)
:D CREATE  NAME SHOW  0 ,  ;CODE  t PUSH,  w t MOV,  NEXT,  C;

:D PUSHES  CREATE  ;CODE  t PUSH,  0 [w] t MOV,  NEXT,  C;
           ( makes constant with no value! Useful when the )
           ( constant depends on the header size & align)

:D CONSTANT   PUSHES  , ( value)  ;D

:D 2CONSTANT  CREATE  , ,  ;CODE
     t PUSH,  2 [w] PUSH,  0 [w] t MOV,  NEXT,  C;

:D CARRAY     ( #bytes -)  PUSHES  RAM ,  ALLOT  ;D
:D ARRAY      ( #cells -)  2*  CARRAY  ;D
:D VARIABLE   1 ARRAY  ;D
                 ( compile ptr to ram, alloc 2 bytes ram)

( 12-oct-1999. Based on our experience with EMIT -backing up i-  - !!AGH!! -
  I'm adding proper deferred words. On second thought, I'll fix EMIT. It's
  nice to be able to have DEFERred USER variables...the cm @EXECUTE way is,
  in some very real ways, better. It's a hair longer, maybe, and a hair
  slower, but I'm not counting.)

00 [if]
:: DEFER    VARIABLE
   ;CODE   0 [w] w MOV,  SS: 0 [w] w MOV,  -2 [w] JMP,  C;
         (  do-constant       @          EXECUTE)
[then]

VARIABLE u  ( user pointer)
:D USER  ( #bytes)  CREATE  #USER ,  UALLOT
   ;CODE  t PUSH,  0 [w] t MOV,  ( offset)   SS: u ) t ADD,  NEXT,  C;

:D :  NAME  0 ,  ]  ;CODE  NEST,  w i MOV, ( pfa is new ip)  NEXT, C;


( Be EXTRA careful with addresses for primitives.  The compilation address
  of words that are called from high-level words -- that is, words with code
  fields -- is >here, the current location in `word' space.  The useful address
  for other primitives -- an address that goes into a code field instead of
  into a word -- is |here, in code space.

  Use `RESOLVES' with a HERE address - most of the time. IMPLEMENTS gets |here
  and starts the assembler.)

CODE lit   HERE RESOLVES 'lit
   t PUSH,  AX LODS,  AX t MOV,  BEGIN, ( for nope)  NEXT,  C;

CODES nope  ( useful no-operation)

CODE  DROP-EXIT  ( strange, but occasionally useful)
   t POP,  BEGIN,  UNNEST,  NEXT,  C;

CODES EXIT   HERE RESOLVES 'exit

( after this we can't use EXIT to skip rest of block...)
( but we've defined SKIP so we're OK!)


( 15-apr-2000. Changed to use `mov #newip,ax; jmp xx' in caller instead of
  `call xx; .word newip'.)

( ROM version pushes param address)
IMPLEMENTS 'does
(  NEST,  i POP,  CS: 0 [i] i MOV,  t PUSH,      w t MOV,  NEXT,  C;  )
   NEST,  AX i MOV,                 t PUSH,      w t MOV,  NEXT,  C;

( RAM version fetches first word of param and pushes)
IMPLEMENTS 'evokes
(  NEST,  i POP,  CS: 0 [i] i MOV,  t PUSH,  0 [w] t MOV,  NEXT,  C;  )
   NEST,  AX i MOV,                 t PUSH,  0 [w] t MOV,  NEXT,  C;

( do something like:)
( CREATE ... DOES>   ... ROM@ ... )
( CREATE ... EVOKES> ...  @   ... )

                       ( jump dest for 0br ?for next)
CODE br   HERE RESOLVES 'br     BEGIN,  BEGIN,  BEGIN, 
   0 [i] i MOV,  NEXT,  C;

CODE 0br  HERE RESOLVES '0br
   t t TEST,  t POP,  0= not UNTIL,
   i INC,  i INC,  ( skip addr if not taken)  NEXT,  C;

( FOR = PUSH )
CODE ?for  ( n -)    HERE RESOLVES '?for
   t AX MOV,  t t TEST,  t POP,
   0= not UNTIL, ( pop & branch if 0)
   i INC,  i INC,  ( else skip jump)  r DEC,  r DEC,
   AX 0 [r] MOV,  NEXT,  C;  ( push count on R)


( `next' executes n times; with param of 0 executes 64k times)
( index ranges over initial..1, decrementing)
CODE next     HERE RESOLVES 'next
   0 [r] DEC,  0= UNTIL, ( skip to branch code)
   r INC,  r INC,  ( drop count)
   i INC,  i INC,  ( skip branch addr)  NEXT,  C;


( Return stack operators)
CODE PUSH   ( n -)   HERE RESOLVES 'for  ( PUSH is the same)
   r DEC,  r DEC,  t 0 [r] MOV,  t POP,  NEXT,  C;

CODE POP    ( - n)
   t PUSH,  0 [r] t MOV,  r INC,  r INC,  NEXT,  C;

( 15-apr-2000. These three words are backwards from ANS. Hmm.)
CODE 2PUSH  ( n1 n2 -; R: - n2 n1)
   4 # r SUB,  t 2 [r] MOV,  t POP,  t 0 [r] MOV,  t POP,  NEXT,  C;

CODE 2POP   ( - n1 n2; R: n2 n1 -)
   t PUSH,  0 [r] t MOV,  t PUSH,  2 [r] t MOV,  4 # r ADD,  NEXT,  C;

CODE 2R@     ( - n1 n2; R: n2 n1 - n2 n1)   
   t PUSH,  0 [r] t MOV,  t PUSH,  2 [r] t MOV,  NEXT,  C;

CODE R@     ( - n)   BEGIN, ( for I)
   t PUSH,  0 [r] t MOV,  NEXT,  C;

CODES I  ( copy code of R@)

CODE  J
   t PUSH,  2 [r] t MOV,  NEXT,  C;


( Small numbers and increments)
CODE  2+  t INC,  BEGIN,  t INC,  NEXT,  C;
CODES 1+
CODE  2-  t DEC,  BEGIN,  t DEC,  NEXT,  C;
CODES 1-

 0 CONSTANT  0
 1 CONSTANT  1
-1 CONSTANT -1


( Stack operators)
CODE 2DUP   ( d - d d)
   AX POP,  AX PUSH,  t PUSH,  AX PUSH,  NEXT,  C;

CODE  2SWAP  ( d1 d2 - d2 d1)
   AX POP,  ( d2L)  DX POP, ( d1H)  CX POP,  ( d1L)
   AX PUSH, ( d2L)  t PUSH, ( d2H)  CX PUSH, ( d1L)  DX t MOV,  NEXT,  C;

CODE  2OVER  ( d1 d2 - d1 d2 d1)
   t PUSH,  s w MOV,  SS: 6 [w] PUSH, ( d1L)  SS: 4 [w] t MOV,  NEXT,  C;

CODE  2DROP  ( d -)       t POP,  BEGIN,  t POP,  NEXT,  C;
CODES DROP   ( n -)

CODE  DUP    ( n - n n)                         t PUSH,             NEXT,  C;
CODE  NIP    ( a b - b)      AX POP,                                NEXT,  C;
CODE  SWAP   ( a b - b a)    AX POP,            t PUSH,  AX t MOV,  NEXT,  C;
CODE  OVER   ( a b - a b a)  AX POP,  AX PUSH,  t PUSH,  AX t MOV,  NEXT,  C;
CODE  TUCK   ( a b - b a b)  AX POP,   t PUSH, AX PUSH,             NEXT,  C;

CODE ROT    ( a b c - b c a)
   AX POP,  DX POP,  AX PUSH,   t PUSH,  DX t MOV,  NEXT, C;

CODE -ROT   ( a b c - c a b)
   AX POP,  DX POP,   t PUSH,  DX PUSH,  AX t MOV,  NEXT, C;

CODE ?DUP   ( n - n n | 0)  ( dupe if not zero)
   t t TEST,  0= not IF,  t PUSH,  THEN,  NEXT,  C;


( Single-length math )
CODE SWAP-  ( a b - b-a)
   AX POP,  AX NEG,  AX t ADD,  NEXT,  C;

CODE -   ( a b - a - b)
   t NEG,  BEGIN,  AX POP,  AX t ADD,  NEXT,  C;  ( purer)

CODES +  ( a b - a + b)

CODE +UNDER  ( a b c - a+c b)
   DX POP,  AX POP,  AX t ADD,  t PUSH,  DX t MOV,  NEXT,  C;

CODE NEGATE  ( n - -n)   ( two's complement)   t NEG,  NEXT,  C;


( Single operand flag words)
CODE 0=  ( n - f)   1 # t SUB, ( cy=z)  t t SBB,  NEXT,  C;
CODE 0<  ( n - f)   t t ADD,  t t SBB,  NEXT,  C;


( Bit operators)
CODE OR   ( a b - ab|)   AX POP,                       AX t OR,  NEXT,  C;
CODE XOR  ( a b - ab^)   AX POP,                       AX t XOR, NEXT,  C;
CODE AND  ( a b - ab&)   AX POP,                       AX t AND, NEXT,  C;
CODE BIC  ( w m - wm~&)  AX POP,  t NOT, ( m is mask)  AX t AND, NEXT,  C;
( 15-apr-2000.
  I still wonder if `mask' and `word' shouldn't be interchanged here.)

CODE  NAND  ( a b - ab&~)   AX POP,  AX t AND,          t NOT,  NEXT,  C;
CODE  NOR   ( a b - ab|~)   AX POP,  AX t OR,   BEGIN,  t NOT,  NEXT,  C;
CODES NOT   ( a   - a~)     

( Controversy: should BIC apply a mask to a word, the way ! and +!
  work?  Or should one be able to say blah @  "20 BIC  bleek  ?
  Opting, as before, for the latter.  `-' doesn't apply like ! .)


( Two operand flag words)
CODE <   ( n n - f)
   AX POP,  t AX SUB,  0 # t MOV,  < IF,  t DEC,  THEN,  NEXT,  C;

CODE >   ( n n - f)
   AX POP,  t AX SUB,  0 # t MOV,  > IF,  t DEC,  THEN,  NEXT,  C;

CODE =   ( n n - f)
   AX POP,  t AX SUB,  1 # AX SUB,  t t SBB,  NEXT,  C;

CODE U<  ( u u - f)
   AX POP,  t AX SUB,  t t SBB,  NEXT,  C;


( Store operators)
CODE 2!   ( d a)   AX POP, ( hi)  SS: AX 0 [t] MOV,
                   AX POP, ( lo)  SS: AX 2 [t] MOV,  t POP,  NEXT, C;
CODE !    ( n a)   AX POP,        SS: AX 0 [t] MOV,  t POP,  NEXT,  C;
CODE +!   ( n a)   AX POP,        SS: AX 0 [t] ADD,  t POP,  NEXT,  C;
CODE C!   ( b a)   AX POP,        SS: AL 0 [t] MOV,  t POP,  NEXT,  C;

CODE !+   ( n a - a+2)
   AX POP,  SS: AX 0 [t] MOV,  t INC,  t INC,  NEXT,  C;


: ON   ( a -)  -1 SWAP !  ;
: OFF  ( a -)   0 SWAP !  ;

CODE FILL  ( a # b -)   CX POP,  DI POP,  cxne IF,  BEGIN,
   SS: BL 0 [DI] MOV,  DI INC,  LOOP,  THEN,  t POP,  NEXT,  C;

( we don't change ES so interrupts can assume it points to i/o)


( Fetch operators)
CODE  2@    ( a - d)
   SS: 2 [t] PUSH,  BEGIN,  SS:  BEGIN, ( Hack!)  0 [t] t MOV,  NEXT, C;
CODES ROM@  ( a - w)
CODES @     ( a - w)

CODE  @+    ( a - a+2 w)
   SS: BEGIN, 0 [t] AX MOV,  t INC,  t INC,  t PUSH,  AX t MOV,  NEXT,  C;
CODES ROM@+   ( a - a+2 w)

CODE  C@      ( a - b)
   SS: BEGIN, ( HACK!)  0 [t] BL MOV,  BH BH XOR,  NEXT,  C;
CODES ROMC@   ( a - b)

CODE  C@+     ( a - a+1 b)    ( sign extends!)
   SS: BEGIN, ( HACK!)  0 [t] AL MOV,  t INC,  t PUSH,
   CBW,  AX t MOV,  NEXT,  C;
CODES ROMC@+


( Byte/word operators)
CODE >HILO   ( w - hi lo)
   AX AX XOR,  BH AL MOV,  AX PUSH,  BH BH XOR,  NEXT,  C;

CODE LOHI>   ( lo hi - w)
   AX POP,  BL BH MOV,  AL BL MOV,  NEXT,  C;


( Shift and rotate)
( 29-apr-2000. ANS specifies LSHIFT and RSHIFT, both logical, and no
  ROTATE. 2/ and 2* are intended for signed numbers.)

CODE ASHIFT  ( n1 shifts - n2;  shifts<0 right, >0 left)
   CX POP,  t CX XCHG,  CX CX OR,  0< IF,  CX NEG,  CL t SAR,
   ELSE,  CL t SHL,  THEN,  NEXT,  C;     ( arithmetic)

CODE SHIFT  ( n1 shifts - n2;  shifts<0 right, >0 left)
   CX POP,  t CX XCHG,  CX CX OR,  0< IF,  CX NEG,  CL t SHR,
   ELSE,  CL t SHL,  THEN,  NEXT,  C;     ( logical)

CODE ROTATE  ( n1 rotates - n2;  like SHIFT)
   CX POP,  t CX XCHG,  CX CX OR,  0< IF,  CX NEG,  CL t ROR,
   ELSE,  CL t ROL,  THEN,  NEXT,  C;

CODE 2*   BEGIN,  t t ADD,    NEXT,  C;  ( faster than SHL -- daf)
CODE 2/   1 # t SAR,  NEXT,  C;  ( signed)
CODE U2/  1 # t SHR,  NEXT,  C;  ( unsigned)

2 CONSTANT CELL
CODES CELLS  ( = 2*)
CODE  CELL+   2 # t ADD,  NEXT,  C;
CODE  CELL-  -2 # t ADD,  NEXT,  C;


( Memory words)
: ERASE  ( addr #bytes -)  0 FILL  ;  ( FILL uses byte #)
  ( use CELLS ERASE for word arrays.)

CODE INDEX  ( index 'array - 'element)
   DI POP,  DI DI ADD,  DI t ADD,  NEXT,  C;


( Non-linears)
CODE ABS  ( n - u)     t t TEST,  0< IF,  t NEG,  THEN,  NEXT,  C;
CODE MIN  ( n n - n)   AX POP,  AX t CMP,  > IF,  AX t MOV,  THEN,  NEXT,  C;
CODE MAX  ( n n - n)   AX POP,  AX t CMP,  < IF,  AX t MOV,  THEN,  NEXT,  C;

: WITHIN  ( n lo hi - f, TRUE if lo <= n < hi)
    OVER - ( hi-lo) PUSH   - ( n-lo)  POP U<  ;


( Execution)
00 [if]  ( for when, someday, I want DEFERred words.)
CODE TO  ( xt -)
   0 [i] w MOV,  i INC,  i INC,  0 [w] w MOV,  SS: t 0 [w] MOV,
   t POP,  NEXT,  C;     ( lit  ROM@  !  )
[then]

CODE EXECUTE   ( pfa)     t w MOV,  t POP,  -2 [w] JMP,  C;
CODE @EXECUTE  ( addr-of-pfa -)
          SS: BEGIN,  0 [t] w MOV,  t POP,  -2 [w] JMP,  C;
CODES ROM@EXECUTE  ( rom-addr-of-pfa -)  ( !! ROM ONLY !!)


( Basic double words)
:D 2VARIABLE  2 ARRAY  ;D

CODE D+  ( 1lo 1hi 2lo 2hi - Slo Shi)
   CX POP, ( 2lo)  DX POP, ( 1hi)  AX POP, ( 1lo)
   CX AX ADD,  AX PUSH, ( Slo)  DX t ADC, ( Shi)  NEXT,  C;

CODE DNEGATE  ( d - 0-d)
   t NEG,  AX POP,  AX NEG,  AX PUSH,  0 # t SBB,  NEXT,  C;

: D-  DNEGATE  D+  ;


( Large memory words, aka `huge' pointer words.  We need these to install
  vectored interrupts.)
( Careful!  !L and @L change DS, so interrupts cannot rely on it.
  Or, use this -only- to install interrupts and not otherwise, and do it
  before interrupts are enabled.)

CODE !L   ( n offset seg)
   w POP,  AX POP,  DS PUSH,  t DS MOV,  AX 0 [w] MOV,
                    DS POP,  t POP,  NEXT,  C;

CODE @L   ( offset seg - n)
   w POP,  DS PUSH,  t DS MOV,  0 [w] t MOV,  DS POP,  NEXT,  C;


( Higher Math          Floored division. )
CODE FM/MOD  ( d n - r q)  ( signed FLOORED divide; 32/16=16)
   DX POP,  AX POP,  ( DX:AX = dividend)
   BX FLOOR,  ( q = AX; r = DX)  ( macro defined in meta.d4)
   DX PUSH, ( r)  AX BX XCHG, ( q)  NEXT,  C;

CODE */MOD  ( n1 n2 n3 - r q)  AX POP,  DX POP,  DX IMUL,
   ( DX:AX = prod)  BX FLOOR,  DX PUSH, ( r)  AX BX XCHG, ( q)  NEXT,  C;

CODE S->D   ( n - d)  ( sign-ext)
   t PUSH,  t t ADD,  ( Cy=Sign)  t t SBB,  NEXT,  C;


( Higher math         UNSIGNED division)
CODE UM/MOD  ( ud u - r q)  ( unsigned divide; 32/16=16)
   DX POP,  AX POP,  ( DX:AX = dividend)
    t DIV,  DX PUSH, ( r)  AX t MOV, ( q)  NEXT,  C;

CODE U*/MOD  ( u1 u2 u3 - r q)  AX POP,  DX POP,  DX MUL,
   ( DX:AX = prod)  t DIV,  DX PUSH, ( r)  AX t MOV, ( q)  NEXT,  C;


( Higher math          Multiplication )
CODE *  ( n1 n2 - prod)  ( signed single-length multiply)
   AX POP,  t IMUL,  AX t MOV,  ( lo word)  NEXT,  C;

CODE M*  ( n1 n2 - d)    ( signed multiply, 16*16=32)
   AX POP,  t IMUL,  AX PUSH,  DX t MOV,  NEXT,  C;

CODE UM*  ( u1 u2 - ud)  ( unsigned 16*16=32)
   AX POP,  t MUL,  AX PUSH,  DX t MOV,  NEXT,  C;


( Higher math          High level )
: */    ( n1 n2 n3 - n1*n2/n3)   */MOD  NIP  ;
: /MOD   ( n1 n2 - r q)   PUSH  S->D  POP ( d1 n2)  FM/MOD  ;

: /      /MOD  ( r q)  NIP  ;
: MOD    /MOD  ( r q)  DROP ;

: U*/   ( u1 u2 u3 - u1*u2/u3)   U*/MOD  NIP  ;
: U/MOD  ( u1 u2 - r q)   0 SWAP ( ud1 u2)  UM/MOD ( r q)  ;
: UMOD   ( u1 u2 - r)     U/MOD   DROP  ;


( Multitask!)

( 15-sep-1998.  This is new.  I figured this all out when I couldn't sleep.
  There is a new [to me] and beautiful way to do multitasking that is in
  between my old way and the elusive polyFORTH brochure's "one machine
  instruction per task" way.  My new way is the middle way, and is intimately
  related to indirect threaded code; the major difference is that it is -not-
  the `canonical Chuck' way to do ITC.  The `word' pointer -- in this case
  it points to a -task- -- points -at- rather than -after- the code pointer.
  It just works out more nicely this way.

  There is a necessary adjustment, however.  In this new way what determines
  whether a task is awake or asleep is its code pointer.  If it points to
  `robin' the task is asleep, and `robin' will cycle to the next task [and
  take only two instructions!].  If the task is awake, its code points to
  `restore', which sets up the user pointer `u' and pops the task's context
  and executes `next', as usual.  The adjustment is this:  where do we store
  the sleep/wakeup count information, which used to be also the awake/asleep
  flag?  The answer is, `where it matters'.  In the case of an i/o queue,
  the `right place' for this information is in the queue, -not- in the task
  that reads from or writes to it.

  In this new world order the tasks or interrupt service routines that used
  to simply increment or decrement a counter have a little bit more work to
  do to wake or lull a task.  But it's not too bad, and the task loop is
  purer, more flexible, and one instruction quicker per task!

  Generally, when a task is using a resource that resource points to the task.
  This has two purposes:  when this pointer is zero, the resource is -free-.
  When non-zero, it points to the task that should be woken when the resource
  is `ready'.  The task points back at some part of the resource, thru the
  `depend' pointer.  Thus if a task is waiting on serial input from a queue,
  the queue -resource- would point to the task; the task's `depend' would
  point to the count of characters available to be read from the queue.  When
  a character comes in from the serial port, the service routine puts the
  character in the queue and increments the count.  It then checks if the
  `depend' pointer has become non-zero, or >0, or whatever the criterion is.
  If so, it wakes the task by changing its `status' code pointer.

  Alternatively the ISR could increment the counter pointed to by the task's
  `depend' pointer.  ISR.owner->task.depend->counter.  These details are a
  bit fuzzy still.)

00 USER status      ( code pointer; determines the wakefulness of the task)
 2 USER me          ( synonym)
 2 USER link        ( link to next task in list)
 2 USER bottom      ( bottom of D stack)
 2 USER top         ( pointer to saved stack)

( 15-sep-1998.  This is now different; see above.  The idea still applies;
  only the location of the counters has changed.  Well, that and that the
  counters now run `the right way'.

  If a task has an associated IRQ, use STATUS as a sema-
  phore -- use AWAIT to sleep and <task> #] dec, [in IRQ
  routine] to awaken.  Incrementing and decrementing STATUS is
  an atomic action.  In this case only  ACTIVATE ever sets STATUS.
  This will happen before the interrupt is enabled so it's OK.

  In other cases it doesn't matter; however, incrementing and
  decrementing STATUS makes a useful auto-wakeup semaphore.)

( Multitask! )
00 [if]  ( Why am I removing this? See comments near EMIT and serial code.)
assemble
LABEL STALL  ( backup i and pause)
   i DEC,  i DEC,    ( 4~ = 0.5 us; a quick branch!)
[then]

CODE PAUSE
   SS: u ) w MOV,  ( get user to w)   BEGIN,  BEGIN, ( for 1DOWN, DOWN)
   t PUSH,  r PUSH,  i PUSH,  ( CS=code, DS=word, SS=ram)
   SS: s top [w] MOV,   ( save sp to TOP)

   ( 6  6  6  2 8 3  2 2 3 = 38~ = 4.75 us @ 8MHz)
   
LABEL WAIT
   SS: link [w] w MOV,  SS: status [w] JMP,
   ( follow link; jump thru status)

   ( 2 8 3  2 17 3 = 35~ = 4.375 us)

LABEL RUN   ( w=task user area)
   SS: w u ) MOV,       ( setup new user)
   SS: top [w] s MOV,   ( new stack)
   i POP,  r POP,  t POP,   NEXT,  C;

   ( 2 2 3  2 8 3  12  12  12 = 56~ + NEXT = 56 + 38 = 94~ = 11.75 us)
   ( So, PAUSE + restore + NEXT = 132~ = 16.5 us)


( After much thinking and head-scratching - and constantly getting it wrong! -
  I'm returning, once again, to the simplest solution. I wanted to avoid
  disabling/enabling interrupts, but I can't see how to do it. Decrementing
  the `semaphore' counter and setting the task status based on the result
  must be an atomic operation. Remember that the effect of STI - to enable
  interrupts - is delayed until the -end- of the -following- instruction.)

CODE 1DOWN  ( a)
   SS: u ) w MOV,  ( get user to w)
   CLI,  SS: 0 [t] DEC,  0< IF,
   STI,  SS: WAIT # status [w] MOV,  ( set task to WAIT state)
   t POP,  \ swap  ) JMP, ( to pause)   THEN,  STI,  t POP,  NEXT,  C;
   
CODE DOWN  ( n a)
   SS: u ) w MOV,  ( get user to w)  AX POP, ( n)
   CLI,  SS: AX 0 [t] SUB,  0< IF,
   STI,  SS: WAIT # status [w] MOV,  ( set task to WAIT state)
   t POP,  \ swap  ) JMP, ( to pause)   THEN,  STI,  t POP,  NEXT,  C;

( My `UP,' macro doesn't work. Instead I will just say this: When incrementing
  semaphore counters, use ADD and not INC! INC doesn't set carry.)


( Multitask! )
00 [if]
VARIABLE saved-link
: SINGLE   link @  saved-link !  me link !  ;  ( pt to self)
: MULTI    me link @ = IF  saved-link @  link !  THEN  ;
[then]

: HERS     ( 'task user-var - 'addr)  +  me -  ;
           ( user 'task - 'addr   also works!!)

( Two states a task can have.)
: WAKE     ( 'task)   [ RUN ]   LITERAL  SWAP  !  ;
: LULL     ( 'task)   [ WAIT ]  LITERAL  SWAP  !  ;
: STOP     me LULL  PAUSE  ;

: 1PUSH  ( a w -- a-2)  -2 +UNDER  OVER !  ;

: BOTTOM-STACK  ( task - top)
   bottom HERS @   "cafe 1PUSH ( sentinel)  ;

: COPY-STACK  ( x1 .. xn n task - top)
   BOTTOM-STACK   OVER CELLS - ( top)  PUSH R@
   SWAP ( n) ?FOR  !+  NEXT THEN  DROP   POP ( top)  ;

: TOP-STACK  ( ip task 'top - task)
   OVER ( u)  "face 1PUSH ( u-2) 1PUSH ( rp)  ROT 1PUSH ( ip)
   OVER top HERS !  ;

: #ACTIVATE  ( x1 .. xn task n)
   SWAP  PUSH R@ ( task)  COPY-STACK ( top)
   2POP ( top task ip)  SWAP ROT  TOP-STACK  WAKE  ;

: ACTIVATE  ( 'task)
   DUP  BOTTOM-STACK ( task top)  POP ( task top ip)  -ROT
   TOP-STACK  WAKE  ;

( Multitask!    Stacks )
CODE RP!  SS: u ) r MOV,  r DEC,  r DEC,  "face # 0 [r] MOV,  NEXT,  C;
   ( start of user area - 2 is bottom of return stack)

CODE SP!  SS: u ) t MOV,  SS: bottom [t] s MOV,  "cafe # t MOV,  NEXT,  C;
   ( data stack bottom is in bottom)

CODE DEPTH  ( - #words)  t PUSH,  SS: u ) t MOV,
   SS: bottom [t] t MOV,  ( bottom @)  s t SUB,
   1 # t SAR,  t DEC,  NEXT,  C;

: $DEPTH  ( task - depth)  DUP bottom HERS @  SWAP top HERS @ -  2/  3 - ;

( Multitask!    Task Definitions)
         ( sizes of D stack, R stack, User )
:D BACKGROUND  ( link #s #r #u - 'link)   push ( #u)
     PUSHES   HERE  push  0 , ( >user)   HERE  push  0 , ( >bottom)
     rot  , ( link)  swap  ALLOT  ( D stack)
     RAM  pop ( 'bottom)  !
     ALLOT  ( R stack)  RAM  r@ ( 'user)  !
     pop  ( >user)  pop  ( #u) ALLOT  ;D

:D CIRCLE   ( link -)  ( close the circle of ROM definitions)
   '  4 + ( to link field)  ! ( to image)  ;D


(  Usage:  00 s r u BACKGROUND panel1
              s r u BACKGROUND watchdog ... CIRCLE panel1 )

(  Scary picture:
    <----ROM------>                  RAM
    CONST       CONST               -------
    'user <-+   'user -----+        D stack
    BOTTOM  |   BOTTOM  ---|------> -------    ^  lower
    link    +-- link       |        R stack    |
                           +------> -------   ---
                                     User      |
                                               v  higher
)


( Internal V25 I/O ES=IO-SEG!!)
CODE IO@ ( reg# - b)
   ES: 0 [t] BL MOV,  BH BH XOR,  NEXT,  C;

CODE IO!  ( b reg# -)
   AX POP,  ES: AL 0 [t] MOV,  t POP,  NEXT,  C;

CODE IOW@  ( reg# - w)
   ES: 0 [t] t MOV,  NEXT,  C;

CODE IOW!  ( w reg# -)
   AX POP,  ES: AX 0 [t] MOV,  t POP,  NEXT,  C;

: SOURCE  ( mask port -)  TUCK  IO@ OR        SWAP IO!  ;
: SINK    ( mask port -)  TUCK  IO@ SWAP BIC  SWAP IO!  ;

( Make a comment on the size so far.)
cr ." Basic kernel, including multitasker and simple i/o, but excluding"
cr ." interrupts and serial i/o, takes "  HERE .  ." bytes of word space and"
cr 'CODE . ." bytes of code."


( Interrupt words)
CODE BRK   3 # INT,  NEXT,  C;
CODE CS@    ( - cs)  t PUSH,  CS t MOV,  NEXT,  C;
CODE +IRQ   STI,  NEXT,  C;
CODE -IRQ   CLI,  NEXT,  C;


( 01-jun-1999. Changed how all the memory bank, serial port, and macro ser-
  vice constants work. Now they do all their fancy footwork on the host. This
  works, as it turns out, for both colon and assembler words. We use the con-
  stants generated to compile machine code or literals.

  Now this is where this gets a little bit tricky. One of the powerful things
  about doing the banking on the target is that it becomes possible to switch
  banks, or serial ports, and then execute -exactly- the same code as before,
  and it will affect the new place instead of the old. This could be handy,
  and for words like RBINSTALL is a necessity.

  Except there is a sort of work-around: BANK returns an offset, `ds' adds
  another offset to it to get an execute-time constant. Essentially making
  the `run-time' banking explicit where we need it.

  What is the right thing to do? Are we often going to be changing serial
  ports `on the fly' or executing common code that would expect this kind
  of differentiation - and, if the latter, why aren't the 'bank's and
  'serial's USER variables?

  So many questions.

  Here's a fancy idea. Make the defining word for these special offset words
  make two words - like `cond' does - one in the meta compiler and one in
  the regular, forth, vocab. The first is for compiling target colon words -
  it would compile a literal; the second is for CODE words.

  But here's another issue: Which port does the host-side code - for CODE
  words - use? Where is that stored? And how set? Urg.

  We have to decide if we need the transparent ability to do this stuff on
  the target, or if we can do it explicitly as needed. That issue also brings
  up the question of ownership of ports, and how interrupts work. All this is
  related.)

( Memory bank stuff -- for fast IRQ routines)       hex
VARIABLE 'bank
:D BREG  CREATE ,  EVOKES>  ( DOES> ROM@)  'bank @  +  ;
  02 BREG ip  ( 04 BREG pswsave   06 BREG ipsave)
  08 BREG ds  ( 0a BREG ss )  0c BREG cs  ( 0e BREG es )
( 10 BREG di    12 BREG si )  14 BREG bp  ( 16 BREG sp )
( 18 BREG bx    1a BREG dx    1c BREG cx    1e BREG ax)

: BANK  ( bank# -)  20 *  e00 +  'bank !  ;
: +RAM  ( enable internal)    40 feb SOURCE  ;
: -RAM  ( disable internal)   40 feb SINK    ;


( 16-sep-1998.  Changed how this works.  I'm going to be using bank-switched
  serial interrupts and wanted an easier way to set up the registers.  The
  most trivial way is to pass a vector of registers and copy them from ROM
  to the internal RAM.  We'll keep the BREG words for debug.

  19-sep-1998.  Created HANDLER to do vectored interrupt installation, then
  factored out common code with RBHANDLER.

  21-aug-1999. RBHANDLER now sets BP to the calling task. Now we don't have
  to load things in such a funny order! And configuration is easier!)

( pfa: IRQreg IRQbank bank# ...)
: IRQbank  ( pfa - IRQreg pfa+ bank#)  ( set bank/priority from word)
   ROM@+ ( IRQreg)  "47 OVER IO! ( disable IRQ)  SWAP  ( IRQreg pfa+)
   ROM@+ ( IRQbank) PUSH   ROM@+ ( bank#)  7 AND ( sanity)  DUP
   R@ ( IRQbank) IO@ 7 BIC OR  POP IO!  ( set bank#)  ;
   
: IRQreg   ( IRQreg - IRQreg pri)   DUP ( IRQreg) IO@  7 AND  ;

( 'code vector# priority IRQpri IRQreg)
:D HANDLER   CREATE  , , , , , ( 'code)
   DOES>  ( install)  IRQbank  ( IRQreg pfa+ bank#)  DROP
   ROM@+ ( vector)  2* 2* PUSH  ROM@ ( code)  R@ 0 !L   CS@ POP 2+ 0 !L
   IRQreg  ( enable IRQ, vectored)  SWAP IO!  ;

decimal
( 'code AX CX DX BX SP BP SI DI ES CS SS DS bank# IRQbank IRQreg)
( CS is ignored. It is set at install time from CS of caller, prob. Bank 7.)
( BP is ignored. It is set at install time from u - the user pointer.)
:D RBHANDLER  CREATE  15 for ,  next ( regs, bank)  ,  ( 'code)
   DOES>  ( install)  IRQbank ( IRQreg pfa+ bank#)  BANK
   +RAM  ds  12 FOR  ( regs)
      PUSH  ROM@+  R@ IOW!  POP 2+  NEXT  DROP ( dest)
   ROM@ ( code) ip IOW!  CS@ cs IOW! ( fix cs)  me bp IOW! ( easy!)  -RAM
   IRQreg  "10 OR ( enable IRQ, Bank Switch)  SWAP IO!  ;


( 23-sep-1999. Moved all the TIMER code to timer.d4.)

( 16-sep-1998.  I've moved to Timer 1 just in case we want to use Timer 0,
  which has an output pin [optionally] connected to it, for something else.
  Also the RAM allocation has changed.  Here is the rationale:  The bottom
  two register banks overlap the macro service and DMA channels.  DMA stuff
  overlaps the bottom two macro service channels.  Register banks take 32
  bytes, macro service and DMA eight.  Also, we want to keep the lowest in
  memory [and -highest- priority] slots open for serial receive.  Thus we
  should put the Timer in slot 4.  Macro/DMA take 0 & 1; Serial could take
  2 & 3. The timer definitions are now in timer.d4.)

02 EQU serial0-priority
03 EQU serial1-priority
04 EQU timer1-priority


( V25 Serial)

( 17-aug-1999. Created, with much anguish and gnashing of teeth.)
( 18-aug-1999. Added code so everything is self-installing.)
( 19-aug-1999. For the life of me, I can't get V25 xmit interrupts to work.
  It just sits there like a stubborn mule. So I'm going back to the simple.
  With a slight hack to the multitasker - the addition of the entry point
  `STALL' which backs up ip so that the calling word will get re-executed
  after PAUSE - I have a simple, fast way of doing output that doesn't seem
  to interfere with tasking. Good enough.)

( 12-oct-1999. Ack. After having wasted a couple of hours I realized the
  ugliness of EMIT's `backing up i' behavior: it doesn't work if EMIT is
  called by EXECUTE or @EXECUTE!  ARGH! So we're back to a high-level EMIT,
  slightly slower to be sure, but more predictable. So the ugly STALL can
  go away.)

( See the file SEMAPHORES for the thinking behind all this.)

( with variable-length-queues   ( this could change)
( Define `serial1-config' to also configure port 1.)

( Host-side definer.)
:O field  ( offset size - offset+size)   over constant  +  ;O

( For simplicity, and since output queues don't seem to exist any more -
  for right now anyway - I'm making queues 256 bytes long. Masking is now
  an AND immediate.)

( Queue structure:)
   00
   02 field qavail   02 field qroom
   02 field qrd      02 field qwr
[with] variable-length-queues [if]
   02 field qmask      [then]
   00 field qdata   \ drop


[with] debug [if]
:O .q   ( q)   hex  4 for  dup  \t @ .  2 +  next  cr
  16 for  2 for  8 for  dup \t C@ .b16 space  1+  next  space  next  cr  next
   drop  decimal  ;O
[then]

:D QUEUE  ( user-queue-var - qram: for RBINSTALL)
   CREATE  RAM ,   ( qvar) ,  RAM  ( - qram)
           256 qdata +   ALLOT
           ( ROM:  0:data  2:queue-var)

   ;CODE     t PUSH, ( extra hand)  0 [w] t MOV, ( ram)
[with] variable-length-queues
[if]
       4 [w] AX MOV,  SS: AX  qroom [t] MOV, ( size)
             AX DEC,  SS: AX  qmask [t] MOV,
[else]
                    SS: 256 # qroom [t] MOV,
[then]
0 [if]
       6 [w] AX MOV,  SS: AX  qport [t] MOV,
[then]
          AX AX XOR,  SS: AX    qrd [t] MOV,
                      SS: AX    qwr [t] MOV,
                      SS: AX qavail [t] MOV,
       2 [w] AX MOV,  SS:      u )  w MOV, ( w = 'task from u, the caller)
0 [if]
                      SS: w   qtask [t] MOV,
[then]
           AX w ADD, ( pt to q var)
                      SS: t       0 [w] MOV, ( user var = q)
   t POP,  NEXT,  C;


( Serial ports)
02 USER port
:D SREG  CREATE ,  EVOKES>  ( DOES> ROM@)  port @  +  ;

decimal
 00 SREG RxData     02 SREG TxData    08 SREG SerialMode
 09 SREG RateSrc   "0a SREG RateDiv
"0c SREG ErrIRQ    "0d SREG RxIRQ    "0e SREG TxIRQ    
: SERIAL  ( port# -)  1 AND  16 *  "f60 +  port !  ;
:O serial  ( offset port# - port)  1 and  16 *  "f60  +  +  ;O



( The New Transmit Code.)
( 12-oct-1999. AAAAAAAAAAAAAAAAAAAAAAAAAAAGGGGHHH! I just spent two hours
  in total confusion because of this! I -vectored- a word that calls EMIT,
  but because EMIT backs up i, it re-executes the @EXECUTE, but there is
  nothing on the stack!  AGH! Maybe I should make proper deferred words,
  or else a less hacky way to do EMIT...

  I've decided to fix EMIT. Phew.)

00 [if]  ( clever but FUCKED UP EMIT...)
CODE EMIT  ( b -)
   SS: u ) w MOV, ( user)  SS: port [w] w MOV,
   ES: "80 # TxIRQ [w] BYTE TEST,  STALL 0< UNTIL,  ( backs up i!)
   ES: "47 # TxIRQ [w] BYTE MOV,  ES: BL TxData [w] MOV,
   t POP,  NEXT,  C;
[then]

( The slower but less troublesome EMIT)
0 [if]
: EMIT   JUMP>  BEGIN  PAUSE  >JUMP  TxIRQ IO@  "80 AND  UNTIL
                   "47 TxIRQ IO!  TxData IO!  ;  ( elegant, no?)
[else]
: EMIT   BEGIN  PAUSE  TxIRQ IO@  "80 AND  UNTIL
                   "47 TxIRQ IO!  TxData IO!  ;  ( elegant, no?)
[then]

02 USER input      ( pointer to input queue)

CODE INPUT-AVAILABLE   ( - 'q 'sema)
   SS: u ) w MOV, ( get user to w)  SS:  input [w] w MOV,
   t PUSH,  w PUSH, ( q)  qavail [w] t LEA,  NEXT,  C;

CODE Q@   ( 'q - ch)   ( increment ROOM)
   AX AX XOR,
   SS:   qrd [t] w MOV,  SS: qdata [t+w] AL MOV,  w INC,
[with] variable-length-queues
        [if]  SS: qmask [t] w AND,  [else]  255 # w AND,  [then]
   SS:  w  qrd [t] MOV,
   SS:   qroom [t] INC,  AX t MOV,  NEXT,  C;
 
: KEY?   ( - #)   INPUT-AVAILABLE    NIP   @  ;
: KEY   ( - ch)   INPUT-AVAILABLE  1DOWN  Q@  ;


( ReceiveISR has to do the equivalent of `OUTPUT-ROOM  1DOWN  Q!'.)

( WARNING! ReceiveISR keeps its write pointer in a register, so doing
  Q! to the same queue - from Forth - will not work!)

LABEL ReceiveISR
   ( A context-switched ISR - so much of the state is kept in registers.)
   ( DS = ram; ES = i/o; SS = ram)
   ( AX = scratch; t = queue; CX = unused; DX = write mask)
   ( i = port; w = write; r = task)

   STI,
          qroom [t] DEC,  0< not IF, ( there's room; go ahead)
   ES: RxData [i] AL MOV,  AL qdata [t+w] MOV,   w INC,  DX w AND,
     1 # qavail [t] ADD,  carry IF,
        RUN # 0 [r] MOV, ( wake waiting task)  THEN,
   FINT, IRETRB,  THEN,
   ( no room; increment dropped counter and set room back to 0)
   0 # qroom [t] MOV,  ( dropped [r] INC,)  FINT,  IRETRB,  C;


( Set up for channel 0.)
( 'code AX CX DX BX SP BP SI DI ES CS SS DS bank# IRQbank IRQreg)
  ReceiveISR
        00
           00 255 ( mask)
                 input   QUEUE input0 ( 'q)
                    32 ALLOT RAM ( stack)
                       00 00 00 serial
                             00 io-seg
                                   00 ram-seg
                                         ram-seg
                                            serial0-priority
                                                   ErrIRQ 00 serial
                                                          RxIRQ 00 serial
RBHANDLER ReceiveISR0  ( Bank Switched version; installs itself when called!)


[with] serial1-config [if]

( Set up for channel 1.)
( 'code AX CX DX BX SP BP SI DI ES CS SS DS bank# IRQbank IRQreg)
  ReceiveISR
        00
           00 255 ( mask)
                 input   QUEUE input1 ( 'q)
                    32 ALLOT RAM ( stack)
                       00 00 01 serial
                             00 io-seg
                                   00 ram-seg
                                         ram-seg
                                            serial1-priority
                                                   ErrIRQ 1 serial
                                                          RxIRQ 1 serial
RBHANDLER ReceiveISR1  ( Bank Switched version; installs itself when called!)
[then]


( Now host versions of the same thing, to make writing assembler stuff
  less painful.)

( This makes me wonder if we shouldn't keep the host and target compiler
  words completely separate, instead of keeping them somewhat apart by having
  separate interpret and compile loops - meta-interpret, host-interpret, ] ,
  and >] . Would that mean another vocabulary? And how would that work,
  exactly?

  Actually, in the even larger sense - or maybe the slightly smaller one -
  it's silly for me to be executing on the target all this fancy name stuff;
  it should be on the host - then usable in assembler and colon words - and
  just compiles literals on the target. Duh!)

( 16-sep-1998.  In order to specify bps rates > 65535 I've decided to rename
  BPS to 50xBPS.  Now the argument is 50s of bits per second.  This allows
  us to specify the maximum bps rate possible on an 8MHz V25, which is 2 Mbps.

  The calculation is a little tricky.  Since the input speed is divided by
  50 already, we divide into 4,000,000 50 /, that is, 80,000.  Well, sort of.
  We divide into twice that, 160,000, so we can round up by adding one and
  then dividing by 2.  This also makes the loop work well.)

: 50xBPS  ( 50bits/sec -)   1000 160 ROT */  ( 160,000 50xbps /)  1+ ( round)
   -1 ( RateSrc)  BEGIN  1+  SWAP U2/ SWAP  OVER  256 U< UNTIL
   RateSrc IO!  RateDiv IO!  ;
   ( RateSrc = n means use fClk/[2^[n+1]] for rate divisor clock.  0 means
     8 MHz / 2 = 4M.)

:I BPS   50 /  \i LITERAL  \t 50xBPS  ;I
   ( Tricky! This compiles 50xBPS when executed.)

:D serMODE  CREATE ,  EVOKES>  >HILO  ( hi=set, lo=clear)
   SerialMode IO@  SWAP BIC ( clear)  OR  ( set)   SerialMode IO!  ;

"8000 serMODE +Tx    "4000 serMODE +Rx    "093f serMODE 8N1
"0080 serMODE -Tx

( 21-aug-1999. All these comments are wrong except where they aren't. This
  is here for historical interest - to see how my mind works, and doesn't.)

( 17-sep-1998.  Serial port, Queue, and Task interaction.

  Each port has a receive queue and a `transmit ring'.  The receive queue
  is actually a circular buffer, allocated exclusively for the use of that
  port.  Transmission is different.  The `transmit ring' consists of two
  pointers, `sending' and `pending', which are just what they sound like.
  Transmission occurs using -macro service-, since we know beforehand the
  count of bytes.  Transmit buffers are allocated by the -caller- of the
  transmit routine and are treated as read-only.

  Receive is easy.  A character comes in and is placed in the next free spot
  in the queue.  The `write' pointer is incremented and wrapped.  The
  `requested' count is incremented [the consumer decrements when it requests]
  and if it becomes non-negative the task that owns this port is awakened.)

( 07-aug-1999. That's all very well and good, but not how we're going to
  do things. This system is getting too complicated - esp for the tasks
  that it's being asked to perform, so I'm going to simplify things.

  Receive will be substantially as indicated. Queues will have three values
  assciated with them: qRead, qWrite, and qAvailable. qRead and qWrite are
  pointers used by the reader and writer, resp., and qAvailable means
  either characters or space available, depending on whether it's a receive
  or transmit queue. Currently we don't use queues for inter-task
  communication.

  Transmit will also use a queue. This is simple, proven, and works
  well. Tasks will probably wait for space in the queue by polling, rather
  than being woken by interrupt. This is to minimize the switching around
  of `depends-on' pointers and because most tasks will be mostly waiting
  for interrupt-driven input. Any [future] task that needs to be woken by
  space available in a xmit queue can be accomodated.

  For simplicity, queues are 256 bytes long. This way we can index with
  byte registers and forgo any masking. We're also going to go the
  `KEY/EMIT' naming route. `KEY?' tests for characters [in the queue
  associated with a task], and returns the count available. `KEY' returns a
  character - immediately - if there is one, and PAUSEs otherwise. `EMIT?'
  and `EMIT' are analogous.

  For this to work, tasks that talk to serial-port queues need to point to
  a data structure with info about all this. We call this a PORT.

  NOTE: xmit and recv are fairly separate operations. It might be nice to
  split them between two tasks. They would share the base i/o address of
  the port but would never use the same registers - tx irq and rcv irq are
  separate, xmit buffer and rcv buffer are separate. We should also be able
  to associate the IRQ service routine with this half of the port - all
  this stuff should stay together.

  Maybe the defining word should be HALF-DUPLEX. :-)

( Shared resources. The easy way. Maybe someday I'll need this.  ;-)
: GRAB   ( a)  me SWAP !  ;  ( when we know it's free)
: TAKE   ( a)  BEGIN  DUP @  WHILE  PAUSE  REPEAT  GRAB  ;
: RELEASE  ( a)  OFF  ;

00 [if]
( Output >1 byte atomically.)
VARIABLE xmitter
: ATOMIC-EMIT  ( bn .. b0 n)
   xmitter TAKE  ?FOR  EMIT  NEXT  THEN  xmitter RELEASE  ;

: W>  >HILO  2  ATOMIC-EMIT  ;  ( output a 16bit word)
: NOTE-ON  ( note vel)  SWAP  "90  3 ATOMIC-EMIT  ;  ( example)
[then]

( Using non-interrupt-driven xmit. A lot easier. Using the `canonical'
  Forth names for words: `key' for input and `emit' for output.)

00 [if]
( Historical interest:
  Use of NOR is faster, but a little bit tricky. A `1' input forces the
  output to 0; a `0' input inverts that bit. So we're zeroing all but the
  interrupt bit, which we invert the sense of.)

: EMIT  ( b -)  BEGIN  TxIRQ IO@ "ff7f NOR  WHILE  PAUSE  REPEAT
   "47 TxIRQ IO! ( clr irq)  TxData IO!  ;  ( order critical)
[then]

00 [if]
( 19-sep-1998.  Queues have changed lots.  I'll document them when they work.)
( Queues)
:: mantissa  ( n1 - n2)  ( Thanks to Niklaus Wirth)
   begin  dup  1 and 0=  while  u2/  repeat  ;
:: ?power2   ( n - n)  dup mantissa  1 -  abort" : size not a power of 2"  ;


:: QUEUE  ( #bytes -)  CREATE  dup  ?power2
   6 + ( room for +rd, +wr, avail)   RAM ,  ALLOT  1- ( mask) ,  ;

( Too bad we can't make these self-initializing.)
32 QUEUE Qchat

( TODO:  should define consts for the fields.)
CODE QINIT  ( #bytes 'queue -)
   AX AX XOR,  CLI,  AX 2 [t] MOV,  AX 4 [t] MOV,
   ( +rd = +wr = 0)  AX POP, ( #bytes)  AX DEC, ( mask)
   AX 0 [t] MOV,  SS: u ) DI MOV,  ( cur task)
   DI 6 [t] MOV,  ( assoc Q with task)
   -1 # 0 [DI] MOV, ( reset task STATUS)  STI,
   t POP,  NEXT,  C;

( mask +rd +wr task data
   0    2   4   6    8
Every Queue has an associated TASK.  We use that task's
STATUS as a NEGATIVE count of bytes in the Q. )

( Queues)
CODE Q@  ( 'queue - b)  ( fetch BYTE sign-extended)
   2 [t] DI MOV,  8 [BX+DI] AL MOV,  ( get byte)
   DI INC,  0 [t] DI AND,  DI 2 [t] MOV,
   CBW,  AX t XCHG,  NEXT,  C;

CODE Q!  ( b 'queue -)   AX POP,  ( AL=b)
   4 [t] DI MOV,  AL 8 [BX+DI] MOV,  ( put byte)
   DI INC,  0 [t] DI AND,  DI 4 [t] MOV, ( +wr)
   t POP,  NEXT,  C;

( mask +rd +wr task data
   0    2   4   6    8 )


( Serial in interrupt)                           hex
( TODO:  serial and queue stuff needs updating for segment regs)
LABEL serial-in-irq  ( `caller' pushed BX DI)  assemble
   ( call with BX=queue, DI='serialport)   AX PUSH,
   ES: 0 [DI] AL MOV,  ( get ch)  4 [BX] DI MOV, ( +wr)
   AL 8 [BX+DI] MOV,  ( ch into queue)
   DI INC,  0 [BX] DI AND, ( wrap)  DI 4 [BX] MOV,
   6 [BX] DI MOV,  0 [DI] DEC,  ( Up semaphore)
   AX POP,  DI POP,  BX POP,  FINT,  IRET,  C;
                                              decimal
( mask +rd +wr task data
   0    2   4   6    8 )

[then]

( Epilogue)

cr ." Kernel code is "    'CODE .  ." bytes."
cr ." Kernel words is "    HERE .  ." bytes."

\ ]file
