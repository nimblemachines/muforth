| This file is part of muforth: https://muforth.dev/
|
| Copyright 2002-2024 David Frech. (Read the LICENSE for details.)

loading ST-LINK debug (interact)

decimal

( Load the flash programming routines into ram.)
ld target/ARM/stm32/flash-programming.mu4

( Skip the rest of the file if no ST-LINK was found.)
.ifdef stlink

| Connect to device, but don't halt it. This is a verbose connect that says
| what it's doing.

: st.connect
   cr  get-ver .ver
   cr  tell-mode
   dup  0=  if  drop  ." => "  dfu>  tell-mode  then
   dup  1 = if  drop  ." => "  >swd  tell-mode  then
        2 = if  ^  then  ( debug mode)
   error" Couldn't put ST-LINK into debug mode." ;

| DCRSR  Debug Core Register Selector Register
| DCRDR  Debug Core Register Data Register

: core.reg@   DCRSR dap!  DCRDR dap@ ;
: core.reg!   swap DCRDR dap!  [ 1 16 << #] ( write reg) +  DCRSR dap! ;

| Add debug key to command bits and store into DHCSR.
: dhcsr!   ( value)  "a05f_0000 +  DHCSR dap! ;

: core.run    [ C_DEBUGEN C_MASKINTS +          #]  dhcsr! ;
: core.halt   [ C_DEBUGEN C_MASKINTS + C_HALT + #]  dhcsr! ;
: core.step   [ C_DEBUGEN C_MASKINTS + C_STEP + #]  dhcsr! ;

: halted?  ( - f)   DHCSR dap@  S_HALT and ;

| Instead of sitting in an endless loop waiting (and sometimes causing
| ST-LINK to hang and require that the board be power cycled, which is
| annoying), let's test the target's state a finite number of times,
| delaying after each test. We stop either when the target executes
| a breakpoint and halts, or when the retry count reaches a maximum.
|
| We return the retry count with the sp and pc.

: ms   1,000,000 * ( ns)  0 swap  nanosleep ;

| st.status retries 1000 times, pausing 1ms between tries, waiting for the
| target to execute a bkpt instruction and halt.
|
| We pass DP (data stack pointer) in register 13: the MP (machine stack
| pointer).

: st.status  ( - #retries dp)
   0  | #retries
   begin  halted? 0= while  1 ms  1+ dup 1000 = until
   ( timed out)  core.halt ( force halt)  then
   ( success)  13 core.reg@ ;

: st.run  ( pc dp)  13 core.reg!  15 core.reg!  core.run ;

.ifdef no-flash-programming

: st.hello  ( - bogus-chunk-size)
   st.connect  core.halt
   ( We don't have flash routines yet; return bogus chunk size)
   1 Ki ;

( No-op flash routines.)
: st.flash-begin ;
: st.flash-end ;
: st.erase  ( a | sector#)  drop ;
: st.program  ( buf a u)  drop 2drop ;

.else

( Copy the flash programming routines to RAM when we connect.)
: st.hello  ( - chunk-size)
   st.connect  core.halt
   [ h @  ram  @flash-routines image+  swap h ! #]  ( address in ram image)
   @flash-routines #flash-routines st.write  ( copy code to ram)
   #flashbuf ;  ( return size of RAM flash buffer as chunk-size)

( Write unlock keys to FLASH_KEYR.)
: st.flash-begin
   "cdef_89ab  "4567_0123  \m stm32-flash-unlock rx ;

( Re-lock flash controller registers.)
: st.flash-end   \m stm32-flash-lock rx ;

| stm32-erase takes a flash address for uniform page devices, and a sector
| number, for sectored devices. target/ARM/v6-m/flash.mu4 has already
| figured this out for us.

: st.erase  ( a | sector#)  \m stm32-flash-page-erase rx ;

( Copy buf contents to ram buffer, then write to flash from there.)
: st.program  ( buf a u)
   push ( u)
   | Copy chunk to target ram, aligning length of copied data by 8 for
   | STM32C parts (which programs the flash in 8 byte chunks).
   swap @flashbuf r@  ( a buf flashbuf u)  8 aligned-by  st.write
   | Program chunk into flash.
   @flashbuf swap pop  ( flashbuf a u)  \m stm32-flash-program rx ;

.then  ( def no-flash-programming)

( The interface for the interact code. Implemented by all debug transports.)
: jtag
   chat-via  st.hello  st.status  st.run  st.read  st.write
   st.flash-begin  st.flash-end  st.erase  st.program ;

.then  ( def stlink)
