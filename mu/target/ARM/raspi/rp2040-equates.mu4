( Automagically generated. DO NOT EDIT!
|
| Generated by https://github.com/nimblemachines/kinetis-chip-equates
| from CMSIS-SVD source file https://raw.githubusercontent.com/raspberrypi/pico-sdk/master/src/rp2040/hardware_regs/RP2040.svd)

loading RP2040 equates

sealed .equates.    ( chip equates and other constants for target)

( First, a few defining words, which we'll use to load the "equates".)
: equ     ( offset)  current preserve  .equates. definitions  constant ;
: vector  ( offset)  equ ;
: |  \ -- ;  ( | ignores the bit-fields that follow each register name)
: aka   .equates. chain' execute ;  ( for making synonyms)

hex

( Vectors)
0040 vector TIMER_IRQ_0      | IRQ  0
0044 vector TIMER_IRQ_1      | IRQ  1
0048 vector TIMER_IRQ_2      | IRQ  2
004c vector TIMER_IRQ_3      | IRQ  3
0050 vector PWM_IRQ_WRAP     | IRQ  4
0054 vector USBCTRL_IRQ      | IRQ  5
0058 vector XIP_IRQ          | IRQ  6
005c vector PIO0_IRQ_0       | IRQ  7
0060 vector PIO0_IRQ_1       | IRQ  8
0064 vector PIO1_IRQ_0       | IRQ  9
0068 vector PIO1_IRQ_1       | IRQ 10
006c vector DMA_IRQ_0        | IRQ 11
0070 vector DMA_IRQ_1        | IRQ 12
0074 vector IO_IRQ_BANK0     | IRQ 13
0078 vector IO_IRQ_QSPI      | IRQ 14
007c vector SIO_IRQ_PROC0    | IRQ 15
0080 vector SIO_IRQ_PROC1    | IRQ 16
0084 vector CLOCKS_IRQ       | IRQ 17
0088 vector SPI0_IRQ         | IRQ 18
008c vector SPI1_IRQ         | IRQ 19
0090 vector UART0_IRQ        | IRQ 20
0094 vector UART1_IRQ        | IRQ 21
0098 vector ADC_IRQ_FIFO     | IRQ 22
009c vector I2C0_IRQ         | IRQ 23
00a0 vector I2C1_IRQ         | IRQ 24
00a4 vector RTC_IRQ          | IRQ 25
00a8 vector LAST_irq         | IRQ 26: dummy LAST vector to mark end of vector table

( Register addresses)

( XIP_CTRL)
1400_0000 equ XIP_CTRL_CTRL          | Cache control
1400_0004 equ XIP_CTRL_FLUSH         | Cache Flush control
1400_0008 equ XIP_CTRL_STAT          | Cache Status
1400_000c equ XIP_CTRL_CTR_HIT       | Cache Hit counter
1400_0010 equ XIP_CTRL_CTR_ACC       | Cache Access counter
1400_0014 equ XIP_CTRL_STREAM_ADDR   | FIFO stream address
1400_0018 equ XIP_CTRL_STREAM_CTR    | FIFO stream control
1400_001c equ XIP_CTRL_STREAM_FIFO   | FIFO stream data

( SSI)
1800_0000 equ SSI_CTRLR0           | Control register 0
1800_0004 equ SSI_CTRLR1           | Master Control register 1
1800_0008 equ SSI_SSIENR           | SSI Enable
1800_000c equ SSI_MWCR             | Microwire Control
1800_0010 equ SSI_SER              | Slave enable
1800_0014 equ SSI_BAUDR            | Baud rate
1800_0018 equ SSI_TXFTLR           | TX FIFO threshold level
1800_001c equ SSI_RXFTLR           | RX FIFO threshold level
1800_0020 equ SSI_TXFLR            | TX FIFO level
1800_0024 equ SSI_RXFLR            | RX FIFO level
1800_0028 equ SSI_SR               | Status register
1800_002c equ SSI_IMR              | Interrupt mask
1800_0030 equ SSI_ISR              | Interrupt status
1800_0034 equ SSI_RISR             | Raw interrupt status
1800_0038 equ SSI_TXOICR           | TX FIFO overflow interrupt clear
1800_003c equ SSI_RXOICR           | RX FIFO overflow interrupt clear
1800_0040 equ SSI_RXUICR           | RX FIFO underflow interrupt clear
1800_0044 equ SSI_MSTICR           | Multi-master interrupt clear
1800_0048 equ SSI_ICR              | Interrupt clear
1800_004c equ SSI_DMACR            | DMA control
1800_0050 equ SSI_DMATDLR          | DMA TX data level
1800_0054 equ SSI_DMARDLR          | DMA RX data level
1800_0058 equ SSI_IDR              | Identification register
1800_005c equ SSI_SSI_VERSION_ID   | Version ID
1800_0060 equ SSI_DR0              | Data Register 0 (of 36)
1800_00f0 equ SSI_RX_SAMPLE_DLY    | RX sample delay
1800_00f4 equ SSI_SPI_CTRLR0       | SPI control
1800_00f8 equ SSI_TXD_DRIVE_EDGE   | TX drive edge

( SYSINFO)
4000_0000 equ SYSINFO_CHIP_ID         | JEDEC JEP-106 compliant chip identifier.
4000_0004 equ SYSINFO_PLATFORM        | Platform register. Allows software to know what environment it is running in.
4000_0010 equ SYSINFO_GITREF_RP2040   | Git hash of the chip source. Used to identify chip version.

( SYSCFG)
4000_4000 equ SYSCFG_PROC0_NMI_MASK           | Processor core 0 NMI source mask
4000_4004 equ SYSCFG_PROC1_NMI_MASK           | Processor core 1 NMI source mask
4000_4008 equ SYSCFG_PROC_CONFIG              | Configuration for processors
4000_400c equ SYSCFG_PROC_IN_SYNC_BYPASS      | For each bit, if 1, bypass the input synchronizer between that GPIO and the GPIO input register in the SIO. The input synchronizers should generally be unbypassed, to avoid injecting metastabilities into processors. If you&#39;re feeling brave, you can bypass to save two cycles of input latency. This register applies to GPIO 0...29.
4000_4010 equ SYSCFG_PROC_IN_SYNC_BYPASS_HI   | For each bit, if 1, bypass the input synchronizer between that GPIO and the GPIO input register in the SIO. The input synchronizers should generally be unbypassed, to avoid injecting metastabilities into processors. If you&#39;re feeling brave, you can bypass to save two cycles of input latency. This register applies to GPIO 30...35 (the QSPI IOs).
4000_4014 equ SYSCFG_DBGFORCE                 | Directly control the SWD debug port of either processor
4000_4018 equ SYSCFG_MEMPOWERDOWN             | Control power downs to memories. Set high to power down memories. Use with extreme caution

( CLOCKS)
4000_8000 equ CLOCKS_CLK_GPOUT0_CTRL        | Clock control, can be changed on-the-fly (except for auxsrc)
4000_8004 equ CLOCKS_CLK_GPOUT0_DIV         | Clock divisor, can be changed on-the-fly
4000_8008 equ CLOCKS_CLK_GPOUT0_SELECTED    | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_800c equ CLOCKS_CLK_GPOUT1_CTRL        | Clock control, can be changed on-the-fly (except for auxsrc)
4000_8010 equ CLOCKS_CLK_GPOUT1_DIV         | Clock divisor, can be changed on-the-fly
4000_8014 equ CLOCKS_CLK_GPOUT1_SELECTED    | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_8018 equ CLOCKS_CLK_GPOUT2_CTRL        | Clock control, can be changed on-the-fly (except for auxsrc)
4000_801c equ CLOCKS_CLK_GPOUT2_DIV         | Clock divisor, can be changed on-the-fly
4000_8020 equ CLOCKS_CLK_GPOUT2_SELECTED    | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_8024 equ CLOCKS_CLK_GPOUT3_CTRL        | Clock control, can be changed on-the-fly (except for auxsrc)
4000_8028 equ CLOCKS_CLK_GPOUT3_DIV         | Clock divisor, can be changed on-the-fly
4000_802c equ CLOCKS_CLK_GPOUT3_SELECTED    | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_8030 equ CLOCKS_CLK_REF_CTRL           | Clock control, can be changed on-the-fly (except for auxsrc)
4000_8034 equ CLOCKS_CLK_REF_DIV            | Clock divisor, can be changed on-the-fly
4000_8038 equ CLOCKS_CLK_REF_SELECTED       | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_803c equ CLOCKS_CLK_SYS_CTRL           | Clock control, can be changed on-the-fly (except for auxsrc)
4000_8040 equ CLOCKS_CLK_SYS_DIV            | Clock divisor, can be changed on-the-fly
4000_8044 equ CLOCKS_CLK_SYS_SELECTED       | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_8048 equ CLOCKS_CLK_PERI_CTRL          | Clock control, can be changed on-the-fly (except for auxsrc)
4000_804c equ CLOCKS_CLK_PERI_DIV           | Clock divisor, can be changed on-the-fly
4000_8050 equ CLOCKS_CLK_PERI_SELECTED      | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_8054 equ CLOCKS_CLK_USB_CTRL           | Clock control, can be changed on-the-fly (except for auxsrc)
4000_8058 equ CLOCKS_CLK_USB_DIV            | Clock divisor, can be changed on-the-fly
4000_805c equ CLOCKS_CLK_USB_SELECTED       | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_8060 equ CLOCKS_CLK_ADC_CTRL           | Clock control, can be changed on-the-fly (except for auxsrc)
4000_8064 equ CLOCKS_CLK_ADC_DIV            | Clock divisor, can be changed on-the-fly
4000_8068 equ CLOCKS_CLK_ADC_SELECTED       | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_806c equ CLOCKS_CLK_RTC_CTRL           | Clock control, can be changed on-the-fly (except for auxsrc)
4000_8070 equ CLOCKS_CLK_RTC_DIV            | Clock divisor, can be changed on-the-fly
4000_8074 equ CLOCKS_CLK_RTC_SELECTED       | Indicates which SRC is currently selected by the glitchless mux (one-hot).
4000_8078 equ CLOCKS_CLK_SYS_RESUS_CTRL
4000_807c equ CLOCKS_CLK_SYS_RESUS_STATUS
4000_8080 equ CLOCKS_FC0_REF_KHZ            | Reference clock frequency in kHz
4000_8084 equ CLOCKS_FC0_MIN_KHZ            | Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
4000_8088 equ CLOCKS_FC0_MAX_KHZ            | Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
4000_808c equ CLOCKS_FC0_DELAY              | Delays the start of frequency counting to allow the mux to settle Delay is measured in multiples of the reference clock period
4000_8090 equ CLOCKS_FC0_INTERVAL           | The test interval is 0.98us * 2**interval, but let&#39;s call it 1us * 2**interval The default gives a test interval of 250us
4000_8094 equ CLOCKS_FC0_SRC                | Clock sent to frequency counter, set to 0 when not required Writing to this register initiates the frequency count
4000_8098 equ CLOCKS_FC0_STATUS             | Frequency counter status
4000_809c equ CLOCKS_FC0_RESULT             | Result of frequency measurement, only valid when status_done=1
4000_80a0 equ CLOCKS_WAKE_EN0               | enable clock in wake mode
4000_80a4 equ CLOCKS_WAKE_EN1               | enable clock in wake mode
4000_80a8 equ CLOCKS_SLEEP_EN0              | enable clock in sleep mode
4000_80ac equ CLOCKS_SLEEP_EN1              | enable clock in sleep mode
4000_80b0 equ CLOCKS_ENABLED0               | indicates the state of the clock enable
4000_80b4 equ CLOCKS_ENABLED1               | indicates the state of the clock enable
4000_80b8 equ CLOCKS_INTR                   | Raw Interrupts
4000_80bc equ CLOCKS_INTE                   | Interrupt Enable
4000_80c0 equ CLOCKS_INTF                   | Interrupt Force
4000_80c4 equ CLOCKS_INTS                   | Interrupt status after masking and forcing

( RESETS)
4000_c000 equ RESETS_RESET        | Reset control. If a bit is set it means the peripheral is in reset. 0 means the peripheral&#39;s reset is deasserted.
4000_c004 equ RESETS_WDSEL        | Watchdog select. If a bit is set then the watchdog will reset this peripheral when the watchdog fires.
4000_c008 equ RESETS_RESET_DONE   | Reset done. If a bit is set then a reset done signal has been returned by the peripheral. This indicates that the peripheral&#39;s registers are ready to be accessed.

( PSM)
4001_0000 equ PSM_FRCE_ON    | Force block out of reset (i.e. power it on)
4001_0004 equ PSM_FRCE_OFF   | Force into reset (i.e. power it off)
4001_0008 equ PSM_WDSEL      | Set to 1 if this peripheral should be reset when the watchdog fires.
4001_000c equ PSM_DONE       | Indicates the peripheral&#39;s registers are ready to access.

( IO_BANK0)
4001_4000 equ IO_BANK0_GPIO0_STATUS         | GPIO status
4001_4004 equ IO_BANK0_GPIO0_CTRL           | GPIO control including function select and overrides.
4001_4008 equ IO_BANK0_GPIO1_STATUS         | GPIO status
4001_400c equ IO_BANK0_GPIO1_CTRL           | GPIO control including function select and overrides.
4001_4010 equ IO_BANK0_GPIO2_STATUS         | GPIO status
4001_4014 equ IO_BANK0_GPIO2_CTRL           | GPIO control including function select and overrides.
4001_4018 equ IO_BANK0_GPIO3_STATUS         | GPIO status
4001_401c equ IO_BANK0_GPIO3_CTRL           | GPIO control including function select and overrides.
4001_4020 equ IO_BANK0_GPIO4_STATUS         | GPIO status
4001_4024 equ IO_BANK0_GPIO4_CTRL           | GPIO control including function select and overrides.
4001_4028 equ IO_BANK0_GPIO5_STATUS         | GPIO status
4001_402c equ IO_BANK0_GPIO5_CTRL           | GPIO control including function select and overrides.
4001_4030 equ IO_BANK0_GPIO6_STATUS         | GPIO status
4001_4034 equ IO_BANK0_GPIO6_CTRL           | GPIO control including function select and overrides.
4001_4038 equ IO_BANK0_GPIO7_STATUS         | GPIO status
4001_403c equ IO_BANK0_GPIO7_CTRL           | GPIO control including function select and overrides.
4001_4040 equ IO_BANK0_GPIO8_STATUS         | GPIO status
4001_4044 equ IO_BANK0_GPIO8_CTRL           | GPIO control including function select and overrides.
4001_4048 equ IO_BANK0_GPIO9_STATUS         | GPIO status
4001_404c equ IO_BANK0_GPIO9_CTRL           | GPIO control including function select and overrides.
4001_4050 equ IO_BANK0_GPIO10_STATUS        | GPIO status
4001_4054 equ IO_BANK0_GPIO10_CTRL          | GPIO control including function select and overrides.
4001_4058 equ IO_BANK0_GPIO11_STATUS        | GPIO status
4001_405c equ IO_BANK0_GPIO11_CTRL          | GPIO control including function select and overrides.
4001_4060 equ IO_BANK0_GPIO12_STATUS        | GPIO status
4001_4064 equ IO_BANK0_GPIO12_CTRL          | GPIO control including function select and overrides.
4001_4068 equ IO_BANK0_GPIO13_STATUS        | GPIO status
4001_406c equ IO_BANK0_GPIO13_CTRL          | GPIO control including function select and overrides.
4001_4070 equ IO_BANK0_GPIO14_STATUS        | GPIO status
4001_4074 equ IO_BANK0_GPIO14_CTRL          | GPIO control including function select and overrides.
4001_4078 equ IO_BANK0_GPIO15_STATUS        | GPIO status
4001_407c equ IO_BANK0_GPIO15_CTRL          | GPIO control including function select and overrides.
4001_4080 equ IO_BANK0_GPIO16_STATUS        | GPIO status
4001_4084 equ IO_BANK0_GPIO16_CTRL          | GPIO control including function select and overrides.
4001_4088 equ IO_BANK0_GPIO17_STATUS        | GPIO status
4001_408c equ IO_BANK0_GPIO17_CTRL          | GPIO control including function select and overrides.
4001_4090 equ IO_BANK0_GPIO18_STATUS        | GPIO status
4001_4094 equ IO_BANK0_GPIO18_CTRL          | GPIO control including function select and overrides.
4001_4098 equ IO_BANK0_GPIO19_STATUS        | GPIO status
4001_409c equ IO_BANK0_GPIO19_CTRL          | GPIO control including function select and overrides.
4001_40a0 equ IO_BANK0_GPIO20_STATUS        | GPIO status
4001_40a4 equ IO_BANK0_GPIO20_CTRL          | GPIO control including function select and overrides.
4001_40a8 equ IO_BANK0_GPIO21_STATUS        | GPIO status
4001_40ac equ IO_BANK0_GPIO21_CTRL          | GPIO control including function select and overrides.
4001_40b0 equ IO_BANK0_GPIO22_STATUS        | GPIO status
4001_40b4 equ IO_BANK0_GPIO22_CTRL          | GPIO control including function select and overrides.
4001_40b8 equ IO_BANK0_GPIO23_STATUS        | GPIO status
4001_40bc equ IO_BANK0_GPIO23_CTRL          | GPIO control including function select and overrides.
4001_40c0 equ IO_BANK0_GPIO24_STATUS        | GPIO status
4001_40c4 equ IO_BANK0_GPIO24_CTRL          | GPIO control including function select and overrides.
4001_40c8 equ IO_BANK0_GPIO25_STATUS        | GPIO status
4001_40cc equ IO_BANK0_GPIO25_CTRL          | GPIO control including function select and overrides.
4001_40d0 equ IO_BANK0_GPIO26_STATUS        | GPIO status
4001_40d4 equ IO_BANK0_GPIO26_CTRL          | GPIO control including function select and overrides.
4001_40d8 equ IO_BANK0_GPIO27_STATUS        | GPIO status
4001_40dc equ IO_BANK0_GPIO27_CTRL          | GPIO control including function select and overrides.
4001_40e0 equ IO_BANK0_GPIO28_STATUS        | GPIO status
4001_40e4 equ IO_BANK0_GPIO28_CTRL          | GPIO control including function select and overrides.
4001_40e8 equ IO_BANK0_GPIO29_STATUS        | GPIO status
4001_40ec equ IO_BANK0_GPIO29_CTRL          | GPIO control including function select and overrides.
4001_40f0 equ IO_BANK0_INTR0                | Raw Interrupts
4001_40f4 equ IO_BANK0_INTR1                | Raw Interrupts
4001_40f8 equ IO_BANK0_INTR2                | Raw Interrupts
4001_40fc equ IO_BANK0_INTR3                | Raw Interrupts
4001_4100 equ IO_BANK0_PROC0_INTE0          | Interrupt Enable for proc0
4001_4104 equ IO_BANK0_PROC0_INTE1          | Interrupt Enable for proc0
4001_4108 equ IO_BANK0_PROC0_INTE2          | Interrupt Enable for proc0
4001_410c equ IO_BANK0_PROC0_INTE3          | Interrupt Enable for proc0
4001_4110 equ IO_BANK0_PROC0_INTF0          | Interrupt Force for proc0
4001_4114 equ IO_BANK0_PROC0_INTF1          | Interrupt Force for proc0
4001_4118 equ IO_BANK0_PROC0_INTF2          | Interrupt Force for proc0
4001_411c equ IO_BANK0_PROC0_INTF3          | Interrupt Force for proc0
4001_4120 equ IO_BANK0_PROC0_INTS0          | Interrupt status after masking and forcing for proc0
4001_4124 equ IO_BANK0_PROC0_INTS1          | Interrupt status after masking and forcing for proc0
4001_4128 equ IO_BANK0_PROC0_INTS2          | Interrupt status after masking and forcing for proc0
4001_412c equ IO_BANK0_PROC0_INTS3          | Interrupt status after masking and forcing for proc0
4001_4130 equ IO_BANK0_PROC1_INTE0          | Interrupt Enable for proc1
4001_4134 equ IO_BANK0_PROC1_INTE1          | Interrupt Enable for proc1
4001_4138 equ IO_BANK0_PROC1_INTE2          | Interrupt Enable for proc1
4001_413c equ IO_BANK0_PROC1_INTE3          | Interrupt Enable for proc1
4001_4140 equ IO_BANK0_PROC1_INTF0          | Interrupt Force for proc1
4001_4144 equ IO_BANK0_PROC1_INTF1          | Interrupt Force for proc1
4001_4148 equ IO_BANK0_PROC1_INTF2          | Interrupt Force for proc1
4001_414c equ IO_BANK0_PROC1_INTF3          | Interrupt Force for proc1
4001_4150 equ IO_BANK0_PROC1_INTS0          | Interrupt status after masking and forcing for proc1
4001_4154 equ IO_BANK0_PROC1_INTS1          | Interrupt status after masking and forcing for proc1
4001_4158 equ IO_BANK0_PROC1_INTS2          | Interrupt status after masking and forcing for proc1
4001_415c equ IO_BANK0_PROC1_INTS3          | Interrupt status after masking and forcing for proc1
4001_4160 equ IO_BANK0_DORMANT_WAKE_INTE0   | Interrupt Enable for dormant_wake
4001_4164 equ IO_BANK0_DORMANT_WAKE_INTE1   | Interrupt Enable for dormant_wake
4001_4168 equ IO_BANK0_DORMANT_WAKE_INTE2   | Interrupt Enable for dormant_wake
4001_416c equ IO_BANK0_DORMANT_WAKE_INTE3   | Interrupt Enable for dormant_wake
4001_4170 equ IO_BANK0_DORMANT_WAKE_INTF0   | Interrupt Force for dormant_wake
4001_4174 equ IO_BANK0_DORMANT_WAKE_INTF1   | Interrupt Force for dormant_wake
4001_4178 equ IO_BANK0_DORMANT_WAKE_INTF2   | Interrupt Force for dormant_wake
4001_417c equ IO_BANK0_DORMANT_WAKE_INTF3   | Interrupt Force for dormant_wake
4001_4180 equ IO_BANK0_DORMANT_WAKE_INTS0   | Interrupt status after masking and forcing for dormant_wake
4001_4184 equ IO_BANK0_DORMANT_WAKE_INTS1   | Interrupt status after masking and forcing for dormant_wake
4001_4188 equ IO_BANK0_DORMANT_WAKE_INTS2   | Interrupt status after masking and forcing for dormant_wake
4001_418c equ IO_BANK0_DORMANT_WAKE_INTS3   | Interrupt status after masking and forcing for dormant_wake

( IO_QSPI)
4001_8000 equ IO_QSPI_GPIO_QSPI_SCLK_STATUS   | GPIO status
4001_8004 equ IO_QSPI_GPIO_QSPI_SCLK_CTRL     | GPIO control including function select and overrides.
4001_8008 equ IO_QSPI_GPIO_QSPI_SS_STATUS     | GPIO status
4001_800c equ IO_QSPI_GPIO_QSPI_SS_CTRL       | GPIO control including function select and overrides.
4001_8010 equ IO_QSPI_GPIO_QSPI_SD0_STATUS    | GPIO status
4001_8014 equ IO_QSPI_GPIO_QSPI_SD0_CTRL      | GPIO control including function select and overrides.
4001_8018 equ IO_QSPI_GPIO_QSPI_SD1_STATUS    | GPIO status
4001_801c equ IO_QSPI_GPIO_QSPI_SD1_CTRL      | GPIO control including function select and overrides.
4001_8020 equ IO_QSPI_GPIO_QSPI_SD2_STATUS    | GPIO status
4001_8024 equ IO_QSPI_GPIO_QSPI_SD2_CTRL      | GPIO control including function select and overrides.
4001_8028 equ IO_QSPI_GPIO_QSPI_SD3_STATUS    | GPIO status
4001_802c equ IO_QSPI_GPIO_QSPI_SD3_CTRL      | GPIO control including function select and overrides.
4001_8030 equ IO_QSPI_INTR                    | Raw Interrupts
4001_8034 equ IO_QSPI_PROC0_INTE              | Interrupt Enable for proc0
4001_8038 equ IO_QSPI_PROC0_INTF              | Interrupt Force for proc0
4001_803c equ IO_QSPI_PROC0_INTS              | Interrupt status after masking and forcing for proc0
4001_8040 equ IO_QSPI_PROC1_INTE              | Interrupt Enable for proc1
4001_8044 equ IO_QSPI_PROC1_INTF              | Interrupt Force for proc1
4001_8048 equ IO_QSPI_PROC1_INTS              | Interrupt status after masking and forcing for proc1
4001_804c equ IO_QSPI_DORMANT_WAKE_INTE       | Interrupt Enable for dormant_wake
4001_8050 equ IO_QSPI_DORMANT_WAKE_INTF       | Interrupt Force for dormant_wake
4001_8054 equ IO_QSPI_DORMANT_WAKE_INTS       | Interrupt status after masking and forcing for dormant_wake

( PADS_BANK0)
4001_c000 equ PADS_BANK0_VOLTAGE_SELECT   | Voltage select. Per bank control
4001_c004 equ PADS_BANK0_GPIO0            | Pad control register
4001_c008 equ PADS_BANK0_GPIO1            | Pad control register
4001_c00c equ PADS_BANK0_GPIO2            | Pad control register
4001_c010 equ PADS_BANK0_GPIO3            | Pad control register
4001_c014 equ PADS_BANK0_GPIO4            | Pad control register
4001_c018 equ PADS_BANK0_GPIO5            | Pad control register
4001_c01c equ PADS_BANK0_GPIO6            | Pad control register
4001_c020 equ PADS_BANK0_GPIO7            | Pad control register
4001_c024 equ PADS_BANK0_GPIO8            | Pad control register
4001_c028 equ PADS_BANK0_GPIO9            | Pad control register
4001_c02c equ PADS_BANK0_GPIO10           | Pad control register
4001_c030 equ PADS_BANK0_GPIO11           | Pad control register
4001_c034 equ PADS_BANK0_GPIO12           | Pad control register
4001_c038 equ PADS_BANK0_GPIO13           | Pad control register
4001_c03c equ PADS_BANK0_GPIO14           | Pad control register
4001_c040 equ PADS_BANK0_GPIO15           | Pad control register
4001_c044 equ PADS_BANK0_GPIO16           | Pad control register
4001_c048 equ PADS_BANK0_GPIO17           | Pad control register
4001_c04c equ PADS_BANK0_GPIO18           | Pad control register
4001_c050 equ PADS_BANK0_GPIO19           | Pad control register
4001_c054 equ PADS_BANK0_GPIO20           | Pad control register
4001_c058 equ PADS_BANK0_GPIO21           | Pad control register
4001_c05c equ PADS_BANK0_GPIO22           | Pad control register
4001_c060 equ PADS_BANK0_GPIO23           | Pad control register
4001_c064 equ PADS_BANK0_GPIO24           | Pad control register
4001_c068 equ PADS_BANK0_GPIO25           | Pad control register
4001_c06c equ PADS_BANK0_GPIO26           | Pad control register
4001_c070 equ PADS_BANK0_GPIO27           | Pad control register
4001_c074 equ PADS_BANK0_GPIO28           | Pad control register
4001_c078 equ PADS_BANK0_GPIO29           | Pad control register
4001_c07c equ PADS_BANK0_SWCLK            | Pad control register
4001_c080 equ PADS_BANK0_SWD              | Pad control register

( PADS_QSPI)
4002_0000 equ PADS_QSPI_VOLTAGE_SELECT   | Voltage select. Per bank control
4002_0004 equ PADS_QSPI_GPIO_QSPI_SCLK   | Pad control register
4002_0008 equ PADS_QSPI_GPIO_QSPI_SD0    | Pad control register
4002_000c equ PADS_QSPI_GPIO_QSPI_SD1    | Pad control register
4002_0010 equ PADS_QSPI_GPIO_QSPI_SD2    | Pad control register
4002_0014 equ PADS_QSPI_GPIO_QSPI_SD3    | Pad control register
4002_0018 equ PADS_QSPI_GPIO_QSPI_SS     | Pad control register

( XOSC)
4002_4000 equ XOSC_CTRL      | Crystal Oscillator Control
4002_4004 equ XOSC_STATUS    | Crystal Oscillator Status
4002_4008 equ XOSC_DORMANT   | Crystal Oscillator pause control
4002_400c equ XOSC_STARTUP   | Controls the startup delay
4002_401c equ XOSC_COUNT     | A down counter running at the xosc frequency which counts to zero and stops. To start the counter write a non-zero value. Can be used for short software pauses when setting up time sensitive hardware.

( PLL_SYS)
4002_8000 equ PLL_SYS_CS          | Control and Status GENERAL CONSTRAINTS: Reference clock frequency min=5MHz, max=800MHz Feedback divider min=16, max=320 VCO frequency min=750MHz, max=1600MHz
4002_8004 equ PLL_SYS_PWR         | Controls the PLL power modes.
4002_8008 equ PLL_SYS_FBDIV_INT   | Feedback divisor (note: this PLL does not support fractional division)
4002_800c equ PLL_SYS_PRIM        | Controls the PLL post dividers for the primary output (note: this PLL does not have a secondary output) the primary output is driven from VCO divided by postdiv1*postdiv2

( PLL_USB)
4002_c000 equ PLL_USB_CS          | Control and Status GENERAL CONSTRAINTS: Reference clock frequency min=5MHz, max=800MHz Feedback divider min=16, max=320 VCO frequency min=750MHz, max=1600MHz
4002_c004 equ PLL_USB_PWR         | Controls the PLL power modes.
4002_c008 equ PLL_USB_FBDIV_INT   | Feedback divisor (note: this PLL does not support fractional division)
4002_c00c equ PLL_USB_PRIM        | Controls the PLL post dividers for the primary output (note: this PLL does not have a secondary output) the primary output is driven from VCO divided by postdiv1*postdiv2

( BUSCTRL)
4003_0000 equ BUSCTRL_BUS_PRIORITY       | Set the priority of each master for bus arbitration.
4003_0004 equ BUSCTRL_BUS_PRIORITY_ACK   | Bus priority acknowledge
4003_0008 equ BUSCTRL_PERFCTR0           | Bus fabric performance counter 0
4003_000c equ BUSCTRL_PERFSEL0           | Bus fabric performance event select for PERFCTR0
4003_0010 equ BUSCTRL_PERFCTR1           | Bus fabric performance counter 1
4003_0014 equ BUSCTRL_PERFSEL1           | Bus fabric performance event select for PERFCTR1
4003_0018 equ BUSCTRL_PERFCTR2           | Bus fabric performance counter 2
4003_001c equ BUSCTRL_PERFSEL2           | Bus fabric performance event select for PERFCTR2
4003_0020 equ BUSCTRL_PERFCTR3           | Bus fabric performance counter 3
4003_0024 equ BUSCTRL_PERFSEL3           | Bus fabric performance event select for PERFCTR3

( UART0)
4003_4000 equ UART0_UARTDR          | Data Register, UARTDR
4003_4004 equ UART0_UARTRSR         | Receive Status Register/Error Clear Register, UARTRSR/UARTECR
4003_4018 equ UART0_UARTFR          | Flag Register, UARTFR
4003_4020 equ UART0_UARTILPR        | IrDA Low-Power Counter Register, UARTILPR
4003_4024 equ UART0_UARTIBRD        | Integer Baud Rate Register, UARTIBRD
4003_4028 equ UART0_UARTFBRD        | Fractional Baud Rate Register, UARTFBRD
4003_402c equ UART0_UARTLCR_H       | Line Control Register, UARTLCR_H
4003_4030 equ UART0_UARTCR          | Control Register, UARTCR
4003_4034 equ UART0_UARTIFLS        | Interrupt FIFO Level Select Register, UARTIFLS
4003_4038 equ UART0_UARTIMSC        | Interrupt Mask Set/Clear Register, UARTIMSC
4003_403c equ UART0_UARTRIS         | Raw Interrupt Status Register, UARTRIS
4003_4040 equ UART0_UARTMIS         | Masked Interrupt Status Register, UARTMIS
4003_4044 equ UART0_UARTICR         | Interrupt Clear Register, UARTICR
4003_4048 equ UART0_UARTDMACR       | DMA Control Register, UARTDMACR
4003_4fe0 equ UART0_UARTPERIPHID0   | UARTPeriphID0 Register
4003_4fe4 equ UART0_UARTPERIPHID1   | UARTPeriphID1 Register
4003_4fe8 equ UART0_UARTPERIPHID2   | UARTPeriphID2 Register
4003_4fec equ UART0_UARTPERIPHID3   | UARTPeriphID3 Register
4003_4ff0 equ UART0_UARTPCELLID0    | UARTPCellID0 Register
4003_4ff4 equ UART0_UARTPCELLID1    | UARTPCellID1 Register
4003_4ff8 equ UART0_UARTPCELLID2    | UARTPCellID2 Register
4003_4ffc equ UART0_UARTPCELLID3    | UARTPCellID3 Register

( UART1)
4003_8000 equ UART1_UARTDR          | Data Register, UARTDR
4003_8004 equ UART1_UARTRSR         | Receive Status Register/Error Clear Register, UARTRSR/UARTECR
4003_8018 equ UART1_UARTFR          | Flag Register, UARTFR
4003_8020 equ UART1_UARTILPR        | IrDA Low-Power Counter Register, UARTILPR
4003_8024 equ UART1_UARTIBRD        | Integer Baud Rate Register, UARTIBRD
4003_8028 equ UART1_UARTFBRD        | Fractional Baud Rate Register, UARTFBRD
4003_802c equ UART1_UARTLCR_H       | Line Control Register, UARTLCR_H
4003_8030 equ UART1_UARTCR          | Control Register, UARTCR
4003_8034 equ UART1_UARTIFLS        | Interrupt FIFO Level Select Register, UARTIFLS
4003_8038 equ UART1_UARTIMSC        | Interrupt Mask Set/Clear Register, UARTIMSC
4003_803c equ UART1_UARTRIS         | Raw Interrupt Status Register, UARTRIS
4003_8040 equ UART1_UARTMIS         | Masked Interrupt Status Register, UARTMIS
4003_8044 equ UART1_UARTICR         | Interrupt Clear Register, UARTICR
4003_8048 equ UART1_UARTDMACR       | DMA Control Register, UARTDMACR
4003_8fe0 equ UART1_UARTPERIPHID0   | UARTPeriphID0 Register
4003_8fe4 equ UART1_UARTPERIPHID1   | UARTPeriphID1 Register
4003_8fe8 equ UART1_UARTPERIPHID2   | UARTPeriphID2 Register
4003_8fec equ UART1_UARTPERIPHID3   | UARTPeriphID3 Register
4003_8ff0 equ UART1_UARTPCELLID0    | UARTPCellID0 Register
4003_8ff4 equ UART1_UARTPCELLID1    | UARTPCellID1 Register
4003_8ff8 equ UART1_UARTPCELLID2    | UARTPCellID2 Register
4003_8ffc equ UART1_UARTPCELLID3    | UARTPCellID3 Register

( SPI0)
4003_c000 equ SPI0_SSPCR0         | Control register 0, SSPCR0 on page 3-4
4003_c004 equ SPI0_SSPCR1         | Control register 1, SSPCR1 on page 3-5
4003_c008 equ SPI0_SSPDR          | Data register, SSPDR on page 3-6
4003_c00c equ SPI0_SSPSR          | Status register, SSPSR on page 3-7
4003_c010 equ SPI0_SSPCPSR        | Clock prescale register, SSPCPSR on page 3-8
4003_c014 equ SPI0_SSPIMSC        | Interrupt mask set or clear register, SSPIMSC on page 3-9
4003_c018 equ SPI0_SSPRIS         | Raw interrupt status register, SSPRIS on page 3-10
4003_c01c equ SPI0_SSPMIS         | Masked interrupt status register, SSPMIS on page 3-11
4003_c020 equ SPI0_SSPICR         | Interrupt clear register, SSPICR on page 3-11
4003_c024 equ SPI0_SSPDMACR       | DMA control register, SSPDMACR on page 3-12
4003_cfe0 equ SPI0_SSPPERIPHID0   | Peripheral identification registers, SSPPeriphID0-3 on page 3-13
4003_cfe4 equ SPI0_SSPPERIPHID1   | Peripheral identification registers, SSPPeriphID0-3 on page 3-13
4003_cfe8 equ SPI0_SSPPERIPHID2   | Peripheral identification registers, SSPPeriphID0-3 on page 3-13
4003_cfec equ SPI0_SSPPERIPHID3   | Peripheral identification registers, SSPPeriphID0-3 on page 3-13
4003_cff0 equ SPI0_SSPPCELLID0    | PrimeCell identification registers, SSPPCellID0-3 on page 3-16
4003_cff4 equ SPI0_SSPPCELLID1    | PrimeCell identification registers, SSPPCellID0-3 on page 3-16
4003_cff8 equ SPI0_SSPPCELLID2    | PrimeCell identification registers, SSPPCellID0-3 on page 3-16
4003_cffc equ SPI0_SSPPCELLID3    | PrimeCell identification registers, SSPPCellID0-3 on page 3-16

( SPI1)
4004_0000 equ SPI1_SSPCR0         | Control register 0, SSPCR0 on page 3-4
4004_0004 equ SPI1_SSPCR1         | Control register 1, SSPCR1 on page 3-5
4004_0008 equ SPI1_SSPDR          | Data register, SSPDR on page 3-6
4004_000c equ SPI1_SSPSR          | Status register, SSPSR on page 3-7
4004_0010 equ SPI1_SSPCPSR        | Clock prescale register, SSPCPSR on page 3-8
4004_0014 equ SPI1_SSPIMSC        | Interrupt mask set or clear register, SSPIMSC on page 3-9
4004_0018 equ SPI1_SSPRIS         | Raw interrupt status register, SSPRIS on page 3-10
4004_001c equ SPI1_SSPMIS         | Masked interrupt status register, SSPMIS on page 3-11
4004_0020 equ SPI1_SSPICR         | Interrupt clear register, SSPICR on page 3-11
4004_0024 equ SPI1_SSPDMACR       | DMA control register, SSPDMACR on page 3-12
4004_0fe0 equ SPI1_SSPPERIPHID0   | Peripheral identification registers, SSPPeriphID0-3 on page 3-13
4004_0fe4 equ SPI1_SSPPERIPHID1   | Peripheral identification registers, SSPPeriphID0-3 on page 3-13
4004_0fe8 equ SPI1_SSPPERIPHID2   | Peripheral identification registers, SSPPeriphID0-3 on page 3-13
4004_0fec equ SPI1_SSPPERIPHID3   | Peripheral identification registers, SSPPeriphID0-3 on page 3-13
4004_0ff0 equ SPI1_SSPPCELLID0    | PrimeCell identification registers, SSPPCellID0-3 on page 3-16
4004_0ff4 equ SPI1_SSPPCELLID1    | PrimeCell identification registers, SSPPCellID0-3 on page 3-16
4004_0ff8 equ SPI1_SSPPCELLID2    | PrimeCell identification registers, SSPPCellID0-3 on page 3-16
4004_0ffc equ SPI1_SSPPCELLID3    | PrimeCell identification registers, SSPPCellID0-3 on page 3-16

( I2C0)
4004_4000 equ I2C0_IC_CON                  | I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
4004_4004 equ I2C0_IC_TAR                  | I2C Target Address Register This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0. Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
4004_4008 equ I2C0_IC_SAR                  | I2C Slave Address Register
4004_4010 equ I2C0_IC_DATA_CMD             | I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO. The size of the register changes as follows: Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
4004_4014 equ I2C0_IC_SS_SCL_HCNT          | Standard Speed I2C Clock SCL High Count Register
4004_4018 equ I2C0_IC_SS_SCL_LCNT          | Standard Speed I2C Clock SCL Low Count Register
4004_401c equ I2C0_IC_FS_SCL_HCNT          | Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
4004_4020 equ I2C0_IC_FS_SCL_LCNT          | Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
4004_402c equ I2C0_IC_INTR_STAT            | I2C Interrupt Status Register Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
4004_4030 equ I2C0_IC_INTR_MASK            | I2C Interrupt Mask Register. These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
4004_4034 equ I2C0_IC_RAW_INTR_STAT        | I2C Raw Interrupt Status Register Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
4004_4038 equ I2C0_IC_RX_TL                | I2C Receive FIFO Threshold Register
4004_403c equ I2C0_IC_TX_TL                | I2C Transmit FIFO Threshold Register
4004_4040 equ I2C0_IC_CLR_INTR             | Clear Combined and Individual Interrupt Register
4004_4044 equ I2C0_IC_CLR_RX_UNDER         | Clear RX_UNDER Interrupt Register
4004_4048 equ I2C0_IC_CLR_RX_OVER          | Clear RX_OVER Interrupt Register
4004_404c equ I2C0_IC_CLR_TX_OVER          | Clear TX_OVER Interrupt Register
4004_4050 equ I2C0_IC_CLR_RD_REQ           | Clear RD_REQ Interrupt Register
4004_4054 equ I2C0_IC_CLR_TX_ABRT          | Clear TX_ABRT Interrupt Register
4004_4058 equ I2C0_IC_CLR_RX_DONE          | Clear RX_DONE Interrupt Register
4004_405c equ I2C0_IC_CLR_ACTIVITY         | Clear ACTIVITY Interrupt Register
4004_4060 equ I2C0_IC_CLR_STOP_DET         | Clear STOP_DET Interrupt Register
4004_4064 equ I2C0_IC_CLR_START_DET        | Clear START_DET Interrupt Register
4004_4068 equ I2C0_IC_CLR_GEN_CALL         | Clear GEN_CALL Interrupt Register
4004_406c equ I2C0_IC_ENABLE               | I2C Enable Register
4004_4070 equ I2C0_IC_STATUS               | I2C Status Register This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt. When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
4004_4074 equ I2C0_IC_TXFLR                | I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
4004_4078 equ I2C0_IC_RXFLR                | I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
4004_407c equ I2C0_IC_SDA_HOLD             | I2C SDA Hold Time Length Register The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW). The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode. Writes to this register succeed only when IC_ENABLE[0]=0. The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented. The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
4004_4080 equ I2C0_IC_TX_ABRT_SOURCE       | I2C Transmit Abort Source Register This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
4004_4084 equ I2C0_IC_SLV_DATA_NACK_ONLY   | Generate Slave Data NACK Register The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register&#39;s address has no effect. A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
4004_4088 equ I2C0_IC_DMA_CR               | DMA Control Register The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
4004_408c equ I2C0_IC_DMA_TDLR             | DMA Transmit Data Level Register
4004_4090 equ I2C0_IC_DMA_RDLR             | I2C Receive Data Level Register
4004_4094 equ I2C0_IC_SDA_SETUP            | I2C SDA Setup Register This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2. Writes to this register succeed only when IC_ENABLE[0] = 0. Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
4004_4098 equ I2C0_IC_ACK_GENERAL_CALL     | I2C ACK General Call Register The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address. This register is applicable only when the DW_apb_i2c is in slave mode.
4004_409c equ I2C0_IC_ENABLE_STATUS        | I2C Enable Status Register The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled. If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1. If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as &#39;0&#39;. Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
4004_40a0 equ I2C0_IC_FS_SPKLEN            | I2C SS, FS or FM+ spike suppression limit This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
4004_40a8 equ I2C0_IC_CLR_RESTART_DET      | Clear RESTART_DET Interrupt Register
4004_40f4 equ I2C0_IC_COMP_PARAM_1         | Component Parameter Register 1 Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component&#39;s parameter settings. Fields shown below are the settings for those parameters
4004_40f8 equ I2C0_IC_COMP_VERSION         | I2C Component Version Register
4004_40fc equ I2C0_IC_COMP_TYPE            | I2C Component Type Register

( I2C1)
4004_8000 equ I2C1_IC_CON                  | I2C Control Register. This register can be written only when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect. Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are read only.
4004_8004 equ I2C1_IC_TAR                  | I2C Target Address Register This register is 12 bits wide, and bits 31:12 are reserved. This register can be written to only when IC_ENABLE[0] is set to 0. Note: If the software or application is aware that the DW_apb_i2c is not using the TAR address for the pending commands in the Tx FIFO, then it is possible to update the TAR address even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any write to this register if DW_apb_i2c is enabled as an I2C slave only.
4004_8008 equ I2C1_IC_SAR                  | I2C Slave Address Register
4004_8010 equ I2C1_IC_DATA_CMD             | I2C Rx/Tx Data Buffer and Command Register; this is the register the CPU writes to when filling the TX FIFO and the CPU reads from when retrieving bytes from RX FIFO. The size of the register changes as follows: Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a read command should be written for every byte that is to be received; otherwise the DW_apb_i2c will stop acknowledging.
4004_8014 equ I2C1_IC_SS_SCL_HCNT          | Standard Speed I2C Clock SCL High Count Register
4004_8018 equ I2C1_IC_SS_SCL_LCNT          | Standard Speed I2C Clock SCL Low Count Register
4004_801c equ I2C1_IC_FS_SCL_HCNT          | Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
4004_8020 equ I2C1_IC_FS_SCL_LCNT          | Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
4004_802c equ I2C1_IC_INTR_STAT            | I2C Interrupt Status Register Each bit in this register has a corresponding mask bit in the IC_INTR_MASK register. These bits are cleared by reading the matching interrupt clear register. The unmasked raw versions of these bits are available in the IC_RAW_INTR_STAT register.
4004_8030 equ I2C1_IC_INTR_MASK            | I2C Interrupt Mask Register. These bits mask their corresponding interrupt status bits. This register is active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the interrupt.
4004_8034 equ I2C1_IC_RAW_INTR_STAT        | I2C Raw Interrupt Status Register Unlike the IC_INTR_STAT register, these bits are not masked so they always show the true status of the DW_apb_i2c.
4004_8038 equ I2C1_IC_RX_TL                | I2C Receive FIFO Threshold Register
4004_803c equ I2C1_IC_TX_TL                | I2C Transmit FIFO Threshold Register
4004_8040 equ I2C1_IC_CLR_INTR             | Clear Combined and Individual Interrupt Register
4004_8044 equ I2C1_IC_CLR_RX_UNDER         | Clear RX_UNDER Interrupt Register
4004_8048 equ I2C1_IC_CLR_RX_OVER          | Clear RX_OVER Interrupt Register
4004_804c equ I2C1_IC_CLR_TX_OVER          | Clear TX_OVER Interrupt Register
4004_8050 equ I2C1_IC_CLR_RD_REQ           | Clear RD_REQ Interrupt Register
4004_8054 equ I2C1_IC_CLR_TX_ABRT          | Clear TX_ABRT Interrupt Register
4004_8058 equ I2C1_IC_CLR_RX_DONE          | Clear RX_DONE Interrupt Register
4004_805c equ I2C1_IC_CLR_ACTIVITY         | Clear ACTIVITY Interrupt Register
4004_8060 equ I2C1_IC_CLR_STOP_DET         | Clear STOP_DET Interrupt Register
4004_8064 equ I2C1_IC_CLR_START_DET        | Clear START_DET Interrupt Register
4004_8068 equ I2C1_IC_CLR_GEN_CALL         | Clear GEN_CALL Interrupt Register
4004_806c equ I2C1_IC_ENABLE               | I2C Enable Register
4004_8070 equ I2C1_IC_STATUS               | I2C Status Register This is a read-only register used to indicate the current transfer status and FIFO status. The status register may be read at any time. None of the bits in this register request an interrupt. When the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set to 0
4004_8074 equ I2C1_IC_TXFLR                | I2C Transmit FIFO Level Register This register contains the number of valid data entries in the transmit FIFO buffer. It is cleared whenever: - The I2C is disabled - There is a transmit abort - that is, TX_ABRT bit is set in the IC_RAW_INTR_STAT register - The slave bulk transmit mode is aborted The register increments whenever data is placed into the transmit FIFO and decrements when data is taken from the transmit FIFO.
4004_8078 equ I2C1_IC_RXFLR                | I2C Receive FIFO Level Register This register contains the number of valid data entries in the receive FIFO buffer. It is cleared whenever: - The I2C is disabled - Whenever there is a transmit abort caused by any of the events tracked in IC_TX_ABRT_SOURCE The register increments whenever data is placed into the receive FIFO and decrements when data is taken from the receive FIFO.
4004_807c equ I2C1_IC_SDA_HOLD             | I2C SDA Hold Time Length Register The bits [15:0] of this register are used to control the hold time of SDA during transmit in both slave and master mode (after SCL goes from HIGH to LOW). The bits [23:16] of this register are used to extend the SDA transition (if any) whenever SCL is HIGH in the receiver in either master or slave mode. Writes to this register succeed only when IC_ENABLE[0]=0. The values in this register are in units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one cycle in master mode, seven cycles in slave mode) for the value to be implemented. The programmed SDA hold time during transmit (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part of scl. Therefore the programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl period measured in ic_clk cycles.
4004_8080 equ I2C1_IC_TX_ABRT_SOURCE       | I2C Transmit Abort Source Register This register has 32 bits that indicate the source of the TX_ABRT bit. Except for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, Bit 9 clears for one cycle and is then re-asserted.
4004_8084 equ I2C1_IC_SLV_DATA_NACK_ONLY   | Generate Slave Data NACK Register The register is used to generate a NACK for the data part of a transfer when DW_apb_i2c is acting as a slave-receiver. This register only exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this parameter disabled, this register does not exist and writing to the register&#39;s address has no effect. A write can occur on this register if both of the following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) - Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register read-back location for the internal slv_activity signal; the user should poll this before writing the ic_slv_data_nack_only bit.
4004_8088 equ I2C1_IC_DMA_CR               | DMA Control Register The register is used to enable the DMA Controller interface operation. There is a separate bit for transmit and receive. This can be programmed regardless of the state of IC_ENABLE.
4004_808c equ I2C1_IC_DMA_TDLR             | DMA Transmit Data Level Register
4004_8090 equ I2C1_IC_DMA_RDLR             | I2C Receive Data Level Register
4004_8094 equ I2C1_IC_SDA_SETUP            | I2C SDA Setup Register This register controls the amount of time delay (in terms of number of ic_clk clock periods) introduced in the rising edge of SCL - relative to SDA changing - when DW_apb_i2c services a read request in a slave-transmitter operation. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2. Writes to this register succeed only when IC_ENABLE[0] = 0. Note: The length of setup time is calculated using [(IC_SDA_SETUP - 1) * (ic_clk_period)], so if the user requires 10 ic_clk periods of setup time, they should program a value of 11. The IC_SDA_SETUP register is only used by the DW_apb_i2c when operating as a slave transmitter.
4004_8098 equ I2C1_IC_ACK_GENERAL_CALL     | I2C ACK General Call Register The register controls whether DW_apb_i2c responds with a ACK or NACK when it receives an I2C General Call address. This register is applicable only when the DW_apb_i2c is in slave mode.
4004_809c equ I2C1_IC_ENABLE_STATUS        | I2C Enable Status Register The register is used to report the DW_apb_i2c hardware status when the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is disabled. If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and bit 0 is forced to 1. If IC_ENABLE[0] has been set to 0, bits 2:1 is only be valid as soon as bit 0 is read as &#39;0&#39;. Note: When IC_ENABLE[0] has been set to 0, a delay occurs for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on I2C bus activities.
4004_80a0 equ I2C1_IC_FS_SPKLEN            | I2C SS, FS or FM+ spike suppression limit This register is used to store the duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS, FS or FM+ modes. The relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus Specification. This register must be programmed with a minimum value of 1.
4004_80a8 equ I2C1_IC_CLR_RESTART_DET      | Clear RESTART_DET Interrupt Register
4004_80f4 equ I2C1_IC_COMP_PARAM_1         | Component Parameter Register 1 Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only register that contains encoded information about the component&#39;s parameter settings. Fields shown below are the settings for those parameters
4004_80f8 equ I2C1_IC_COMP_VERSION         | I2C Component Version Register
4004_80fc equ I2C1_IC_COMP_TYPE            | I2C Component Type Register

( ADC)
4004_c000 equ ADC_CS       | ADC Control and Status
4004_c004 equ ADC_RESULT   | Result of most recent ADC conversion
4004_c008 equ ADC_FCS      | FIFO control and status
4004_c00c equ ADC_FIFO     | Conversion result FIFO
4004_c010 equ ADC_DIV      | Clock divider. If non-zero, CS_START_MANY will start conversions at regular intervals rather than back-to-back. The divider is reset when either of these fields are written. Total period is 1 + INT + FRAC / 256
4004_c014 equ ADC_INTR     | Raw Interrupts
4004_c018 equ ADC_INTE     | Interrupt Enable
4004_c01c equ ADC_INTF     | Interrupt Force
4004_c020 equ ADC_INTS     | Interrupt status after masking and forcing

( PWM)
4005_0000 equ PWM_CH0_CSR   | Control and status register
4005_0004 equ PWM_CH0_DIV   | INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
4005_0008 equ PWM_CH0_CTR   | Direct access to the PWM counter
4005_000c equ PWM_CH0_CC    | Counter compare values
4005_0010 equ PWM_CH0_TOP   | Counter wrap value
4005_0014 equ PWM_CH1_CSR   | Control and status register
4005_0018 equ PWM_CH1_DIV   | INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
4005_001c equ PWM_CH1_CTR   | Direct access to the PWM counter
4005_0020 equ PWM_CH1_CC    | Counter compare values
4005_0024 equ PWM_CH1_TOP   | Counter wrap value
4005_0028 equ PWM_CH2_CSR   | Control and status register
4005_002c equ PWM_CH2_DIV   | INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
4005_0030 equ PWM_CH2_CTR   | Direct access to the PWM counter
4005_0034 equ PWM_CH2_CC    | Counter compare values
4005_0038 equ PWM_CH2_TOP   | Counter wrap value
4005_003c equ PWM_CH3_CSR   | Control and status register
4005_0040 equ PWM_CH3_DIV   | INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
4005_0044 equ PWM_CH3_CTR   | Direct access to the PWM counter
4005_0048 equ PWM_CH3_CC    | Counter compare values
4005_004c equ PWM_CH3_TOP   | Counter wrap value
4005_0050 equ PWM_CH4_CSR   | Control and status register
4005_0054 equ PWM_CH4_DIV   | INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
4005_0058 equ PWM_CH4_CTR   | Direct access to the PWM counter
4005_005c equ PWM_CH4_CC    | Counter compare values
4005_0060 equ PWM_CH4_TOP   | Counter wrap value
4005_0064 equ PWM_CH5_CSR   | Control and status register
4005_0068 equ PWM_CH5_DIV   | INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
4005_006c equ PWM_CH5_CTR   | Direct access to the PWM counter
4005_0070 equ PWM_CH5_CC    | Counter compare values
4005_0074 equ PWM_CH5_TOP   | Counter wrap value
4005_0078 equ PWM_CH6_CSR   | Control and status register
4005_007c equ PWM_CH6_DIV   | INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
4005_0080 equ PWM_CH6_CTR   | Direct access to the PWM counter
4005_0084 equ PWM_CH6_CC    | Counter compare values
4005_0088 equ PWM_CH6_TOP   | Counter wrap value
4005_008c equ PWM_CH7_CSR   | Control and status register
4005_0090 equ PWM_CH7_DIV   | INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
4005_0094 equ PWM_CH7_CTR   | Direct access to the PWM counter
4005_0098 equ PWM_CH7_CC    | Counter compare values
4005_009c equ PWM_CH7_TOP   | Counter wrap value
4005_00a0 equ PWM_EN        | This register aliases the CSR_EN bits for all channels. Writing to this register allows multiple channels to be enabled or disabled simultaneously, so they can run in perfect sync. For each channel, there is only one physical EN register bit, which can be accessed through here or CHx_CSR.
4005_00a4 equ PWM_INTR      | Raw Interrupts
4005_00a8 equ PWM_INTE      | Interrupt Enable
4005_00ac equ PWM_INTF      | Interrupt Force
4005_00b0 equ PWM_INTS      | Interrupt status after masking and forcing

( TIMER)
4005_4000 equ TIMER_TIMEHW     | Write to bits 63:32 of time always write timelw before timehw
4005_4004 equ TIMER_TIMELW     | Write to bits 31:0 of time writes do not get copied to time until timehw is written
4005_4008 equ TIMER_TIMEHR     | Read from bits 63:32 of time always read timelr before timehr
4005_400c equ TIMER_TIMELR     | Read from bits 31:0 of time
4005_4010 equ TIMER_ALARM0     | Arm alarm 0, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
4005_4014 equ TIMER_ALARM1     | Arm alarm 1, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
4005_4018 equ TIMER_ALARM2     | Arm alarm 2, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
4005_401c equ TIMER_ALARM3     | Arm alarm 3, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
4005_4020 equ TIMER_ARMED      | Indicates the armed/disarmed status of each alarm. A write to the corresponding ALARMx register arms the alarm. Alarms automatically disarm upon firing, but writing ones here will disarm immediately without waiting to fire.
4005_4024 equ TIMER_TIMERAWH   | Raw read from bits 63:32 of time (no side effects)
4005_4028 equ TIMER_TIMERAWL   | Raw read from bits 31:0 of time (no side effects)
4005_402c equ TIMER_DBGPAUSE   | Set bits high to enable pause when the corresponding debug ports are active
4005_4030 equ TIMER_PAUSE      | Set high to pause the timer
4005_4034 equ TIMER_INTR       | Raw Interrupts
4005_4038 equ TIMER_INTE       | Interrupt Enable
4005_403c equ TIMER_INTF       | Interrupt Force
4005_4040 equ TIMER_INTS       | Interrupt status after masking and forcing

( WATCHDOG)
4005_8000 equ WATCHDOG_CTRL       | Watchdog control The rst_wdsel register determines which subsystems are reset when the watchdog is triggered. The watchdog can be triggered in software.
4005_8004 equ WATCHDOG_LOAD       | Load the watchdog timer. The maximum setting is 0xffffff which corresponds to 0xffffff / 2 ticks before triggering a watchdog reset (see errata RP2040-E1).
4005_8008 equ WATCHDOG_REASON     | Logs the reason for the last reset. Both bits are zero for the case of a hardware reset.
4005_800c equ WATCHDOG_SCRATCH0   | Scratch register. Information persists through soft reset of the chip.
4005_8010 equ WATCHDOG_SCRATCH1   | Scratch register. Information persists through soft reset of the chip.
4005_8014 equ WATCHDOG_SCRATCH2   | Scratch register. Information persists through soft reset of the chip.
4005_8018 equ WATCHDOG_SCRATCH3   | Scratch register. Information persists through soft reset of the chip.
4005_801c equ WATCHDOG_SCRATCH4   | Scratch register. Information persists through soft reset of the chip.
4005_8020 equ WATCHDOG_SCRATCH5   | Scratch register. Information persists through soft reset of the chip.
4005_8024 equ WATCHDOG_SCRATCH6   | Scratch register. Information persists through soft reset of the chip.
4005_8028 equ WATCHDOG_SCRATCH7   | Scratch register. Information persists through soft reset of the chip.
4005_802c equ WATCHDOG_TICK       | Controls the tick generator

( RTC)
4005_c000 equ RTC_CLKDIV_M1     | Divider minus 1 for the 1 second counter. Safe to change the value when RTC is not enabled.
4005_c004 equ RTC_SETUP_0       | RTC setup register 0
4005_c008 equ RTC_SETUP_1       | RTC setup register 1
4005_c00c equ RTC_CTRL          | RTC Control and status
4005_c010 equ RTC_IRQ_SETUP_0   | Interrupt setup register 0
4005_c014 equ RTC_IRQ_SETUP_1   | Interrupt setup register 1
4005_c018 equ RTC_RTC_1         | RTC register 1.
4005_c01c equ RTC_RTC_0         | RTC register 0 Read this before RTC 1!
4005_c020 equ RTC_INTR          | Raw Interrupts
4005_c024 equ RTC_INTE          | Interrupt Enable
4005_c028 equ RTC_INTF          | Interrupt Force
4005_c02c equ RTC_INTS          | Interrupt status after masking and forcing

( ROSC)
4006_0000 equ ROSC_CTRL        | Ring Oscillator control
4006_0004 equ ROSC_FREQA       | The FREQA and FREQB registers control the frequency by controlling the drive strength of each stage The drive strength has 4 levels determined by the number of bits set Increasing the number of bits set increases the drive strength and increases the oscillation frequency 0 bits set is the default drive strength 1 bit set doubles the drive strength 2 bits set triples drive strength 3 bits set quadruples drive strength
4006_0008 equ ROSC_FREQB       | For a detailed description see freqa register
4006_000c equ ROSC_DORMANT     | Ring Oscillator pause control
4006_0010 equ ROSC_DIV         | Controls the output divider
4006_0014 equ ROSC_PHASE       | Controls the phase shifted output
4006_0018 equ ROSC_STATUS      | Ring Oscillator Status
4006_001c equ ROSC_RANDOMBIT   | This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency
4006_0020 equ ROSC_COUNT       | A down counter running at the ROSC frequency which counts to zero and stops. To start the counter write a non-zero value. Can be used for short software pauses when setting up time sensitive hardware.

( VREG_AND_CHIP_RESET)
4006_4000 equ VREG_AND_CHIP_RESET_VREG         | Voltage regulator control and status
4006_4004 equ VREG_AND_CHIP_RESET_BOD          | brown-out detection control
4006_4008 equ VREG_AND_CHIP_RESET_CHIP_RESET   | Chip reset control and status

( TBMAN)
4006_c000 equ TBMAN_PLATFORM   | Indicates the type of platform in use

( DMA)
5000_0000 equ DMA_CH0_READ_ADDR               | DMA Channel 0 Read Address pointer
5000_0004 equ DMA_CH0_WRITE_ADDR              | DMA Channel 0 Write Address pointer
5000_0008 equ DMA_CH0_TRANS_COUNT             | DMA Channel 0 Transfer Count
5000_000c equ DMA_CH0_CTRL_TRIG               | DMA Channel 0 Control and Status
5000_0010 equ DMA_CH0_AL1_CTRL                | Alias for channel 0 CTRL register
5000_0014 equ DMA_CH0_AL1_READ_ADDR           | Alias for channel 0 READ_ADDR register
5000_0018 equ DMA_CH0_AL1_WRITE_ADDR          | Alias for channel 0 WRITE_ADDR register
5000_001c equ DMA_CH0_AL1_TRANS_COUNT_TRIG    | Alias for channel 0 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0020 equ DMA_CH0_AL2_CTRL                | Alias for channel 0 CTRL register
5000_0024 equ DMA_CH0_AL2_TRANS_COUNT         | Alias for channel 0 TRANS_COUNT register
5000_0028 equ DMA_CH0_AL2_READ_ADDR           | Alias for channel 0 READ_ADDR register
5000_002c equ DMA_CH0_AL2_WRITE_ADDR_TRIG     | Alias for channel 0 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0030 equ DMA_CH0_AL3_CTRL                | Alias for channel 0 CTRL register
5000_0034 equ DMA_CH0_AL3_WRITE_ADDR          | Alias for channel 0 WRITE_ADDR register
5000_0038 equ DMA_CH0_AL3_TRANS_COUNT         | Alias for channel 0 TRANS_COUNT register
5000_003c equ DMA_CH0_AL3_READ_ADDR_TRIG      | Alias for channel 0 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0040 equ DMA_CH1_READ_ADDR               | DMA Channel 1 Read Address pointer
5000_0044 equ DMA_CH1_WRITE_ADDR              | DMA Channel 1 Write Address pointer
5000_0048 equ DMA_CH1_TRANS_COUNT             | DMA Channel 1 Transfer Count
5000_004c equ DMA_CH1_CTRL_TRIG               | DMA Channel 1 Control and Status
5000_0050 equ DMA_CH1_AL1_CTRL                | Alias for channel 1 CTRL register
5000_0054 equ DMA_CH1_AL1_READ_ADDR           | Alias for channel 1 READ_ADDR register
5000_0058 equ DMA_CH1_AL1_WRITE_ADDR          | Alias for channel 1 WRITE_ADDR register
5000_005c equ DMA_CH1_AL1_TRANS_COUNT_TRIG    | Alias for channel 1 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0060 equ DMA_CH1_AL2_CTRL                | Alias for channel 1 CTRL register
5000_0064 equ DMA_CH1_AL2_TRANS_COUNT         | Alias for channel 1 TRANS_COUNT register
5000_0068 equ DMA_CH1_AL2_READ_ADDR           | Alias for channel 1 READ_ADDR register
5000_006c equ DMA_CH1_AL2_WRITE_ADDR_TRIG     | Alias for channel 1 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0070 equ DMA_CH1_AL3_CTRL                | Alias for channel 1 CTRL register
5000_0074 equ DMA_CH1_AL3_WRITE_ADDR          | Alias for channel 1 WRITE_ADDR register
5000_0078 equ DMA_CH1_AL3_TRANS_COUNT         | Alias for channel 1 TRANS_COUNT register
5000_007c equ DMA_CH1_AL3_READ_ADDR_TRIG      | Alias for channel 1 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0080 equ DMA_CH2_READ_ADDR               | DMA Channel 2 Read Address pointer
5000_0084 equ DMA_CH2_WRITE_ADDR              | DMA Channel 2 Write Address pointer
5000_0088 equ DMA_CH2_TRANS_COUNT             | DMA Channel 2 Transfer Count
5000_008c equ DMA_CH2_CTRL_TRIG               | DMA Channel 2 Control and Status
5000_0090 equ DMA_CH2_AL1_CTRL                | Alias for channel 2 CTRL register
5000_0094 equ DMA_CH2_AL1_READ_ADDR           | Alias for channel 2 READ_ADDR register
5000_0098 equ DMA_CH2_AL1_WRITE_ADDR          | Alias for channel 2 WRITE_ADDR register
5000_009c equ DMA_CH2_AL1_TRANS_COUNT_TRIG    | Alias for channel 2 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_00a0 equ DMA_CH2_AL2_CTRL                | Alias for channel 2 CTRL register
5000_00a4 equ DMA_CH2_AL2_TRANS_COUNT         | Alias for channel 2 TRANS_COUNT register
5000_00a8 equ DMA_CH2_AL2_READ_ADDR           | Alias for channel 2 READ_ADDR register
5000_00ac equ DMA_CH2_AL2_WRITE_ADDR_TRIG     | Alias for channel 2 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_00b0 equ DMA_CH2_AL3_CTRL                | Alias for channel 2 CTRL register
5000_00b4 equ DMA_CH2_AL3_WRITE_ADDR          | Alias for channel 2 WRITE_ADDR register
5000_00b8 equ DMA_CH2_AL3_TRANS_COUNT         | Alias for channel 2 TRANS_COUNT register
5000_00bc equ DMA_CH2_AL3_READ_ADDR_TRIG      | Alias for channel 2 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_00c0 equ DMA_CH3_READ_ADDR               | DMA Channel 3 Read Address pointer
5000_00c4 equ DMA_CH3_WRITE_ADDR              | DMA Channel 3 Write Address pointer
5000_00c8 equ DMA_CH3_TRANS_COUNT             | DMA Channel 3 Transfer Count
5000_00cc equ DMA_CH3_CTRL_TRIG               | DMA Channel 3 Control and Status
5000_00d0 equ DMA_CH3_AL1_CTRL                | Alias for channel 3 CTRL register
5000_00d4 equ DMA_CH3_AL1_READ_ADDR           | Alias for channel 3 READ_ADDR register
5000_00d8 equ DMA_CH3_AL1_WRITE_ADDR          | Alias for channel 3 WRITE_ADDR register
5000_00dc equ DMA_CH3_AL1_TRANS_COUNT_TRIG    | Alias for channel 3 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_00e0 equ DMA_CH3_AL2_CTRL                | Alias for channel 3 CTRL register
5000_00e4 equ DMA_CH3_AL2_TRANS_COUNT         | Alias for channel 3 TRANS_COUNT register
5000_00e8 equ DMA_CH3_AL2_READ_ADDR           | Alias for channel 3 READ_ADDR register
5000_00ec equ DMA_CH3_AL2_WRITE_ADDR_TRIG     | Alias for channel 3 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_00f0 equ DMA_CH3_AL3_CTRL                | Alias for channel 3 CTRL register
5000_00f4 equ DMA_CH3_AL3_WRITE_ADDR          | Alias for channel 3 WRITE_ADDR register
5000_00f8 equ DMA_CH3_AL3_TRANS_COUNT         | Alias for channel 3 TRANS_COUNT register
5000_00fc equ DMA_CH3_AL3_READ_ADDR_TRIG      | Alias for channel 3 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0100 equ DMA_CH4_READ_ADDR               | DMA Channel 4 Read Address pointer
5000_0104 equ DMA_CH4_WRITE_ADDR              | DMA Channel 4 Write Address pointer
5000_0108 equ DMA_CH4_TRANS_COUNT             | DMA Channel 4 Transfer Count
5000_010c equ DMA_CH4_CTRL_TRIG               | DMA Channel 4 Control and Status
5000_0110 equ DMA_CH4_AL1_CTRL                | Alias for channel 4 CTRL register
5000_0114 equ DMA_CH4_AL1_READ_ADDR           | Alias for channel 4 READ_ADDR register
5000_0118 equ DMA_CH4_AL1_WRITE_ADDR          | Alias for channel 4 WRITE_ADDR register
5000_011c equ DMA_CH4_AL1_TRANS_COUNT_TRIG    | Alias for channel 4 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0120 equ DMA_CH4_AL2_CTRL                | Alias for channel 4 CTRL register
5000_0124 equ DMA_CH4_AL2_TRANS_COUNT         | Alias for channel 4 TRANS_COUNT register
5000_0128 equ DMA_CH4_AL2_READ_ADDR           | Alias for channel 4 READ_ADDR register
5000_012c equ DMA_CH4_AL2_WRITE_ADDR_TRIG     | Alias for channel 4 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0130 equ DMA_CH4_AL3_CTRL                | Alias for channel 4 CTRL register
5000_0134 equ DMA_CH4_AL3_WRITE_ADDR          | Alias for channel 4 WRITE_ADDR register
5000_0138 equ DMA_CH4_AL3_TRANS_COUNT         | Alias for channel 4 TRANS_COUNT register
5000_013c equ DMA_CH4_AL3_READ_ADDR_TRIG      | Alias for channel 4 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0140 equ DMA_CH5_READ_ADDR               | DMA Channel 5 Read Address pointer
5000_0144 equ DMA_CH5_WRITE_ADDR              | DMA Channel 5 Write Address pointer
5000_0148 equ DMA_CH5_TRANS_COUNT             | DMA Channel 5 Transfer Count
5000_014c equ DMA_CH5_CTRL_TRIG               | DMA Channel 5 Control and Status
5000_0150 equ DMA_CH5_AL1_CTRL                | Alias for channel 5 CTRL register
5000_0154 equ DMA_CH5_AL1_READ_ADDR           | Alias for channel 5 READ_ADDR register
5000_0158 equ DMA_CH5_AL1_WRITE_ADDR          | Alias for channel 5 WRITE_ADDR register
5000_015c equ DMA_CH5_AL1_TRANS_COUNT_TRIG    | Alias for channel 5 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0160 equ DMA_CH5_AL2_CTRL                | Alias for channel 5 CTRL register
5000_0164 equ DMA_CH5_AL2_TRANS_COUNT         | Alias for channel 5 TRANS_COUNT register
5000_0168 equ DMA_CH5_AL2_READ_ADDR           | Alias for channel 5 READ_ADDR register
5000_016c equ DMA_CH5_AL2_WRITE_ADDR_TRIG     | Alias for channel 5 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0170 equ DMA_CH5_AL3_CTRL                | Alias for channel 5 CTRL register
5000_0174 equ DMA_CH5_AL3_WRITE_ADDR          | Alias for channel 5 WRITE_ADDR register
5000_0178 equ DMA_CH5_AL3_TRANS_COUNT         | Alias for channel 5 TRANS_COUNT register
5000_017c equ DMA_CH5_AL3_READ_ADDR_TRIG      | Alias for channel 5 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0180 equ DMA_CH6_READ_ADDR               | DMA Channel 6 Read Address pointer
5000_0184 equ DMA_CH6_WRITE_ADDR              | DMA Channel 6 Write Address pointer
5000_0188 equ DMA_CH6_TRANS_COUNT             | DMA Channel 6 Transfer Count
5000_018c equ DMA_CH6_CTRL_TRIG               | DMA Channel 6 Control and Status
5000_0190 equ DMA_CH6_AL1_CTRL                | Alias for channel 6 CTRL register
5000_0194 equ DMA_CH6_AL1_READ_ADDR           | Alias for channel 6 READ_ADDR register
5000_0198 equ DMA_CH6_AL1_WRITE_ADDR          | Alias for channel 6 WRITE_ADDR register
5000_019c equ DMA_CH6_AL1_TRANS_COUNT_TRIG    | Alias for channel 6 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_01a0 equ DMA_CH6_AL2_CTRL                | Alias for channel 6 CTRL register
5000_01a4 equ DMA_CH6_AL2_TRANS_COUNT         | Alias for channel 6 TRANS_COUNT register
5000_01a8 equ DMA_CH6_AL2_READ_ADDR           | Alias for channel 6 READ_ADDR register
5000_01ac equ DMA_CH6_AL2_WRITE_ADDR_TRIG     | Alias for channel 6 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_01b0 equ DMA_CH6_AL3_CTRL                | Alias for channel 6 CTRL register
5000_01b4 equ DMA_CH6_AL3_WRITE_ADDR          | Alias for channel 6 WRITE_ADDR register
5000_01b8 equ DMA_CH6_AL3_TRANS_COUNT         | Alias for channel 6 TRANS_COUNT register
5000_01bc equ DMA_CH6_AL3_READ_ADDR_TRIG      | Alias for channel 6 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_01c0 equ DMA_CH7_READ_ADDR               | DMA Channel 7 Read Address pointer
5000_01c4 equ DMA_CH7_WRITE_ADDR              | DMA Channel 7 Write Address pointer
5000_01c8 equ DMA_CH7_TRANS_COUNT             | DMA Channel 7 Transfer Count
5000_01cc equ DMA_CH7_CTRL_TRIG               | DMA Channel 7 Control and Status
5000_01d0 equ DMA_CH7_AL1_CTRL                | Alias for channel 7 CTRL register
5000_01d4 equ DMA_CH7_AL1_READ_ADDR           | Alias for channel 7 READ_ADDR register
5000_01d8 equ DMA_CH7_AL1_WRITE_ADDR          | Alias for channel 7 WRITE_ADDR register
5000_01dc equ DMA_CH7_AL1_TRANS_COUNT_TRIG    | Alias for channel 7 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_01e0 equ DMA_CH7_AL2_CTRL                | Alias for channel 7 CTRL register
5000_01e4 equ DMA_CH7_AL2_TRANS_COUNT         | Alias for channel 7 TRANS_COUNT register
5000_01e8 equ DMA_CH7_AL2_READ_ADDR           | Alias for channel 7 READ_ADDR register
5000_01ec equ DMA_CH7_AL2_WRITE_ADDR_TRIG     | Alias for channel 7 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_01f0 equ DMA_CH7_AL3_CTRL                | Alias for channel 7 CTRL register
5000_01f4 equ DMA_CH7_AL3_WRITE_ADDR          | Alias for channel 7 WRITE_ADDR register
5000_01f8 equ DMA_CH7_AL3_TRANS_COUNT         | Alias for channel 7 TRANS_COUNT register
5000_01fc equ DMA_CH7_AL3_READ_ADDR_TRIG      | Alias for channel 7 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0200 equ DMA_CH8_READ_ADDR               | DMA Channel 8 Read Address pointer
5000_0204 equ DMA_CH8_WRITE_ADDR              | DMA Channel 8 Write Address pointer
5000_0208 equ DMA_CH8_TRANS_COUNT             | DMA Channel 8 Transfer Count
5000_020c equ DMA_CH8_CTRL_TRIG               | DMA Channel 8 Control and Status
5000_0210 equ DMA_CH8_AL1_CTRL                | Alias for channel 8 CTRL register
5000_0214 equ DMA_CH8_AL1_READ_ADDR           | Alias for channel 8 READ_ADDR register
5000_0218 equ DMA_CH8_AL1_WRITE_ADDR          | Alias for channel 8 WRITE_ADDR register
5000_021c equ DMA_CH8_AL1_TRANS_COUNT_TRIG    | Alias for channel 8 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0220 equ DMA_CH8_AL2_CTRL                | Alias for channel 8 CTRL register
5000_0224 equ DMA_CH8_AL2_TRANS_COUNT         | Alias for channel 8 TRANS_COUNT register
5000_0228 equ DMA_CH8_AL2_READ_ADDR           | Alias for channel 8 READ_ADDR register
5000_022c equ DMA_CH8_AL2_WRITE_ADDR_TRIG     | Alias for channel 8 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0230 equ DMA_CH8_AL3_CTRL                | Alias for channel 8 CTRL register
5000_0234 equ DMA_CH8_AL3_WRITE_ADDR          | Alias for channel 8 WRITE_ADDR register
5000_0238 equ DMA_CH8_AL3_TRANS_COUNT         | Alias for channel 8 TRANS_COUNT register
5000_023c equ DMA_CH8_AL3_READ_ADDR_TRIG      | Alias for channel 8 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0240 equ DMA_CH9_READ_ADDR               | DMA Channel 9 Read Address pointer
5000_0244 equ DMA_CH9_WRITE_ADDR              | DMA Channel 9 Write Address pointer
5000_0248 equ DMA_CH9_TRANS_COUNT             | DMA Channel 9 Transfer Count
5000_024c equ DMA_CH9_CTRL_TRIG               | DMA Channel 9 Control and Status
5000_0250 equ DMA_CH9_AL1_CTRL                | Alias for channel 9 CTRL register
5000_0254 equ DMA_CH9_AL1_READ_ADDR           | Alias for channel 9 READ_ADDR register
5000_0258 equ DMA_CH9_AL1_WRITE_ADDR          | Alias for channel 9 WRITE_ADDR register
5000_025c equ DMA_CH9_AL1_TRANS_COUNT_TRIG    | Alias for channel 9 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0260 equ DMA_CH9_AL2_CTRL                | Alias for channel 9 CTRL register
5000_0264 equ DMA_CH9_AL2_TRANS_COUNT         | Alias for channel 9 TRANS_COUNT register
5000_0268 equ DMA_CH9_AL2_READ_ADDR           | Alias for channel 9 READ_ADDR register
5000_026c equ DMA_CH9_AL2_WRITE_ADDR_TRIG     | Alias for channel 9 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0270 equ DMA_CH9_AL3_CTRL                | Alias for channel 9 CTRL register
5000_0274 equ DMA_CH9_AL3_WRITE_ADDR          | Alias for channel 9 WRITE_ADDR register
5000_0278 equ DMA_CH9_AL3_TRANS_COUNT         | Alias for channel 9 TRANS_COUNT register
5000_027c equ DMA_CH9_AL3_READ_ADDR_TRIG      | Alias for channel 9 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0280 equ DMA_CH10_READ_ADDR              | DMA Channel 10 Read Address pointer
5000_0284 equ DMA_CH10_WRITE_ADDR             | DMA Channel 10 Write Address pointer
5000_0288 equ DMA_CH10_TRANS_COUNT            | DMA Channel 10 Transfer Count
5000_028c equ DMA_CH10_CTRL_TRIG              | DMA Channel 10 Control and Status
5000_0290 equ DMA_CH10_AL1_CTRL               | Alias for channel 10 CTRL register
5000_0294 equ DMA_CH10_AL1_READ_ADDR          | Alias for channel 10 READ_ADDR register
5000_0298 equ DMA_CH10_AL1_WRITE_ADDR         | Alias for channel 10 WRITE_ADDR register
5000_029c equ DMA_CH10_AL1_TRANS_COUNT_TRIG   | Alias for channel 10 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_02a0 equ DMA_CH10_AL2_CTRL               | Alias for channel 10 CTRL register
5000_02a4 equ DMA_CH10_AL2_TRANS_COUNT        | Alias for channel 10 TRANS_COUNT register
5000_02a8 equ DMA_CH10_AL2_READ_ADDR          | Alias for channel 10 READ_ADDR register
5000_02ac equ DMA_CH10_AL2_WRITE_ADDR_TRIG    | Alias for channel 10 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_02b0 equ DMA_CH10_AL3_CTRL               | Alias for channel 10 CTRL register
5000_02b4 equ DMA_CH10_AL3_WRITE_ADDR         | Alias for channel 10 WRITE_ADDR register
5000_02b8 equ DMA_CH10_AL3_TRANS_COUNT        | Alias for channel 10 TRANS_COUNT register
5000_02bc equ DMA_CH10_AL3_READ_ADDR_TRIG     | Alias for channel 10 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_02c0 equ DMA_CH11_READ_ADDR              | DMA Channel 11 Read Address pointer
5000_02c4 equ DMA_CH11_WRITE_ADDR             | DMA Channel 11 Write Address pointer
5000_02c8 equ DMA_CH11_TRANS_COUNT            | DMA Channel 11 Transfer Count
5000_02cc equ DMA_CH11_CTRL_TRIG              | DMA Channel 11 Control and Status
5000_02d0 equ DMA_CH11_AL1_CTRL               | Alias for channel 11 CTRL register
5000_02d4 equ DMA_CH11_AL1_READ_ADDR          | Alias for channel 11 READ_ADDR register
5000_02d8 equ DMA_CH11_AL1_WRITE_ADDR         | Alias for channel 11 WRITE_ADDR register
5000_02dc equ DMA_CH11_AL1_TRANS_COUNT_TRIG   | Alias for channel 11 TRANS_COUNT register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_02e0 equ DMA_CH11_AL2_CTRL               | Alias for channel 11 CTRL register
5000_02e4 equ DMA_CH11_AL2_TRANS_COUNT        | Alias for channel 11 TRANS_COUNT register
5000_02e8 equ DMA_CH11_AL2_READ_ADDR          | Alias for channel 11 READ_ADDR register
5000_02ec equ DMA_CH11_AL2_WRITE_ADDR_TRIG    | Alias for channel 11 WRITE_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_02f0 equ DMA_CH11_AL3_CTRL               | Alias for channel 11 CTRL register
5000_02f4 equ DMA_CH11_AL3_WRITE_ADDR         | Alias for channel 11 WRITE_ADDR register
5000_02f8 equ DMA_CH11_AL3_TRANS_COUNT        | Alias for channel 11 TRANS_COUNT register
5000_02fc equ DMA_CH11_AL3_READ_ADDR_TRIG     | Alias for channel 11 READ_ADDR register This is a trigger register (0xc). Writing a nonzero value will reload the channel counter and start the channel.
5000_0400 equ DMA_INTR                        | Interrupt Status (raw)
5000_0404 equ DMA_INTE0                       | Interrupt Enables for IRQ 0
5000_0408 equ DMA_INTF0                       | Force Interrupts
5000_040c equ DMA_INTS0                       | Interrupt Status for IRQ 0
5000_0410 equ DMA_INTR1                       | Interrupt Status (raw)
5000_0414 equ DMA_INTE1                       | Interrupt Enables for IRQ 1
5000_0418 equ DMA_INTF1                       | Force Interrupts for IRQ 1
5000_041c equ DMA_INTS1                       | Interrupt Status (masked) for IRQ 1
5000_0420 equ DMA_TIMER0                      | Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
5000_0424 equ DMA_TIMER1                      | Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
5000_0428 equ DMA_TIMER2                      | Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
5000_042c equ DMA_TIMER3                      | Pacing (X/Y) Fractional Timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
5000_0430 equ DMA_MULTI_CHAN_TRIGGER          | Trigger one or more channels simultaneously
5000_0434 equ DMA_SNIFF_CTRL                  | Sniffer Control
5000_0438 equ DMA_SNIFF_DATA                  | Data accumulator for sniff hardware
5000_0440 equ DMA_FIFO_LEVELS                 | Debug RAF, WAF, TDF levels
5000_0444 equ DMA_CHAN_ABORT                  | Abort an in-progress transfer sequence on one or more channels
5000_0448 equ DMA_N_CHANNELS                  | The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
5000_0800 equ DMA_CH0_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0804 equ DMA_CH0_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0840 equ DMA_CH1_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0844 equ DMA_CH1_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0880 equ DMA_CH2_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0884 equ DMA_CH2_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_08c0 equ DMA_CH3_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_08c4 equ DMA_CH3_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0900 equ DMA_CH4_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0904 equ DMA_CH4_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0940 equ DMA_CH5_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0944 equ DMA_CH5_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0980 equ DMA_CH6_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0984 equ DMA_CH6_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_09c0 equ DMA_CH7_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_09c4 equ DMA_CH7_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0a00 equ DMA_CH8_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0a04 equ DMA_CH8_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0a40 equ DMA_CH9_DBG_CTDREQ              | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0a44 equ DMA_CH9_DBG_TCR                 | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0a80 equ DMA_CH10_DBG_CTDREQ             | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0a84 equ DMA_CH10_DBG_TCR                | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer
5000_0ac0 equ DMA_CH11_DBG_CTDREQ             | Read: get channel DREQ counter (i.e. how many accesses the DMA expects it can perform on the peripheral without overflow/underflow. Write any value: clears the counter, and cause channel to re-initiate DREQ handshake.
5000_0ac4 equ DMA_CH11_DBG_TCR                | Read to get channel TRANS_COUNT reload value, i.e. the length of the next transfer

( USB_DPRAM)
5010_0000 equ USB_DPRAM_SETUP_PACKET_LOW          | Bytes 0-3 of the SETUP packet from the host.
5010_0004 equ USB_DPRAM_SETUP_PACKET_HIGH         | Bytes 4-7 of the setup packet from the host.
5010_0008 equ USB_DPRAM_EP1_IN_CONTROL
5010_000c equ USB_DPRAM_EP1_OUT_CONTROL
5010_0010 equ USB_DPRAM_EP2_IN_CONTROL
5010_0014 equ USB_DPRAM_EP2_OUT_CONTROL
5010_0018 equ USB_DPRAM_EP3_IN_CONTROL
5010_001c equ USB_DPRAM_EP3_OUT_CONTROL
5010_0020 equ USB_DPRAM_EP4_IN_CONTROL
5010_0024 equ USB_DPRAM_EP4_OUT_CONTROL
5010_0028 equ USB_DPRAM_EP5_IN_CONTROL
5010_002c equ USB_DPRAM_EP5_OUT_CONTROL
5010_0030 equ USB_DPRAM_EP6_IN_CONTROL
5010_0034 equ USB_DPRAM_EP6_OUT_CONTROL
5010_0038 equ USB_DPRAM_EP7_IN_CONTROL
5010_003c equ USB_DPRAM_EP7_OUT_CONTROL
5010_0040 equ USB_DPRAM_EP8_IN_CONTROL
5010_0044 equ USB_DPRAM_EP8_OUT_CONTROL
5010_0048 equ USB_DPRAM_EP9_IN_CONTROL
5010_004c equ USB_DPRAM_EP9_OUT_CONTROL
5010_0050 equ USB_DPRAM_EP10_IN_CONTROL
5010_0054 equ USB_DPRAM_EP10_OUT_CONTROL
5010_0058 equ USB_DPRAM_EP11_IN_CONTROL
5010_005c equ USB_DPRAM_EP11_OUT_CONTROL
5010_0060 equ USB_DPRAM_EP12_IN_CONTROL
5010_0064 equ USB_DPRAM_EP12_OUT_CONTROL
5010_0068 equ USB_DPRAM_EP13_IN_CONTROL
5010_006c equ USB_DPRAM_EP13_OUT_CONTROL
5010_0070 equ USB_DPRAM_EP14_IN_CONTROL
5010_0074 equ USB_DPRAM_EP14_OUT_CONTROL
5010_0078 equ USB_DPRAM_EP15_IN_CONTROL
5010_007c equ USB_DPRAM_EP15_OUT_CONTROL
5010_0080 equ USB_DPRAM_EP0_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_0084 equ USB_DPRAM_EP0_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_0088 equ USB_DPRAM_EP1_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_008c equ USB_DPRAM_EP1_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_0090 equ USB_DPRAM_EP2_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_0094 equ USB_DPRAM_EP2_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_0098 equ USB_DPRAM_EP3_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_009c equ USB_DPRAM_EP3_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00a0 equ USB_DPRAM_EP4_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00a4 equ USB_DPRAM_EP4_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00a8 equ USB_DPRAM_EP5_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00ac equ USB_DPRAM_EP5_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00b0 equ USB_DPRAM_EP6_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00b4 equ USB_DPRAM_EP6_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00b8 equ USB_DPRAM_EP7_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00bc equ USB_DPRAM_EP7_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00c0 equ USB_DPRAM_EP8_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00c4 equ USB_DPRAM_EP8_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00c8 equ USB_DPRAM_EP9_IN_BUFFER_CONTROL     | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00cc equ USB_DPRAM_EP9_OUT_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00d0 equ USB_DPRAM_EP10_IN_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00d4 equ USB_DPRAM_EP10_OUT_BUFFER_CONTROL   | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00d8 equ USB_DPRAM_EP11_IN_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00dc equ USB_DPRAM_EP11_OUT_BUFFER_CONTROL   | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00e0 equ USB_DPRAM_EP12_IN_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00e4 equ USB_DPRAM_EP12_OUT_BUFFER_CONTROL   | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00e8 equ USB_DPRAM_EP13_IN_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00ec equ USB_DPRAM_EP13_OUT_BUFFER_CONTROL   | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00f0 equ USB_DPRAM_EP14_IN_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00f4 equ USB_DPRAM_EP14_OUT_BUFFER_CONTROL   | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00f8 equ USB_DPRAM_EP15_IN_BUFFER_CONTROL    | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.
5010_00fc equ USB_DPRAM_EP15_OUT_BUFFER_CONTROL   | Buffer control for both buffers of an endpoint. Fields ending in a _1 are for buffer 1. Fields ending in a _0 are for buffer 0. Buffer 1 controls are only valid if the endpoint is in double buffered mode.

( USB)
5011_0000 equ USB_ADDR_ENDP                | Device address and endpoint control
5011_0004 equ USB_ADDR_ENDP1               | Interrupt endpoint 1. Only valid for HOST mode.
5011_0008 equ USB_ADDR_ENDP2               | Interrupt endpoint 2. Only valid for HOST mode.
5011_000c equ USB_ADDR_ENDP3               | Interrupt endpoint 3. Only valid for HOST mode.
5011_0010 equ USB_ADDR_ENDP4               | Interrupt endpoint 4. Only valid for HOST mode.
5011_0014 equ USB_ADDR_ENDP5               | Interrupt endpoint 5. Only valid for HOST mode.
5011_0018 equ USB_ADDR_ENDP6               | Interrupt endpoint 6. Only valid for HOST mode.
5011_001c equ USB_ADDR_ENDP7               | Interrupt endpoint 7. Only valid for HOST mode.
5011_0020 equ USB_ADDR_ENDP8               | Interrupt endpoint 8. Only valid for HOST mode.
5011_0024 equ USB_ADDR_ENDP9               | Interrupt endpoint 9. Only valid for HOST mode.
5011_0028 equ USB_ADDR_ENDP10              | Interrupt endpoint 10. Only valid for HOST mode.
5011_002c equ USB_ADDR_ENDP11              | Interrupt endpoint 11. Only valid for HOST mode.
5011_0030 equ USB_ADDR_ENDP12              | Interrupt endpoint 12. Only valid for HOST mode.
5011_0034 equ USB_ADDR_ENDP13              | Interrupt endpoint 13. Only valid for HOST mode.
5011_0038 equ USB_ADDR_ENDP14              | Interrupt endpoint 14. Only valid for HOST mode.
5011_003c equ USB_ADDR_ENDP15              | Interrupt endpoint 15. Only valid for HOST mode.
5011_0040 equ USB_MAIN_CTRL                | Main control register
5011_0044 equ USB_SOF_WR                   | Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.
5011_0048 equ USB_SOF_RD                   | Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.
5011_004c equ USB_SIE_CTRL                 | SIE control register
5011_0050 equ USB_SIE_STATUS               | SIE status register
5011_0054 equ USB_INT_EP_CTRL              | interrupt endpoint control register
5011_0058 equ USB_BUFF_STATUS              | Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.
5011_005c equ USB_BUFF_CPU_SHOULD_HANDLE   | Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.
5011_0060 equ USB_EP_ABORT                 | Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
5011_0064 equ USB_EP_ABORT_DONE            | Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.
5011_0068 equ USB_EP_STALL_ARM             | Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.
5011_006c equ USB_NAK_POLL                 | Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.
5011_0070 equ USB_EP_STATUS_STALL_NAK      | Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.
5011_0074 equ USB_USB_MUXING               | Where to connect the USB controller. Should be to_phy by default.
5011_0078 equ USB_USB_PWR                  | Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable so switch over to the override value.
5011_007c equ USB_USBPHY_DIRECT            | Note that most functions are driven directly from usb_fsls controller. This register allows more detailed control/status from the USB PHY. Useful for debug but not expected to be used in normal operation Use in conjunction with usbphy_direct_override register
5011_0080 equ USB_USBPHY_DIRECT_OVERRIDE
5011_0084 equ USB_USBPHY_TRIM              | Note that most functions are driven directly from usb_fsls controller. This register allows more detailed control/status from the USB PHY. Useful for debug but not expected to be used in normal operation
5011_008c equ USB_INTR                     | Raw Interrupts
5011_0090 equ USB_INTE                     | Interrupt Enable
5011_0094 equ USB_INTF                     | Interrupt Force
5011_0098 equ USB_INTS                     | Interrupt status after masking and forcing

( PIO0)
5020_0000 equ PIO0_CTRL                | PIO control register
5020_0004 equ PIO0_FSTAT               | FIFO status register
5020_0008 equ PIO0_FDEBUG              | FIFO debug register
5020_000c equ PIO0_FLEVEL              | FIFO levels
5020_0010 equ PIO0_TXF0                | Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
5020_0014 equ PIO0_TXF1                | Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
5020_0018 equ PIO0_TXF2                | Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
5020_001c equ PIO0_TXF3                | Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
5020_0020 equ PIO0_RXF0                | Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
5020_0024 equ PIO0_RXF1                | Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
5020_0028 equ PIO0_RXF2                | Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
5020_002c equ PIO0_RXF3                | Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
5020_0030 equ PIO0_IRQ                 | State machine IRQ flags register. Write 1 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There&#39;s no fixed association between flags and state machines -- any state machine can use any flag. Any of the 8 flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. The lower four of these flags are also routed out to system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE.
5020_0034 equ PIO0_IRQ_FORCE           | Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.
5020_0038 equ PIO0_INPUT_SYNC_BYPASS   | There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. 0 -> input is synchronized (default) 1 -> synchronizer is bypassed If in doubt, leave this register as all zeroes.
5020_003c equ PIO0_DBG_PADOUT          | Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
5020_0040 equ PIO0_DBG_PADOE           | Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
5020_0044 equ PIO0_DBG_CFGINFO         | The PIO hardware has some free parameters that may vary between chip products. These should be provided in the chip datasheet, but are also exposed here.
5020_0048 equ PIO0_INSTR_MEM0          | Write-only access to instruction memory location 0
5020_004c equ PIO0_INSTR_MEM1          | Write-only access to instruction memory location 1
5020_0050 equ PIO0_INSTR_MEM2          | Write-only access to instruction memory location 2
5020_0054 equ PIO0_INSTR_MEM3          | Write-only access to instruction memory location 3
5020_0058 equ PIO0_INSTR_MEM4          | Write-only access to instruction memory location 4
5020_005c equ PIO0_INSTR_MEM5          | Write-only access to instruction memory location 5
5020_0060 equ PIO0_INSTR_MEM6          | Write-only access to instruction memory location 6
5020_0064 equ PIO0_INSTR_MEM7          | Write-only access to instruction memory location 7
5020_0068 equ PIO0_INSTR_MEM8          | Write-only access to instruction memory location 8
5020_006c equ PIO0_INSTR_MEM9          | Write-only access to instruction memory location 9
5020_0070 equ PIO0_INSTR_MEM10         | Write-only access to instruction memory location 10
5020_0074 equ PIO0_INSTR_MEM11         | Write-only access to instruction memory location 11
5020_0078 equ PIO0_INSTR_MEM12         | Write-only access to instruction memory location 12
5020_007c equ PIO0_INSTR_MEM13         | Write-only access to instruction memory location 13
5020_0080 equ PIO0_INSTR_MEM14         | Write-only access to instruction memory location 14
5020_0084 equ PIO0_INSTR_MEM15         | Write-only access to instruction memory location 15
5020_0088 equ PIO0_INSTR_MEM16         | Write-only access to instruction memory location 16
5020_008c equ PIO0_INSTR_MEM17         | Write-only access to instruction memory location 17
5020_0090 equ PIO0_INSTR_MEM18         | Write-only access to instruction memory location 18
5020_0094 equ PIO0_INSTR_MEM19         | Write-only access to instruction memory location 19
5020_0098 equ PIO0_INSTR_MEM20         | Write-only access to instruction memory location 20
5020_009c equ PIO0_INSTR_MEM21         | Write-only access to instruction memory location 21
5020_00a0 equ PIO0_INSTR_MEM22         | Write-only access to instruction memory location 22
5020_00a4 equ PIO0_INSTR_MEM23         | Write-only access to instruction memory location 23
5020_00a8 equ PIO0_INSTR_MEM24         | Write-only access to instruction memory location 24
5020_00ac equ PIO0_INSTR_MEM25         | Write-only access to instruction memory location 25
5020_00b0 equ PIO0_INSTR_MEM26         | Write-only access to instruction memory location 26
5020_00b4 equ PIO0_INSTR_MEM27         | Write-only access to instruction memory location 27
5020_00b8 equ PIO0_INSTR_MEM28         | Write-only access to instruction memory location 28
5020_00bc equ PIO0_INSTR_MEM29         | Write-only access to instruction memory location 29
5020_00c0 equ PIO0_INSTR_MEM30         | Write-only access to instruction memory location 30
5020_00c4 equ PIO0_INSTR_MEM31         | Write-only access to instruction memory location 31
5020_00c8 equ PIO0_SM0_CLKDIV          | Clock divisor register for state machine 0 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
5020_00cc equ PIO0_SM0_EXECCTRL        | Execution/behavioural settings for state machine 0
5020_00d0 equ PIO0_SM0_SHIFTCTRL       | Control behaviour of the input/output shift registers for state machine 0
5020_00d4 equ PIO0_SM0_ADDR            | Current instruction address of state machine 0
5020_00d8 equ PIO0_SM0_INSTR           | Read to see the instruction currently addressed by state machine 0&#39;s program counter Write to execute an instruction immediately (including jumps) and then resume execution.
5020_00dc equ PIO0_SM0_PINCTRL         | State machine pin control
5020_00e0 equ PIO0_SM1_CLKDIV          | Clock divisor register for state machine 1 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
5020_00e4 equ PIO0_SM1_EXECCTRL        | Execution/behavioural settings for state machine 1
5020_00e8 equ PIO0_SM1_SHIFTCTRL       | Control behaviour of the input/output shift registers for state machine 1
5020_00ec equ PIO0_SM1_ADDR            | Current instruction address of state machine 1
5020_00f0 equ PIO0_SM1_INSTR           | Read to see the instruction currently addressed by state machine 1&#39;s program counter Write to execute an instruction immediately (including jumps) and then resume execution.
5020_00f4 equ PIO0_SM1_PINCTRL         | State machine pin control
5020_00f8 equ PIO0_SM2_CLKDIV          | Clock divisor register for state machine 2 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
5020_00fc equ PIO0_SM2_EXECCTRL        | Execution/behavioural settings for state machine 2
5020_0100 equ PIO0_SM2_SHIFTCTRL       | Control behaviour of the input/output shift registers for state machine 2
5020_0104 equ PIO0_SM2_ADDR            | Current instruction address of state machine 2
5020_0108 equ PIO0_SM2_INSTR           | Read to see the instruction currently addressed by state machine 2&#39;s program counter Write to execute an instruction immediately (including jumps) and then resume execution.
5020_010c equ PIO0_SM2_PINCTRL         | State machine pin control
5020_0110 equ PIO0_SM3_CLKDIV          | Clock divisor register for state machine 3 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
5020_0114 equ PIO0_SM3_EXECCTRL        | Execution/behavioural settings for state machine 3
5020_0118 equ PIO0_SM3_SHIFTCTRL       | Control behaviour of the input/output shift registers for state machine 3
5020_011c equ PIO0_SM3_ADDR            | Current instruction address of state machine 3
5020_0120 equ PIO0_SM3_INSTR           | Read to see the instruction currently addressed by state machine 3&#39;s program counter Write to execute an instruction immediately (including jumps) and then resume execution.
5020_0124 equ PIO0_SM3_PINCTRL         | State machine pin control
5020_0128 equ PIO0_INTR                | Raw Interrupts
5020_012c equ PIO0_IRQ0_INTE           | Interrupt Enable for irq0
5020_0130 equ PIO0_IRQ0_INTF           | Interrupt Force for irq0
5020_0134 equ PIO0_IRQ0_INTS           | Interrupt status after masking and forcing for irq0
5020_0138 equ PIO0_IRQ1_INTE           | Interrupt Enable for irq1
5020_013c equ PIO0_IRQ1_INTF           | Interrupt Force for irq1
5020_0140 equ PIO0_IRQ1_INTS           | Interrupt status after masking and forcing for irq1

( PIO1)
5030_0000 equ PIO1_CTRL                | PIO control register
5030_0004 equ PIO1_FSTAT               | FIFO status register
5030_0008 equ PIO1_FDEBUG              | FIFO debug register
5030_000c equ PIO1_FLEVEL              | FIFO levels
5030_0010 equ PIO1_TXF0                | Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
5030_0014 equ PIO1_TXF1                | Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
5030_0018 equ PIO1_TXF2                | Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
5030_001c equ PIO1_TXF3                | Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
5030_0020 equ PIO1_RXF0                | Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
5030_0024 equ PIO1_RXF1                | Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
5030_0028 equ PIO1_RXF2                | Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
5030_002c equ PIO1_RXF3                | Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
5030_0030 equ PIO1_IRQ                 | State machine IRQ flags register. Write 1 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There&#39;s no fixed association between flags and state machines -- any state machine can use any flag. Any of the 8 flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. The lower four of these flags are also routed out to system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE.
5030_0034 equ PIO1_IRQ_FORCE           | Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.
5030_0038 equ PIO1_INPUT_SYNC_BYPASS   | There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. 0 -> input is synchronized (default) 1 -> synchronizer is bypassed If in doubt, leave this register as all zeroes.
5030_003c equ PIO1_DBG_PADOUT          | Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
5030_0040 equ PIO1_DBG_PADOE           | Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
5030_0044 equ PIO1_DBG_CFGINFO         | The PIO hardware has some free parameters that may vary between chip products. These should be provided in the chip datasheet, but are also exposed here.
5030_0048 equ PIO1_INSTR_MEM0          | Write-only access to instruction memory location 0
5030_004c equ PIO1_INSTR_MEM1          | Write-only access to instruction memory location 1
5030_0050 equ PIO1_INSTR_MEM2          | Write-only access to instruction memory location 2
5030_0054 equ PIO1_INSTR_MEM3          | Write-only access to instruction memory location 3
5030_0058 equ PIO1_INSTR_MEM4          | Write-only access to instruction memory location 4
5030_005c equ PIO1_INSTR_MEM5          | Write-only access to instruction memory location 5
5030_0060 equ PIO1_INSTR_MEM6          | Write-only access to instruction memory location 6
5030_0064 equ PIO1_INSTR_MEM7          | Write-only access to instruction memory location 7
5030_0068 equ PIO1_INSTR_MEM8          | Write-only access to instruction memory location 8
5030_006c equ PIO1_INSTR_MEM9          | Write-only access to instruction memory location 9
5030_0070 equ PIO1_INSTR_MEM10         | Write-only access to instruction memory location 10
5030_0074 equ PIO1_INSTR_MEM11         | Write-only access to instruction memory location 11
5030_0078 equ PIO1_INSTR_MEM12         | Write-only access to instruction memory location 12
5030_007c equ PIO1_INSTR_MEM13         | Write-only access to instruction memory location 13
5030_0080 equ PIO1_INSTR_MEM14         | Write-only access to instruction memory location 14
5030_0084 equ PIO1_INSTR_MEM15         | Write-only access to instruction memory location 15
5030_0088 equ PIO1_INSTR_MEM16         | Write-only access to instruction memory location 16
5030_008c equ PIO1_INSTR_MEM17         | Write-only access to instruction memory location 17
5030_0090 equ PIO1_INSTR_MEM18         | Write-only access to instruction memory location 18
5030_0094 equ PIO1_INSTR_MEM19         | Write-only access to instruction memory location 19
5030_0098 equ PIO1_INSTR_MEM20         | Write-only access to instruction memory location 20
5030_009c equ PIO1_INSTR_MEM21         | Write-only access to instruction memory location 21
5030_00a0 equ PIO1_INSTR_MEM22         | Write-only access to instruction memory location 22
5030_00a4 equ PIO1_INSTR_MEM23         | Write-only access to instruction memory location 23
5030_00a8 equ PIO1_INSTR_MEM24         | Write-only access to instruction memory location 24
5030_00ac equ PIO1_INSTR_MEM25         | Write-only access to instruction memory location 25
5030_00b0 equ PIO1_INSTR_MEM26         | Write-only access to instruction memory location 26
5030_00b4 equ PIO1_INSTR_MEM27         | Write-only access to instruction memory location 27
5030_00b8 equ PIO1_INSTR_MEM28         | Write-only access to instruction memory location 28
5030_00bc equ PIO1_INSTR_MEM29         | Write-only access to instruction memory location 29
5030_00c0 equ PIO1_INSTR_MEM30         | Write-only access to instruction memory location 30
5030_00c4 equ PIO1_INSTR_MEM31         | Write-only access to instruction memory location 31
5030_00c8 equ PIO1_SM0_CLKDIV          | Clock divisor register for state machine 0 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
5030_00cc equ PIO1_SM0_EXECCTRL        | Execution/behavioural settings for state machine 0
5030_00d0 equ PIO1_SM0_SHIFTCTRL       | Control behaviour of the input/output shift registers for state machine 0
5030_00d4 equ PIO1_SM0_ADDR            | Current instruction address of state machine 0
5030_00d8 equ PIO1_SM0_INSTR           | Read to see the instruction currently addressed by state machine 0&#39;s program counter Write to execute an instruction immediately (including jumps) and then resume execution.
5030_00dc equ PIO1_SM0_PINCTRL         | State machine pin control
5030_00e0 equ PIO1_SM1_CLKDIV          | Clock divisor register for state machine 1 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
5030_00e4 equ PIO1_SM1_EXECCTRL        | Execution/behavioural settings for state machine 1
5030_00e8 equ PIO1_SM1_SHIFTCTRL       | Control behaviour of the input/output shift registers for state machine 1
5030_00ec equ PIO1_SM1_ADDR            | Current instruction address of state machine 1
5030_00f0 equ PIO1_SM1_INSTR           | Read to see the instruction currently addressed by state machine 1&#39;s program counter Write to execute an instruction immediately (including jumps) and then resume execution.
5030_00f4 equ PIO1_SM1_PINCTRL         | State machine pin control
5030_00f8 equ PIO1_SM2_CLKDIV          | Clock divisor register for state machine 2 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
5030_00fc equ PIO1_SM2_EXECCTRL        | Execution/behavioural settings for state machine 2
5030_0100 equ PIO1_SM2_SHIFTCTRL       | Control behaviour of the input/output shift registers for state machine 2
5030_0104 equ PIO1_SM2_ADDR            | Current instruction address of state machine 2
5030_0108 equ PIO1_SM2_INSTR           | Read to see the instruction currently addressed by state machine 2&#39;s program counter Write to execute an instruction immediately (including jumps) and then resume execution.
5030_010c equ PIO1_SM2_PINCTRL         | State machine pin control
5030_0110 equ PIO1_SM3_CLKDIV          | Clock divisor register for state machine 3 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
5030_0114 equ PIO1_SM3_EXECCTRL        | Execution/behavioural settings for state machine 3
5030_0118 equ PIO1_SM3_SHIFTCTRL       | Control behaviour of the input/output shift registers for state machine 3
5030_011c equ PIO1_SM3_ADDR            | Current instruction address of state machine 3
5030_0120 equ PIO1_SM3_INSTR           | Read to see the instruction currently addressed by state machine 3&#39;s program counter Write to execute an instruction immediately (including jumps) and then resume execution.
5030_0124 equ PIO1_SM3_PINCTRL         | State machine pin control
5030_0128 equ PIO1_INTR                | Raw Interrupts
5030_012c equ PIO1_IRQ0_INTE           | Interrupt Enable for irq0
5030_0130 equ PIO1_IRQ0_INTF           | Interrupt Force for irq0
5030_0134 equ PIO1_IRQ0_INTS           | Interrupt status after masking and forcing for irq0
5030_0138 equ PIO1_IRQ1_INTE           | Interrupt Enable for irq1
5030_013c equ PIO1_IRQ1_INTF           | Interrupt Force for irq1
5030_0140 equ PIO1_IRQ1_INTS           | Interrupt status after masking and forcing for irq1

( SIO)
d000_0000 equ SIO_CPUID                | Processor core identifier
d000_0004 equ SIO_GPIO_IN              | Input value for GPIO pins
d000_0008 equ SIO_GPIO_HI_IN           | Input value for QSPI pins
d000_0010 equ SIO_GPIO_OUT             | GPIO output value
d000_0014 equ SIO_GPIO_OUT_SET         | GPIO output value set
d000_0018 equ SIO_GPIO_OUT_CLR         | GPIO output value clear
d000_001c equ SIO_GPIO_OUT_XOR         | GPIO output value XOR
d000_0020 equ SIO_GPIO_OE              | GPIO output enable
d000_0024 equ SIO_GPIO_OE_SET          | GPIO output enable set
d000_0028 equ SIO_GPIO_OE_CLR          | GPIO output enable clear
d000_002c equ SIO_GPIO_OE_XOR          | GPIO output enable XOR
d000_0030 equ SIO_GPIO_HI_OUT          | QSPI output value
d000_0034 equ SIO_GPIO_HI_OUT_SET      | QSPI output value set
d000_0038 equ SIO_GPIO_HI_OUT_CLR      | QSPI output value clear
d000_003c equ SIO_GPIO_HI_OUT_XOR      | QSPI output value XOR
d000_0040 equ SIO_GPIO_HI_OE           | QSPI output enable
d000_0044 equ SIO_GPIO_HI_OE_SET       | QSPI output enable set
d000_0048 equ SIO_GPIO_HI_OE_CLR       | QSPI output enable clear
d000_004c equ SIO_GPIO_HI_OE_XOR       | QSPI output enable XOR
d000_0050 equ SIO_FIFO_ST              | Status register for inter-core FIFOs (mailboxes). There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep. Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX). Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX). The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
d000_0054 equ SIO_FIFO_WR              | Write access to this core&#39;s TX FIFO
d000_0058 equ SIO_FIFO_RD              | Read access to this core&#39;s RX FIFO
d000_005c equ SIO_SPINLOCK_ST          | Spinlock state A bitmap containing the state of all 32 spinlocks (1=locked). Mainly intended for debugging.
d000_0060 equ SIO_DIV_UDIVIDEND        | Divider unsigned dividend Write to the DIVIDEND operand of the divider, i.e. the p in `p / q`. Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. UDIVIDEND/SDIVIDEND are aliases of the same internal register. The U alias starts an unsigned calculation, and the S alias starts a signed calculation.
d000_0064 equ SIO_DIV_UDIVISOR         | Divider unsigned divisor Write to the DIVISOR operand of the divider, i.e. the q in `p / q`. Any operand write starts a new calculation. The results appear in QUOTIENT, REMAINDER. UDIVISOR/SDIVISOR are aliases of the same internal register. The U alias starts an unsigned calculation, and the S alias starts a signed calculation.
d000_0068 equ SIO_DIV_SDIVIDEND        | Divider signed dividend The same as UDIVIDEND, but starts a signed calculation, rather than unsigned.
d000_006c equ SIO_DIV_SDIVISOR         | Divider signed divisor The same as UDIVISOR, but starts a signed calculation, rather than unsigned.
d000_0070 equ SIO_DIV_QUOTIENT         | Divider result quotient The result of `DIVIDEND / DIVISOR` (division). Contents undefined while CSR_READY is low. For signed calculations, QUOTIENT is negative when the signs of DIVIDEND and DIVISOR differ. This register can be written to directly, for context save/restore purposes. This halts any in-progress calculation and sets the CSR_READY and CSR_DIRTY flags. Reading from QUOTIENT clears the CSR_DIRTY flag, so should read results in the order REMAINDER, QUOTIENT if CSR_DIRTY is used.
d000_0074 equ SIO_DIV_REMAINDER        | Divider result remainder The result of `DIVIDEND % DIVISOR` (modulo). Contents undefined while CSR_READY is low. For signed calculations, REMAINDER is negative only when DIVIDEND is negative. This register can be written to directly, for context save/restore purposes. This halts any in-progress calculation and sets the CSR_READY and CSR_DIRTY flags.
d000_0078 equ SIO_DIV_CSR              | Control and status register for divider.
d000_0080 equ SIO_INTERP0_ACCUM0       | Read/write access to accumulator 0
d000_0084 equ SIO_INTERP0_ACCUM1       | Read/write access to accumulator 1
d000_0088 equ SIO_INTERP0_BASE0        | Read/write access to BASE0 register.
d000_008c equ SIO_INTERP0_BASE1        | Read/write access to BASE1 register.
d000_0090 equ SIO_INTERP0_BASE2        | Read/write access to BASE2 register.
d000_0094 equ SIO_INTERP0_POP_LANE0    | Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
d000_0098 equ SIO_INTERP0_POP_LANE1    | Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
d000_009c equ SIO_INTERP0_POP_FULL     | Read FULL result, and simultaneously write lane results to both accumulators (POP).
d000_00a0 equ SIO_INTERP0_PEEK_LANE0   | Read LANE0 result, without altering any internal state (PEEK).
d000_00a4 equ SIO_INTERP0_PEEK_LANE1   | Read LANE1 result, without altering any internal state (PEEK).
d000_00a8 equ SIO_INTERP0_PEEK_FULL    | Read FULL result, without altering any internal state (PEEK).
d000_00ac equ SIO_INTERP0_CTRL_LANE0   | Control register for lane 0
d000_00b0 equ SIO_INTERP0_CTRL_LANE1   | Control register for lane 1
d000_00b4 equ SIO_INTERP0_ACCUM0_ADD   | Values written here are atomically added to ACCUM0 Reading yields lane 0&#39;s raw shift and mask value (BASE0 not added).
d000_00b8 equ SIO_INTERP0_ACCUM1_ADD   | Values written here are atomically added to ACCUM1 Reading yields lane 1&#39;s raw shift and mask value (BASE1 not added).
d000_00bc equ SIO_INTERP0_BASE_1AND0   | On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. Each half is sign-extended to 32 bits if that lane&#39;s SIGNED flag is set.
d000_00c0 equ SIO_INTERP1_ACCUM0       | Read/write access to accumulator 0
d000_00c4 equ SIO_INTERP1_ACCUM1       | Read/write access to accumulator 1
d000_00c8 equ SIO_INTERP1_BASE0        | Read/write access to BASE0 register.
d000_00cc equ SIO_INTERP1_BASE1        | Read/write access to BASE1 register.
d000_00d0 equ SIO_INTERP1_BASE2        | Read/write access to BASE2 register.
d000_00d4 equ SIO_INTERP1_POP_LANE0    | Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
d000_00d8 equ SIO_INTERP1_POP_LANE1    | Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
d000_00dc equ SIO_INTERP1_POP_FULL     | Read FULL result, and simultaneously write lane results to both accumulators (POP).
d000_00e0 equ SIO_INTERP1_PEEK_LANE0   | Read LANE0 result, without altering any internal state (PEEK).
d000_00e4 equ SIO_INTERP1_PEEK_LANE1   | Read LANE1 result, without altering any internal state (PEEK).
d000_00e8 equ SIO_INTERP1_PEEK_FULL    | Read FULL result, without altering any internal state (PEEK).
d000_00ec equ SIO_INTERP1_CTRL_LANE0   | Control register for lane 0
d000_00f0 equ SIO_INTERP1_CTRL_LANE1   | Control register for lane 1
d000_00f4 equ SIO_INTERP1_ACCUM0_ADD   | Values written here are atomically added to ACCUM0 Reading yields lane 0&#39;s raw shift and mask value (BASE0 not added).
d000_00f8 equ SIO_INTERP1_ACCUM1_ADD   | Values written here are atomically added to ACCUM1 Reading yields lane 1&#39;s raw shift and mask value (BASE1 not added).
d000_00fc equ SIO_INTERP1_BASE_1AND0   | On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. Each half is sign-extended to 32 bits if that lane&#39;s SIGNED flag is set.
d000_0100 equ SIO_SPINLOCK0            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0104 equ SIO_SPINLOCK1            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0108 equ SIO_SPINLOCK2            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_010c equ SIO_SPINLOCK3            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0110 equ SIO_SPINLOCK4            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0114 equ SIO_SPINLOCK5            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0118 equ SIO_SPINLOCK6            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_011c equ SIO_SPINLOCK7            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0120 equ SIO_SPINLOCK8            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0124 equ SIO_SPINLOCK9            | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0128 equ SIO_SPINLOCK10           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_012c equ SIO_SPINLOCK11           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0130 equ SIO_SPINLOCK12           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0134 equ SIO_SPINLOCK13           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0138 equ SIO_SPINLOCK14           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_013c equ SIO_SPINLOCK15           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0140 equ SIO_SPINLOCK16           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0144 equ SIO_SPINLOCK17           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0148 equ SIO_SPINLOCK18           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_014c equ SIO_SPINLOCK19           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0150 equ SIO_SPINLOCK20           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0154 equ SIO_SPINLOCK21           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0158 equ SIO_SPINLOCK22           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_015c equ SIO_SPINLOCK23           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0160 equ SIO_SPINLOCK24           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0164 equ SIO_SPINLOCK25           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0168 equ SIO_SPINLOCK26           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_016c equ SIO_SPINLOCK27           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0170 equ SIO_SPINLOCK28           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0174 equ SIO_SPINLOCK29           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_0178 equ SIO_SPINLOCK30           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
d000_017c equ SIO_SPINLOCK31           | Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.

( PPB)
e000_e010 equ PPB_SYST_CSR     | Use the SysTick Control and Status Register to enable the SysTick features.
e000_e014 equ PPB_SYST_RVR     | Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN. To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
e000_e018 equ PPB_SYST_CVR     | Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
e000_e01c equ PPB_SYST_CALIB   | Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
e000_e100 equ PPB_NVIC_ISER    | Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled. If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority.
e000_e180 equ PPB_NVIC_ICER    | Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled.
e000_e200 equ PPB_NVIC_ISPR    | The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending.
e000_e280 equ PPB_NVIC_ICPR    | Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending.
e000_e400 equ PPB_NVIC_IPR0    | Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt. These registers are only word-accessible
e000_e404 equ PPB_NVIC_IPR1    | Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
e000_e408 equ PPB_NVIC_IPR2    | Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
e000_e40c equ PPB_NVIC_IPR3    | Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
e000_e410 equ PPB_NVIC_IPR4    | Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
e000_e414 equ PPB_NVIC_IPR5    | Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
e000_e418 equ PPB_NVIC_IPR6    | Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
e000_e41c equ PPB_NVIC_IPR7    | Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.
e000_ed00 equ PPB_CPUID        | Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core.
e000_ed04 equ PPB_ICSR         | Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception.
e000_ed08 equ PPB_VTOR         | The VTOR holds the vector table offset address.
e000_ed0c equ PPB_AIRCR        | Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
e000_ed10 equ PPB_SCR          | System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
e000_ed14 equ PPB_CCR          | The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault.
e000_ed1c equ PPB_SHPR2        | System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall.
e000_ed20 equ PPB_SHPR3        | System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick.
e000_ed24 equ PPB_SHCSR        | Use the System Handler Control and State Register to determine or clear the pending status of SVCall.
e000_ed90 equ PPB_MPU_TYPE     | Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports.
e000_ed94 equ PPB_MPU_CTRL     | Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs.
e000_ed98 equ PPB_MPU_RNR      | Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR.
e000_ed9c equ PPB_MPU_RBAR     | Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated.
e000_eda0 equ PPB_MPU_RASR     | Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region.
