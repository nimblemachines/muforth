| This file is part of muforth: https://muforth.dev/
|
| Copyright 2002-2024 David Frech. (Read the LICENSE for details.)

( Chat entry and command processing loop.)

__meta
hex

| Compile the first 32 bits of the current muforth Git commit. When asked
| for the version, return these four bytes, in little-endian order.

here
   muforth-commit drop 8 evaluate  >3210  c, c, c, c,

label version-cmd
   ( here) z ldiw  ret  ;c

| Host will use set-addr to set Z to ra of PC to call. run-cmd will push Z, then
| host will send another word for Z, and then execute the code.

label run-cmd
   z pushw ( PC to jump to; already in ra form)
   ( fall through)  ;c

label set-addr-cmd
   recv-word rcall  x z movw  ret  ;c

| NOTE: This can be called after running a piece of code to get some kind
| of status or address back to the host.

label get-addr-cmd
   z x movw  send-word rjmp  ;c

| This is unfortunate, but when we get here from the boot RESET handler -
| from create-tasks - h2 points to the chat user area, so that the next
| created task will link to it.
|
| When called from the chat command loop, h2 is unknown. We have to set it
| to point to the chat user area, otherwise ... BOOM.

label app-start
   chat-user-area h2 ldi  ( first task defined will link to chat)

   ( Read the app RESET vector; if non-empty, call 0000 to create the app's tasks.)
   0 ( app RESET vector) z ldiw
   pmz+ g0 ld  pmz g1 ld  g1 g0 and  g0 com  0= not if  ( unset vector)
      0 call
   then

   | Close the circle. h2 has pointer to last task created. Put it into the
   | chat-task's next pointer, and return.

   chat-user-area y ldiw  1 h2 stu  ret  ;c

| NOTE: If the watchdog is running, chat-only can be used to *cause* a
| watchdog reset.

label chat-only
   cli  chat-user-area    h0 ldi
        chat-user-area 1+ h0 sts  ret  ;c

| NOTE: When we stop the app, we disable interrupts, in case it is
| using them. When it gets restarted, it is up to the app to re-enable
| interrupts.

| To stop the app, we make the chat task the only one in the task loop by
| pointing its next pointer to itself, and then disable the watchdog.

label app-stop
   chat-only rcall
   ( fall thru)  ;c

label watchdog-off
   wdr  18 ( WDCE + WDE) h0 ldi  WDTCSR h0 out
   h0 clr  WDTCSR h0 out  ret  ;c


( Command dispatch.)
label command-table
   ( 10) version-cmd       rjmp
   ( 11) set-addr-cmd      rjmp
   ( 12) get-addr-cmd      rjmp
   ( 13) run-cmd           rjmp

   | We want to group the read commands together so "du" can read from the
   | current memory "space".

   ( 14) read-flash-cmd    rjmp  ( space 0)
   ( 15) read-data-cmd     rjmp  ( space 1)
   ( 16) read-eeprom-cmd   rjmp  ( space 2)

   ( 17) write-flash-cmd   rjmp
   ( 18) write-data-cmd    rjmp
   ( 19) write-eeprom-cmd  rjmp

   ( 1a) app-start         rjmp
   ( 1b) app-stop          rjmp
   ;c

label process
   recv-command-byte rcall
   10 xl subi  ( 00 to 0f become large unsigned numbers)
   process command-table - 2/ xl cpi u< if  xh clr
      command-table 2/ ( word address) negate >hilo  xl subi  xh sbci
      xl push  xh push ( big-endian!)
   then ( unknown... return, and get called again)
   ret  ;c

label chat-task
   serial-init rcall  ( initialize serial interface)

( XXX what about I2C? Is this the right place for this?)
.labels. .contains catch .if
   catch rcall  ( for I2C only)
.then

   begin  process rcall  again  ;c

RESET handler
label system-startup
   | First things first. Turn off the watchdog, in case we got a watchdog
   | reset and it's still enabled. At reset, SP is set to point to the end
   | of RAM, so it's safe to make subroutine calls without setting it.

   watchdog-off rcall

   | Let's start with a clean slate, by setting every byte of the RAM to a
   | known state. We do this in stages. First we set each byte of the task
   | stack page - the last page of the RAM - to hex 55 (so it's easier to
   | see how much space each task is really taking), then, using a temporary
   | stack *below* the stack page, we initialize the task user areas; and,
   | lastly, we set the rest of the RAM to zero.

   @ram #ram + #256 - 2 - x ldiw ( beginning last page of the ram, minus two)

   | Set up a temporary stack - so we can call code to create the tasks -
   | below the task stacks. Since the stacks consume at most a 256 byte
   | page, the page below the last one will do fine.
   |
   | Be careful though: we don't want to clobber the last byte of the page
   | below the task stacks, since we are going to keep a count of watchdog
   | resets there. That's why we subtract *two* before setting SP - one,
   | because the AVR uses an empty descending stack; and one to skip the
   | watchdog reset count byte!

   x sp!-iclear  2 x adiw

   ( Set every byte of the stack page to 55 hex.)
   55 h0 ldi  begin  x+ h0 st  xl tst  0= until

   ( Create the tasks, starting with the chat task.)
   chat-user-area y ldiw
   chat-task 2/ h0 ldiw ( starting pc)
   create-task rcall  ( leaves h2 pointing to chat-user-area)

   | If the app RESET vector is non-empty, app-start will call it, and it
   | will create the app tasks.

   app-start rcall  ( return with y pointing to chat task)

   ( Read the reset flags; save them in g1; and zero them.)
   MCUSR g1 in  g0 clr  MCUSR g0 out  ( clear all reset flags)

   ( Finally, write zeros to the ram, stopping 257 bytes from the end.)
   @ram x ldiw  ( beginning of ram)
   #ram #257 - w ldiw  ( size of ram, minus the last page, minus one)
   begin  x+ g0 st  1 w sbiw  0= until

   | If we experienced a watchdog reset, count it in the last byte of ram
   | before the stack page; otherwise, zero that byte.

   3 ( WDRF) g1 sbrs  never  ( watchdog reset)
      x@ g0 ld  g0 inc
   then
   x+ g0 st  ( store zero or incremented watchdog reset count)

   | The tasking code only changes the low half of the stack pointer, SPL.
   | We need to set SPH correctly before we start the first task!

   chat-user-area 8 >> h0 ldi  SPH h0 out  ( point SPH to task stack page)
   run-task rjmp  ( start chat task)  ;c
