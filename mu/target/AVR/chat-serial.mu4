( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2023 David Frech. (Read the LICENSE for details.)

loading AVR serial chat (core)

__meta

hex

comment %%

Commands for a simple client debug stub for talking to an AVR chip over a
uart connection.

         sends            returns       cmd byte (hex)
  ====================================================
  SetAddr  <lo>  <hi>     nothing        10
  ReadProgram             <byte>         11
  ReadData                <byte>         12
  WriteData  <byte>       nothing        13
  Go                      nothing        14

  ReadData, WriteData read and write data memory -- including the general
        registers, stack pointer, all the i/o registers, and all the RAM.

  ReadProgram reads program memory (flash)

  SetAddr sets the address to be used for reading & writing memory

  Go executes code from the address set by SetAddr
%%

.ndef mega164  .ndef mega324  .ndef mega644  .and .and .if
   z" This code currently only supports the mega164/324/644 devices." abort
.then

comment register-use

  r0/r1              is used for writing flash (via SPM instruction)
  r26/27 -- aka x -- is used for status and data bytes
  r30/31 -- aka z -- is used to point to memory

  These are registers that are considered "scratch" by the meta-compiler's
  conventions.

register-use

( Start, stop, and run the application.)
ld target/AVR/chat-app.mu4

( Let's run the UART at 125kb/s. Baud rate divisor = fosc/bps/16 - 1.)
( No, let's run the UART at 38,400 b/s. Baud rate divisor = fosc/bps/16 - 1.)
label serial-init
   -- #8_000 ( fosc = 8M)  #125 /  #16 /  1 - >hilo
   #8,000,000 ( fosc = 8M)  #38,400 /  #16 /  1 - >hilo
   xl ldi  xh ldi  UBRR1H xh out  UBRR1L xl out
   %0001_1000 xl ldi  UCSR1B xl out  ( enable RX and TX)
   ( chip defaults to 8bits, 1stop, no parity at reset)
   ( fall thru)  ;c

( Called when we re-enter chat after executing code. Necessary for I2C;
  no-op for us.)

label serial-ack   ret  ;c

( Host uses send and recv. Let's do the same here.)

( For both recv-byte and send-byte we want to run the app while we are
  either waiting for a byte to go out or to come in.

  app-run saves and restores r0, r1 and Z around calling the app.)

( Could clobber xh.)
label recv-command-byte  ;c  ( For chat dispatch loop.)
label recv-byte
   ( Wait for RXC - receive complete)
   begin  app-run rcall  UCSR1A xl in  7 ( RXC) xl sbrs  again
   UDR1 xl in  ret  ;c

( Could clobber xh.)
label send-byte
   xl push  ( app might clobber it; and app-run doesn't save it)
   ( Wait for UDRE - data register empty)
   begin  app-run rcall  UCSR1A xl in  5 ( UDRE) xl sbrs  again
   xl pop  UDR1 xl out  ret  ;c

label recv-word
   recv-byte rcall  xl push
   recv-byte rcall  xl xh mov  xl pop  ret  ;c

label send-word
   xh push  ( send-byte might clobber it)
   send-byte rcall  xl pop  send-byte rjmp  ;c

( EEPROM read/write.)
ld target/AVR/eeprom.mu4

( Flash self-programming support.)
ld target/AVR/flash-self-prog.mu4

( Command routines.)
label read-data-cmd
     z+ xl ld  send-byte rjmp  ;c

label write-data-cmd
   recv-byte rcall  z+ xl st  ret  ;c

label read-eeprom-cmd
   read-eeprom-byte rcall  1 z adiw  send-byte rjmp  ;c

label read-flash-cmd
   pmz+ xl ld  send-byte rjmp  ;c

( The following commands take several ms to complete; each one sends a byte
  to the host to signal completeion.)

label write-eeprom-cmd
   recv-byte rcall  write-eeprom-byte rcall
   1 z adiw  send-byte rjmp  ;c

( Recv a word and a byte command from host; write word and cmd to flash;
  return contents of SPMCSR as flash status.)

label write-flash-cmd
   recv-word rcall  x 0 movw  recv-byte rcall ( cmd)  do-spm rcall
   2 z adiw  SPMCSR xl in  send-byte rjmp  ;c

( Load chat entry, dispatch, and init.)
ld target/AVR/chat-loop.mu4
