| This file is part of muforth: https://muforth.dev/
|
| Copyright 2002-2024 David Frech. (Read the LICENSE for details.)

loading S08 Chat v4 (host)

| Chat version 4
|
| This has only minor changes from v3, but making a new version still
| makes. I want to clean things up, drop 908 support, and experiment with
| a "trampoline-style" way of calling code. I'm also thinking of adding
| a simple tasker, like in the AVR target. And in general I like starting
| the commands at 10 (hex), so I'm going to do that too. ;-)

| Commands:
| 00 - 0f and
| 18 - ff      - ignored by chat; force other command loops to return to chat;
|                can be used as an "idle" command
|
| 10 version   - set HX to point to version string
|
| 11 run       - push HX (PC), do set-addr, return to pushed PC
| 12 set-addr  - recv two bytes, write them into H & X registers
| 13 status    - send HX then PC to host
|
| 14 read-n    - recv count, read and send bytes from memory @HX, incrementing
| 15 write-1   - recv byte, write to memory @HX, increment HX
| 16 flash-1   - recv byte, write to flash @HX, increment HX, return FSTAT
|                (calls a routine in ram that host downloads to device)

hex

: >b  send ;
: b>  recv ;

: >w  >lohi >b >b ;        ( send word, in big-endian order)
: w>        b> b> hilo> ;  ( recv word, in big-endian order)

: >cmd  ?spkt >b ;

: cx.idle       00 >b  ;  ( command 0 is ignored by the chat target)
: cx.version    10 >cmd  ;  ( point to chat firmware version commit)
: cx.run        11 >cmd  >w ;  ( don't walk! and don't wait for the target. ;-)
: cx.set-addr   12 >cmd  >w ;
: cx.status     13 >cmd     w> w> ;
: cx.read-n     14 >cmd  >b ;  ( then "stream" N bytes from memory)
: cx.write-1    15 >cmd  >b ;
: cx.flash-1    16 >cmd  >b b> ;  ( flash one byte, get flash status)

| Resynchronise the protocol - just to make sure. We send two dummy bytes,
| in case we were doing a run or set-addr command. We wait for them to
| transmit. Then we throw away any unread input. This puts us back into
| a known state.

: resync  ?spkt  cx.idle  cx.idle  drain  flush ;

.ifndef m&

| We load this file just to run S08 code to, eg, talk to AVR targets, so
| we won't have the version in target/S08/memory.mu4. If the other target
| hasn't loaded the equivalent, we define our own version here.

| Generic tools for reading and writing host-side memory. These give us a
| second "hand" so we can, eg, compare two images using c@+ on the one hand
| and m* on the other.

variable m  ( memory pointer)
: m*  ( - byte)  m @  c@  1 m +! ;
: m&  ( byte)    m @  c!  1 m +! ;

.then  ( ifndef m&)

: c.setup-chunk  ( buf a u - u)  swap cx.set-addr  swap m ! ; 

| For chunked read and write, if chunk count is 0, don't do anything.
: c.read   ( buf a u)
   c.setup-chunk  ?if  dup cx.read-n  for  b> m&  next  then ;

: c.write  ( buf a u)
   c.setup-chunk  ?if  for  m* cx.write-1  next  then ;

: flash-chunk-until-error  ( len - status)
   for  m* cx.flash-1  dup 0c0 xor if  rdrop ^  then  drop  next
   0c0 ;

| Helper for flash-chunk. Set an address, and write a byte there.
: chat-c!  ( b a)  cx.set-addr cx.write-1 ;

: c.flash   ( buf a u cmd - status)
   30 \eq FSTAT chat-c!  ( clear flash errors)
   \m flash-command chat-c!
   c.setup-chunk  flash-chunk-until-error
   00 \m flash-command chat-c! ;

decimal

| XXX to read the PC - to figure out if chat is running in RAM or flash
| - we need to execute a tiny piece of code! It could be in RAM. Something
| like this:
|   txs  0 ,x ldhx  rts
| to read the return address on stack!

| Let's do something crazy: make room on the D stack for a small 3-byte
| routine that will read the return address from top of the machine stack.

| XXX but if I'm putting this here and in chat3-host, it suggests that it
| should be part of the interact interface after all! Probably t.status
| really *does* need to return PC.

: pc@-xx
   h preserve  ram
   \m here  ( save current)
   [ \m dp0 3 - #]  dup \m goto  asm{  tsx  0 ,x ldhx  rts }
   swap \m goto  ( restore current)
   dup image+ swap 3 t.write  ( copy to target)
   0 t.run  t.status  ( execute) ;

.ifdef t.hello  ( only if we've loaded the interact code)

: c.hello  ( - in-ram?)
.ifdef chat-slow  ( using a xtal that only allows 38400)
    38400 bps
.else
   115200 bps
.then
   resync  ( exit BDM loop, if running; resync chat protocol)

   cx.version  4 cx.read-n  b> b> b> b>  3210>
   cr ." Chat firmware version "
   radix preserve  hex  sep preserve  -sep  <#  4#  4#  #> type
   cx.status nip ( pc) [ @ram #ram + #] u<  dup if  ."  (running in RAM)"  then
   ( Copy flash routine to RAM.)  copy-flash-routine ;

: c.status  ( - dp)  cx.status drop ;
: c.run  ( pc dp)  swap cx.set-addr  cx.run ;

: chat
   chat-via  c.hello  cx.status  c.run  c.read  c.write  c.flash ;

.then  ( t.hello)
