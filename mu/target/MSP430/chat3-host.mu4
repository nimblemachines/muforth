( This file is part of muforth: http://muforth.nimblemachines.com/

  Copyright 2002-2018 David Frech. (Read the LICENSE for details.)

loading MSP430 serial chat protocol v3 (host)

hex

( Trying something simple and traditional.

  Responds to the following commands. NOTE: these are hex values!

00 - 2f  Idle   - these command bytes are ignored

30  GetVersion  - get the chat firmware commit
31  GetStatus   - get SP, PC, SR, and CP
32  Run         - set PC, SR, CP, and execute
33  ReadWords   - set address, then read N words
34  WriteWords  - set address, then write N words
35  GetCheck    - return accumulated checksum to host

The following are for older - non-CPUX? non-FRAM? - MSP430s that have
byte-sized i/o from 0020 to 00ff and sport regular Flash memory rather than
FRAM.

36  ReadWordsB  - set address, then read N words bytewise
37  FlashWords  - set flash command, set address, then write N words to Flash

38 - ff  Idle   - these command bytes are ignored
)

variable checksum
: sum!       checksum off ;
: sum  ( w)  checksum @  xor  checksum ! ;

: >b         dup sum  send ;
: b>   recv  dup sum ;

: >w                     dup sum  >hilo  send send ;
: w>   recv recv  lohi>  dup sum ;

: c.Idle                           0 >b  ;
: c.GetVersion  ( - n)            30 >b  w> w>  ( lo hi)  10 << + ;
: c.GetStatus   ( - sp pc sr cp)  31 >b  w> w> w> w> ;

: c.Run         ( pc sr cp)       32 >b  rot >w swap >w >w ;
: c.ReadWords   ( a n)            33 >b  swap >w >b ;  ( then read bytes)
: c.WriteWords  ( a n)            34 >b  swap >w >b ;  ( then write bytes)

: c.GetCheck    ( )               35 >b  w> drop ;

: c.ReadWordsB  ( a n)            36 >b  swap >w >b ;  ( then read bytes)
: c.FlashWords  ( cmd a n)        37 >b  rot >w  swap >w >b ;  ( then write bytes)

( Send two no-ops, let them transmit, _then_ throw away any input bytes.)
: resync  c.Idle  c.Idle  drain  flush ;


.ifdef paranoid

( Reset host's and target's checksum accumulator.)
: ?reset   resync  c.GetCheck              sum! ;
: ?ok              c.GetCheck  checksum @  sum!
   =if  ." checksum failed: " u.  ^  then  drop ;

.else

: ?reset   resync ;
: ?ok ;

.then


: get-status  resync  c.GetStatus ;

: c.setup-chunk  ( buf a u - #words a #words)  rot m !  1+ 2/ ( words)  tuck ;

( Hook into interact code.)
: c.Hello
   #115200 bps  ?reset
   cr ." Chat firmware version "  c.GetVersion  ?ok
   radix preserve  hex  sep preserve  -sep   u. ;

( This is for the sake of the G2553 and other chips that have bytewide i/o
  ports from 0020 to 00ff, and wordwide i/o from 0100 to 01ff.)

: ?read-bytewise  ( a #words - a #words)
   over 0100 u< if  c.ReadWordsB ^  then  c.ReadWords ;

: c.ReadChunk    ( buf a u)
   c.setup-chunk  ?read-bytewise  for  w> >hilo  m& m&  next  ?ok ;

: c.WriteChunk   ( buf a u)
   c.setup-chunk  c.WriteWords  for  m* m* lohi> >w  next  ?ok ;

.equates. .contains FCTL1 .if  ( chip has Flash memory!)

: flash-fail?  ( status - fail?)
   ." FCTL3=" dup u.
   84 and ;

: erase-page  ( 'target - status)
   [ \eq FERASE \eq FKEY + ]  swap  1  ( fcmd a u)  c.FlashWords  0 >w  w> ;

( Or together returned flash statuses for the chunk, then check it once.)
: c.FlashChunk  ( buf a u erase? - ok?)
   if  over erase-page  flash-fail? if  drop 2drop 0  ^  then  then
   c.setup-chunk  ( #words a #words)
   [ \eq FWRT   \eq FKEY + ]  -rot  ( fcmd a u)  c.FlashWords
   0 swap  ( 0 #words)
   for  m* m* lohi>  >w  w> or  next
   flash-failed? 0=  ?ok ;

.else

: c.FlashChunk  ( buf a u erase? - ok?)  drop  c.WriteChunk  -1  ?ok ;

.then

( NOTE: We don't define RunWait separately. Since we will always be reading
  the registers back after Run, that first read command will block until
  the target is ready.)

: chat
   chat-via  c.Hello  get-status  c.Run
             c.ReadChunk  c.WriteChunk  c.FlashChunk ;
