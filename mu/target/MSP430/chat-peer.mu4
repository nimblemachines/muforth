| This file is part of muforth: https://muforth.dev/
|
| Copyright 2002-2025 David Frech. (Read the LICENSE for details.)

loading MSP430 serial chat protocol v2 (peer)

| NOTE: This might seem a bit odd, but this file implements the side of the
| chat protocol normally implemented by firmware in a target chip! The
| reason for doing this here, in muforth, is to test out the protocol by
| having both sides running on the host.

hex

| Taking inspiration from the wildly successful HC08 serial chat protocol.
|
| Responds to the following commands. NOTE: these are hex values!
|
| 00 - 1f  Idle   - these command bytes are ignored
|
| 20  GetVersion  - get the chat protocol version
| 21  SetAddr     - set the memory address pointer
| 22  GetSP       - get stack pointer - points to saved regs
| 23  ReadWord    - read a word from memory, incr pointer
| 24  ReadWords   - read N words, incrementing as we go
| 25  WriteWord   - write a word to memory, incr pointer
| 26  Run         - pop the registers and saved status, and go
| 27  FlashWord   - write a word to flash, passing command each time
|               - can be used to initiate an erase, or to write a word
| 28  GetCheck    - return accumulated checksum to host
| 29  ReadWordsB  - read N words *byte-wise*, incrementing as we go
|
| 2a - ff  Idle   - these command bytes are ignored


variable pty-master
: pty-send  ( b)     pty-master @ >emit ;
: pty-recv  ( - b)   pty-master @ <key ;

( Spying on the protocol.)
variable spy  spy on
: send             spy @ if ." >"  dup .h8_ then  pty-send ;
: recv   pty-recv  spy @ if ." <"  dup .h8_ then ;

| To make spying on the protocol easier to deal with, break up the printed
| bytes into "packets" in a semantically meaningful way. How about this
| stupid name, which is easy to remember:

: ?spkt  ( spy packet, or "spiked")  spy @ if  cr  then ;

variable checksum
: sum  ( w)  checksum @  xor  checksum ! ;

: >b   send ;
: b>   recv ;
: >w   dup sum  >hilo  >b >b ;
: w>   b> b>  lohi>  dup sum ;

variable peer-sp
: p.push  ( w)     peer-sp @       \m cell-  dup  peer-sp !  image-! ;
: p.pop   ( - w)   peer-sp @  dup  \m cell+       peer-sp !  image-@ ;

: peer-push-frame
   @ram #ram +  peer-sp !

.ifdef in-ram
   034c p.push  ( return to "call interact" loop)
   0342 p.push  ( return to "call chat-entry" loop)
.else
   fd70 p.push  ( return to "call interact" loop)
   fd58 p.push  ( return to "call chat-entry" loop)
.then

   d0d0 p.push  ( SR)
   @ram p.push  ( CP) ;

| Compile the first 32 bits of the current muforth Git commit.
| When asked for the version, return these two 16-bit words, in
| little-endian order.

: p.GetVersion   [ muforth-commit drop 8 evaluate #]  dup >w  10 >> >w ;

: p.SetAddr      w>  image+  m ! ;
: p.GetSP        peer-sp @ >w ;

: p.ReadWord     m* m* lohi> >w ;
: p.WriteWord    w> >hilo m& m& ;

: p.ReadWords    b>  dup sum  for  p.ReadWord  next ;

: p.Run
   "c0de checksum !   ( emulate code that clobbers checksum when run)
   peer-push-frame ;

: peer-erase-page
   m @  0 image+ -  ( 'target)  cr ." erase " dup u.  [ /page 1- #] bic  image+  m !
   /page for  0ff m&  next  [ /page negate #]  m +! ;

( Only do the flash operation if fcmd is valid.)
: p.FlashWord
   w> ( value)  w> ( fcmd)
   dup  [ \eq FWRT    \eq FKEY  + #] = if  drop  >hilo m& m&  9658 >w  ^  then
        [ \eq FERASE  \eq FKEY  + #] = if  drop  peer-erase-page  9658 >w  ^  then
   9680 >w  ( bad flash command) ;

: p.GetCheck     checksum @ >w ;  ( zeroes checksum!!)

: peer-command
   ?spkt  b>  dup sum  20 - dup 0a u< if  jump
      p.GetVersion  p.SetAddr  p.GetSP
      p.ReadWord  p.ReadWords  p.WriteWord
      p.Run  p.FlashWord  p.GetCheck
      p.ReadWords
   then  drop ;

: re-peer
   open-pty  cr  ." Connect to "  zcount type  ."  to chat with this peer."
   pty-master !  begin  peer-command  again ;

| FUCK!! Is it a new Linux kernel? The re-peering process seems now to open
| another, different, pty each time! Really annoying.
|
| Ah! A race condition. Lovely. Let's wait 100ms before re-opening the pty
| master. That seems to work. Fucking Linux!!

: peer
   peer-push-frame
   begin  catch re-peer  pty-master @ close-file
                                         0 #100,000,000 nanosleep  again ;

( Let's run it!)
peer
