( This file is part of muforth: https://muforth.dev/
|
| Copyright 2002-2024 David Frech. (Read the LICENSE for details.)

loading Command-line history editing (test)

( Need tty support.)
.ifndef tty
   ld lib/tty.mu4
.then

comment ansi-sequences
|
| These sequences are generated by my (Linux) console:
| Up     ESC [   A
| Down   ESC [   B
| Right  ESC [   C
| Left   ESC [   D
| Home   ESC [ 1 ~
| Ins    ESC [ 2 ~
| Del    ESC [ 3 ~
| End    ESC [ 4 ~
| PgUp   ESC [ 5 ~
| PgDn   ESC [ 6 ~
|
| Backspace key could generate DEL rather than BS, so be prepared for this. ;-)
|
| When output, BS and cursor motions do _not_ go past screen edges; we need
| to do this ourselves. What ANSI sequences move the cursor quickly, eg to
| EOL?
|
| Cursor movement
| Insert  ESC [ <n> @        <n> is count of blanks to insert; def to 1
| Up      ESC [ <n> A        <n> is rows/colums to move; defaults to 1
| Down    ESC [ <n> B
| Right   ESC [ <n> C
| Left    ESC [ <n> D
|
| DownCR  ESC [ <n> E     like B, but also go to column 1
| UpCR    ESC [ <n> F     like A, but also go to column 1
|
| Go      ESC [       <col> G     defaults to col 1
| GoYX    ESC [ <row> <col> H     origin at (1,1); both default to 1
|
| Erase (ie, _replace with blanks_); cursor stays put
| erase-chars     ESC [ <n> X   <n> can be omitted; defaults to 1
| erase-to-eol    ESC [   K
| erase-from-bol  ESC [ 1 K
| erase-line      ESC [ 2 K
|
| erase-to-eos    ESC [   J     erase from cursor to end of screen
| erase-from-bos  ESC [ 1 J     erase start of screen to cursor
| erase-screen    ESC [ 2 J
|
| On Linux, console_codes(4) has all the details. It should be interesting to
| see where OSX and BSD console drivers diverge (to say nothing of xterms,
| etc). Should I be using (n)curses? Probably. ;-)
|
| ansi-sequences

: curs-bol         #CR emit ;
: curs-to-x        ." ["  radix preserve decimal  (u.) type  char G emit ;
: curs-ins         ." [@" ;
: curs-del         ." [P" ;
: curs-right       ." [C" ;
: curs-left        ." [D" ;
: curs-erase-eol   ." [K" ;

256 buffer cl  ( One line only! Generously making it 256 bytes for wide ttys!)

( Make space in cl for one char at idx, then store char there.)
: cl-ins  ( len idx ch - len+1 idx+1)
   push   2dup - ( count)  push  dup cl +  dup dup 1+ pop cmove
   pop swap c!  1 1 v+ ;

( Remove char at idx from cl.)
( NOTE: len > idx, otherwise: BOOM!)
: cl-del  ( len idx - len-1 idx)
   -1 u+  2dup - push ( count)  dup cl +  dup 1+ swap pop cmove ;

2 tty-width constant cl-width

create cl-root  here dup , ,  0 ,  ( prev/next point to cl-root, initially)

variable cl-cur   ( points to cl that we're editing)

( We're about to evaluate it; link cl into history)

: cl>history  ( len)
   here  dup  cl-root @ , ( prev=root.prev)  cl-root , ( next=root)
   cl-root !  ( root.prev=new)
   dup @ cell+ ! ( new.prev.next=new)
   cl swap _string  drop ;

: >cl  ( 'cl - len)  ( history>cl ?)
   [ 3 cells ] +  count  ( a len)  tuck  cl swap  cmove ;

: cl-show  ( len - len idx)
   curs-bol  curs-erase-eol  cl over type  dup ;

( XXX are len and idx unsigned?)
: cl-left?   ( len idx - len idx flag)  ( can we move left?)   dup 0 > ;
: cl-right?  ( len idx - len idx flag)  ( can we move right?)   2dup > ;

: cl-left   ( len idx - len idx-1)  curs-left  1- ;
: cl-right  ( len idx - len idx+1)  curs-right 1+ ;

: cl-key-left   ( len idx - len' idx')  cl-left?  if  cl-left   then ;
: cl-key-right  ( len idx - len' idx')  cl-right? if  cl-right  then ;

: cl-key-up  ( len idx - len' 0)
   2drop  cl-cur @        @ ( prev)  dup cl-cur !  >cl  cl-show ;

: cl-key-dn  ( len idx - len' 0)
   2drop  cl-cur @  cell+ @ ( next)  dup cl-cur !  >cl  cl-show ;

: cl-key-del  ( len idx - len' idx')  ( ^D)
   cl-right? if  curs-del  cl-del  then ;

: cl-key-bs   ( len idx - len' idx')  ( ^H or DEL)
   cl-left? if  cl-left  cl-key-del  then ;

: cl-key-ret  ( len idx - a len)  drop  dup cl>history  cl swap  ( evaluate) ;

: cl-key-add  ( len idx ch - len' idx')
   push  over cl-width 1- < if
      curs-ins  r@ emit  pop cl-ins  ^  then
   shunt ;

: read-esc-seq   key
   char [ = if  key
      dup char A = if  ( cursor up)     drop  cl-key-up     ^ then
      dup char B = if  ( cursor down)   drop  cl-key-dn     ^ then
      dup char C = if  ( cursor right)  drop  cl-key-right  ^ then
          char D = if  ( cursor left)         cl-key-left   ^ then
      then ;

: process-key   ( len idx - len' idx')  key
    dup #ESC =     if  drop  read-esc-seq  0 ^  then
    dup #BS  =
   over #DEL = or  if  drop  cl-key-bs   0 ^  then
    dup ctrl D =   if  drop  cl-key-del  0 ^  then
    dup #CR  =     if  drop  over  1+ curs-to-x space  -1 ^  then
    31 over  u<    if        cl-key-add  0 ^  then
   drop  ( default)  0 ;

: editline  ( - a len)
   cl-root cl-cur !
   0 0  begin  process-key  until  cl-key-ret ;

: interact   tty user-raw  editline  tty cooked ;
: ii  begin  interact  prompt  =while  cr type cr  repeat  2drop ;


( What I started with in 2010...)

1 Ki buffer tib

: march  ( a1 a2 inc)  dup v+ ;

: whiteout ( n)
   0 do  #BS emit  space  #BS emit  loop ;

: >bol  #CR emit ;  ( no LF)
: >idx  >bol  dup 0 do  i tib + c@ emit  loop ;
: >eol  ( len idx)  2dup do  i tib + c@ emit  loop  drop dup ;
: erase>eol  ( len idx)  2dup do  space  loop  nip dup ;

: >tib  ( len idx a u - u u)  ( put a string into tib; reset len & idx)
   push ( u)  tib r@ cmove  r@ >idx  ( - len idx u)
   - spaces  drop  ( if this line shorter, erase end of prev)
   pop dup ( - len idx) ;

: recall-prev  2drop  " (prev)" >tib ;
: recall-next  2drop  " (next)" >tib ;

: move-left   ( len idx)
   dup 0 > if  #BS emit  1-  then ;

: move-right  ( len idx)
   2dup >  if  tib over + c@ emit  1+  then ;

: read-esc-seq   key
   char [ = if  key
      dup char A = if  ( cursor up)     drop  recall-prev  ^ then
      dup char B = if  ( cursor down)   drop  recall-next  ^ then
      dup char C = if  ( cursor right)  drop  move-right  ^ then
          char D = if  ( cursor left)         move-left  ^ then
      then ;

: do-backspace   =if  2 whiteout  -1 march   then ;

: process-key   ( len idx - len' idx')  key
    dup #ESC =     if  drop  read-esc-seq  0 ^  then
    dup #BS  =
   over #DEL = or  if  drop  do-backspace  0 ^  then
    dup #CR  =     if  drop  space  -1 ^  then
   31 over u< if  dup emit  push  tib over +  pop swap c!  1 march  then
   ( default)  0 ;

: editline  ( a u)  0 0  begin  process-key  until   drop ( idx)  tib swap ;

: interact   tty user-raw   editline  tty cooked ;
: ii  begin  interact  prompt  =while  cr type cr  repeat ;

: show-key
   dup #ESC = if  drop  ." <ESC>"  ^  then
   dup #CR  = if  drop  ." <CR>"   ^  then
   dup #LF  = if  drop  ." <LF>"   ^  then
   dup #DEL = if  drop  ." <DEL>"  ^  then
   dup bl  u< if  char ^ emit  64 xor  then
   emit ;

: echo
   tty user-raw
   begin  key  dup show-key  ctrl C = until
   tty cooked ;

: verb
   tty user-raw
   begin  key  dup emit      ctrl C = until
   tty cooked ;

( terminal ESC sequences)
( CSI - see ECMA-48 - means "control sequencer introducer". Go figure. ;-)

: #d   radix preserve  decimal  #s ;
: <csi    ( ch)  <#  hold ;
: csi>    char [ hold  ctrl [ hold  #>  type ;

: csi    \f char  constant  does> @  <csi                       csi> ;
: csi1   \f char  constant  does> @  <csi  #d                   csi> ;
: csi2   \f char  constant  does> @  <csi  #d  char ; hold  #d  csi> ;

csi1 A move-up  ( n)
csi1 B move-down  ( n)
csi1 C move-right  ( n)
csi1 D move-left  ( n)

csi1 E move-down-cr  ( n)
csi1 F move-up-cr  ( n)

( XXX change these to use 0-based coordinates?)
csi1 G move-to-col      ( col)
csi2 H move-to-row-col  ( row col)
