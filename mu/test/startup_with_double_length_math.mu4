: definitions  current ! ;
: forth        .forth. definitions ;
: compiler  .compiler. definitions ;

: literal  (literal) (literal) compile,  compile, ;

: ]   literal -] ;
: char   token  drop  c@ ;

: (    [ char ) ]  parse  2drop ;

( Phew! now we can have comments!)

( $Id$
|
| This file is part of muforth.
|
| Copyright 2002-2024 David Frech. (Read the LICENSE for details.)
  reversed.

  Licensed under the Apache License, Version 2.0 [the "License"];
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  or see the file LICENSE in the top directory of this distribution.

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.)

( This file is muforth/startup.mu4. It contains high-level Forth code
| necessary to the useful execution of Forth. This file is loaded and
| interpreted when Forth starts up.
|
| The idea is to move as much code as possible -out- of the Forth kernel.
| Hence the name: "mu" is the Greek letter often used in engineering to
| represent "micro". I had called it "nu" Forth, because it was new, but I
| like this nu Greek letter better.)

( This file exemplifies a Forth strength - shared by Lisp and Smalltalk,
| among other interpretive/compiled languages - that I like to call
| "writing the reader"; the reader being, in this case, the Forth
| interpreter/compiler.
|
| As defined in the kernel, the interpreter/compiler is very simple; it
| only knows how to do the following things:
|
| 1. compile a call to an already-defined word [Forth for "named piece of
|    code"];
|
| 2. convert a compiled call into a jump, if it would be followed by a
|    "return" instruction [so-called "tail-call conversion"];
|
| 3. create a new word, making a dictionary entry for it;
|
| 4. compile code to push a constant onto the stack [an "inline literal"];
|
| 5. compile code to do a few stack manipulations, or stack tests [TOP ==
|    0, for instance], that are difficult or impossible to do in Forth, or
|    involve machine dependencies.
|
| That's it! The machine-dependent compiler code - in this first pass at
| the problem, for the x86 architecture - is around 300 lines of C code,
| but in principle very simple.
|
| In this file, in Forth, we need to extend the interpreter/compiler to do
| the following:
|
| 1. compile control structures: if/then, for/next, begin/while/repeat;
|
| 2. compile data structures: variables, constants, create/does words;
|
| 3. read and write numbers - an interesting exercise since muforth starts
|    life _not_ even knowing only the constant 1!
|
| 4. read and write strings.
|
| Once these are complete we will have a useful Forth for doing real work.
|
| The order of business will sometimes seem haphazard; words can only be
| defined after the words they depend on have been defined, so we end up
| jumping around a bit in the "semantics" of the language.
|
| Hopefully the reader will find this an interesting exercise in
| bootstrapping, which was precisely my intention.
|
| So, here goes; now we start extending the language, bit by bit.)


( !! NOTE !! Do -NOT- change this part of the file without thinking VERY
| hard first. Make changes below the line marked `Add changes below this
| line', otherwise it may be difficult to diagnose problems added by new
| code.)


( First, we need compiler versions of ( and char. Since we no longer hide
| words as they are being defined, we need to be careful about how we do
| this. So let's define some words that are useful for searching specific
| dictionary chains and compiling words from them.)

( Stack comment and word comment words. We redefine these to generate
| documentation.)
: (s  ( ;  ( stack comment)
: (w  ( ;  (w word comment)

( Roll tokenizing and searching into one.)
: token'   token  rot  find ;   (s chain - a u F | body T)

( Compiling from specific chains. Note that `\' is an elaboration of the
| basic scheme of `\chain'. These words will be handy in the assembler
| and target compiler.)

( Tick)
: chain'  token'  huh?  ;
: \chain  chain'  compile,  ;

( 28-apr-2000. Do we ever -really- want to search anything other than .forth.?)
: '   .forth.  chain'  ;
( : '   current @  chain'  ;  ( XXX)

compiler
( XXX: should this and ' do the same thing?)
( : [']  .forth. chain' literal ;)
: [']  ' literal ;

( XXX: is this useful? Here? Maybe in a target compiler...)
: \f     .forth. \chain ;
: \c  .compiler. \chain ;  ( until we have \ ; we need this for "if")

( Ok, now we can define our compiler comment char, ( .)
: (    \f ( ;
: (s   \f ( ;  (w stack comment)
: (w   \f ( ;  (w word comment)
forth


( Some useful tidbits.)
: -   negate + ;
: u+  (s a b c - a+c b)  rot +  swap ;  ( "under-plus")
: v+  (s x1 y1 x2 y2 - x1+x2 y1+y2)  push u+ pop + ;  ( add 2-vectors)

( We don't even have any constants yet! So we make the easiest one first...)
: 0   [ dup dup xor ] ;
: -1  [ 0 invert ] ;
: 1   [ -1 negate ] ;
: 2   [ 1 2* ] ;

: 1+   1 + ;  ( these are common)
: 1-  -1 + ;

: cell   [ 1 cells ] ;
: cell+  [ cell ] + ;
: cell-  [ cell negate ] + ;

: bl  [ 2 2* 2* 2* 2* ] ;  ( space character)

: tuck  (s a b - b a b)  swap over ;

: @+  (s a - n a+)  dup @  swap cell+ ;
: !+  (s n a - a+)  tuck !  cell+ ;

: 2@  @+ @  swap ;  ( cell at lower address to TOP)
: 2!  !+ ! ;

: 2dup  over over ;
: 2swap  rot push  rot pop ;
: 2push  (s a b -> R: a b)  pop -rot  swap push push  push ;
: 2pop   (s R: a b -> a b)  pop       pop pop swap    rot push ;

( Compatibility.)
: =  xor 0= ;
: bic  invert and ;
: lshift  << ;
: rshift  >> ;
: urshift  u>> ;

: @execute  @ execute ;

( XXX: can this be refactored to get rid of some of the swaps?)
( XXX: can this be got rid of entirely?)
: vector    (s n a)  swap cells +  @execute ;
: |vector|  (s n a mask)  rot and  swap  vector  ;

( Compiler nuts and bolts.)
: aligned  [ cell 1- ] +  [ cell negate ] and ;
: here   h @ ;  ( h points to the first free byte in code space)
: ram    r @ ;  ( r points to the first free byte in data space)
: allot  aligned  r +! ;  ( keeps ram space cell-aligned)
: ,      ram !  cell allot ;

( We'll define words to compile into code space once we have create/does.)


( Now `ctrl' and the compiler's "char" and "ctrl".)
: ctrl   char  [ bl 2* ( 64) ]  xor ;  ( how you get ^? = 127.)
compiler
: char   \f char literal ;
: ctrl   \f ctrl literal ;
forth

( A nice way to do full-line comments with no trailing delimiter.)
: //  ctrl J parse  2drop ;  ( throw away until a newline)

( the old definition)
// : ctrl   char  [ bl 1- ( 31) ]  and ;  ( elliptical, but it works :-)


( Basic conditionals)
: <resolve  (s dest src)  ! ;
: resolve>  (s src dest)  swap <resolve ;
: mark>  (s - src)  here  0 compile, ;

compiler
: =if   (s - src)  ['] (=0branch) compile,  mark> ;
: if    (s - src)  [']  (0branch) compile,  mark> ;
: then  (s src)  here resolve> ;

( make \ more like ANS-Forth's POSTPONE)
( in our case, what do we compile?
| movl $xt, %eax; call push_literal; call compile,
| Now, the confusion happens because we need to write code _in this word_
| that will compile the above code into _other_ words. How about that?)

( Read a token out of the input stream. If the token is on the compiler
| chain, postpone its execution until the word we're compiling executes. If
| the token is on the forth chain, postpone its compilation until the word
| that we're compiling executes. Got that? ;-)

: \   .compiler. token'  if compile, ^ then
         .forth. find  huh?  literal  ['] compile,  compile, ;

// : else      (s src0 - src1)  \ (branch) mark>  swap  \ then ;

: begin   (s - dest)  here ;
: =until  (s dest -)       \ =if  <resolve ;
: until   (s dest -)        \ if  <resolve ;
: again   (s dest -)  \ (branch) mark> <resolve ;
: =while  (s dest - src dest)  \ =if  swap ;
: while   (s dest - src dest)   \ if  swap ;
: repeat  (s src dest -)   \ again  \ then ;

( n for .. next         goes n times; 4 billion+ if n=0 )
( n ?for .. next then   goes n times; 0 if n=0 )

: for     (s - dest)      \ push  \ begin ;
: ?for    (s - src dest)  \ (?for) mark>  \ begin ;
: next    (s dest -)      \ (next) mark> <resolve ;

forth

( To bracket comments in a flexible way. If you've bracketed some text
| using comment, changing "comment" to "uncomment" will interpret the
| bracketed text - the delimiter becomes a noop.)

: comment  token  begin  2dup token  string-compare 0=  until  2drop ;
: uncomment  new \ ^ ;  ( create a noop word)


( Defining words are next. Right now we only `know' how to make `colon'
| definitions. We need some structural help first.)

( Some notes on the newer, smarter ] . I wanted to gain a
| little of the clarity that Chuck Moore's colorForth gains by getting rid
| of "[ <calculate something here> ] literal". He replaces the whole
| construct with colored words that are executed or compiled depending on
| their color, but with a little added twist: words that are executed [of
| "execute" color] create what I call a "pending literal" that will be
| compiled just _before_ the next word that is compiled [of "compile"
| color].
|
| Even if we don't have color, we do still have [ and ] and can use them to
| achieve the same end. [ creates a pending literal and ] compiles it.
|
| How does it work? Simple. ] _always_ compiles a literal before restarting
| the colon compiler. To restart it _without_ compiling a literal, use -] .)


( 2002-mar-18. New and modern create/does. Everything changes dramatically
| with native compilation. Let's look at what we have.
|
| First of all, "does>" changes from compiling an _address_ to compiling a
| _constant_ - which could, of course, be an address. does> splits the code
| to push a constant into two parts: a load part and a push part. The load
| part is the code:
|
|   movl $constant,%edx
|
| The push part is the call [or jump!] to push-literal. This is the same
| code that "literal" generates; we're splitting it into two parts to save
| code space.
|
| Here's how it works. Let's say we're writing an assembler and need words
| for addressing modes. Like many create/does> words, these consist of a
| _constant_ and some code. The old way to do this would go something like:
|
|   : md  create ,  does> @  a b c ;
|
| This is a clumsy way to work with constants - compiling them into the
| word only to fetch them out again - and is inefficient when compiled to
| native code. My modernized way looks like this:
|
|   : md  create  does>  a b c ;
|   octal 004 md deferred
|
| does> by default creates a constant, which gets pushed when the child
| word - "deferred" in this example - is executed. The actual code that is
| compiled looks like this:
|
| md: call create         ; define-time
|     call ;does          ; define-time
| md_does:
|     call push_literal   ; run-time
|     call a              ; run-time
|     call b              ; run-time
|     jmp  c              ; run-time
|
| deferred:
|     movl $004, %edx
|     jmp md_does
|
| Wait a minute! How did that ";does" thing get in there? Well, does> is
| actually a _compiler_ word. It compiles "call ;does" followed by "call
| push_literal" into the word being defined - "md" in this case.
|
| When md is called - to create a child word, or, equivalently [for OO
| types] an _instance_ - md create's the new word and then ;does compiles
| the load constant and the jump to md's run-time code.
|
| If we hadn't split the push-constant part, the code in each child word -
| and there could be lots of them! - would have to have an extra call:
|
| md: call create         ; define-time
|     call ;does          ; define-time
| md_does:
|     call a              ; run-time
|     call b              ; run-time
|     jmp  c              ; run-time
|
| deferred:
|     movl $'006, %edx
|     call push_literal
|     jmp md_does
|
| What we have essentially done is move the "call push_literal", since it
| is common to every child word, out of the child and into the parent.
|
| With that long-winded intro, we can now get into some of the odd
| subtleties of this brave new world.
|
| The first subtlety is that while does> and constant - as defined below -
| both create some type of constant, they do it slightly differently.
| constant creates a word and writes code to push a constant - both the
| load and push halves of that action - and then forces a _tail-call
| conversion_ of the call to push_literal, changing it to a _jump_ and
| thereby ending the word. It can do nothing more than push its constant.
|
| This ends up being syntactic sugar;
|
|   4 constant cell
|
| and
|
|   : cell  4 ;
|
| produce exactly the same code; namely:
|
| cell:
|   movl $4,%edx
|   jmp  push_literal
|
| does> is different; it leaves open - in fact encourages! - doing
| something exciting with the constant that has just been pushed. [Remember
| that this constant could be the address of some data structure.] It
| splits the constant-pushing task into two parts, as described above,
| putting the load into the child and the push into the parent, but leaves
| the call to push_literal as a _call_ that is expected to be followed, as
| in "md" above, with code that processes the constant.
|
| To drive home this subtle difference, assume that we defined constant
| thus:
|
|   : constant  create does> ;
|   4 constant cell
|
| Now what do we have?
|
| constant:
|   call create
|   call ;does
| constant_does:
|   jmp  push_literal
|
| cell:
|   movl $4,%edx
|   jmp  constant_does
|
| This is slightly less efficient; it compiles extra code into the parent
| word - the run-time code "jmp push_literal" - and to execute this
| constant we do a jump to a jump, which is both silly and slow.
|
| Note: the trailing ; in our example definition of "constant" above
| changed the "call push_literal" to "jmp push_literal". Sneaky!
|
| The other important subtlety is that these constants - esp. when they are
| the address of some data structure - can be in the way when compiling
| said data structure. The constant that you want compiled into the child
| word has to be on the stack when does> [really ;does] executes. It's a
| bit clumsy, but you have to do something like this:
|
|   : clumsy  create  ram  push  , ,  pop  does>  a b c ;
|   thing1 thing2 clumsy example
|
| I suppose you could write that like this too, with consequent changes in
| how the data is "fetched" and used in a, b, and c:
|
|   : less-clumsy  create  literal  does>  a' b' c' ;
|   thing1 thing2 less-clumsy example
|
| In this case we compile _two_ literals, the second one being "split in
| two" in the canonical way:
|
| less_clumsy:
|   call create
|   call literal    ; compiles code to load & push a literal
|   call ;does
| less_clumsy_does:
|   call push_literal
|   call aprime
|   call bprime
|   jmp  cprime
|
| example:
|   movl $thing2,%edx
|   call push_literal
|   movl $thing1,%edx
|   jmp  less_clumsy_does
|
| With this new kind of create/does>, you choose how to do it.)


( "nameless" colon words.)
: -:   here <:> -] ;

( For comparison, the regular : compiler is defined thus:
| : :  new <:> -] ; )

: -create  here <does> ;  ( nameless do_does word)
: create   new <does> ;  ( nameful do_does word)
: does>  (s constant)
    pop  compile, ( compile IP of parent does)
    compile, ;  ( compile constant)

comment XXXalternative with do_does words laid out like this:
|    do_does
|    <constant>
|    <new IP>
|
| : create (s constant)  new <does>  compile, ( constant) ;
| : does>  pop compile, ( parent IP) ;
| XXXalternative

: constant  create  does> ;
: _buffer  (s bytes - ram)  ram swap  aligned  cell/  ?for 0 , next then ;
: buffer  _buffer constant ;  ( XXX: untested)

: _var  create  ram  does> ;
: variable   _var  0 , ;
: 2variable  _var  0 , 0 , ;

( : array   (s n - ) _var ;  ( XXX: Fixme: I like arrays to be self-indexing.)

( These depended on the data space being zeroed, which makes me nervous.
| And well I should have been nervous: temporary strings - for file names,
| among other things - are allocated there. And this just bit me. I was
| assuming that variables would be zero when allocated; instead I got a
| bunch of junk. As I was generating a linked-list head pointer - actually
| a dictionary chain - what was supposed to be a null pointer at the end
| was instead an invalid pointer off into the weeds!
|
| : buffer  ram constant  allot ;
| : variable       cell buffer ;
| : 2variable   2 cells buffer ; )

( 2002-mar-30. Experimenting with an alternative here.)

( If any code is _compiled_ between create and does>, bad things will
| happen. The reason for this experimental way is to get the constant out
| of the way; but by splitting the compilation of the load constant and
| jump to the does code into two a potentially dangerous situation arises.
|
| Maybe ;does should look back and "steer" the last-compiled call to point
| to the code that follows it; this way a complete load-and-call-push could
| be compiled, then partly un-compiled when the does comes along.
|
| But does> has compiled a push-literal [call push_literal] into the parent
| word at the start of its shared does code; this needs to immediately
| follow a register load in the child word. Which means, once again, that
| no code can intervene between the two. In fact, as I have envisioned
| them, does words _only_ consist of a load constant and jump to the
| parent's code; though I guess if this is the _last_ thing in the child
| word that it's ok. That means compiling everything in does> and ;does as
| I am now, instead of doing anything in create. Hmm.
|
| In fact, as it works now does> does all the work; create is simply a
| synonym for "name".
|
| In any case, this allow us to write
|
|   ram create  cells allot  does>
|
| instead of
|
|   create  ram swap  cells allot  does>
|
| Maybe it's not such a big deal, but the first seems a lot cleaner.
|
| Urr. It's still a problem. I going to bed; I'll think about this
| tomorrow.)

comment XXXperimental
| ( -create is basically the same as "here".)
| : create   new  load-literal ;  ( loads a constant)
| : constant  create  push-literal  \ ^ ;  ( syntactic sugar for : foo  89 ; )
| : 'buffer  ram constant ;
| : buffer   'buffer allot ;
|
| : variable    'buffer  0 , ;
| : 2variable   'buffer  0 , 0 , ;
|
| ( These depended on the data space being zeroed, which makes me nervous:
|   : variable       cell buffer ;
|   : 2variable   2 cells buffer ; )
|
| : ;does   -compile  pop compile, \ ^ ;
| compiler
| : does>   ['] ;does compile,  push-literal ;
| forth
| XXXperimental

( We need words to help us navigate the dictionary structure. find returns
| a pointer to the code field. We need to be able to convert this to point
| to other parts of the structure.)

: >link  cell- ;
: link>  cell+ ;
: >body  cell+ ;
: >name  (s code - a n)
   >link  dup  1- c@ dup push ( length)  1+ aligned -  pop ;

( What about the last word defined? "current @ @" will yield a pointer to a
| link field.)

: last  current @ @ ;

( I guess we can have deferred words, even though they are, in some ways,
| inelegant. The alternative - creating a variable and a colon word that
| calls through that variable, for _every_ deferred word - is also in some
| ways inelegant - and clumsy.
|
| Actually, the way we define this is exactly equivalent to what we would
| have to do with variables; the difference is that instead of two named
| objects - the variable and the colon word that calls thru it - we have
| one - the deferred word - and we need an extra mechanism to get to its
| value to change it.
|
| The main argument _against_ deferred words is that they aren't orthogonal
| w.r.t. _user_ variables. The way we are defining them here they are
| implemented using a global, system variable. On muforth, we don't care,
| because we don't _have_ user variables; but on a properly multithreaded
| target machine things are different. There we probably wouldn't implement
| deferred words at all, using instead the "<variable> @execute" idiom; or,
| indeed, we could have all deferred use _user_ variables instead of
| globals. But that's what the fuss is.
|
| That and that "vectoring" them isn't strictly postfix. And it requires
| architecture-specific code!)

variable undeferred  ' nope undeferred !
: defer  create  ram  undeferred @ ,  does> @execute ;
: >data  >body cell+ @ ;  ( given code addr of does word, fetch its constant)
: 'data  ' >data ;

( test!!)
undeferred @  0 undeferred !  undeferred @ drop  undeferred ! zzz

( Syntactic sugar - from Rod Crawford's 4ARM.)
: now   '  ;
: is    'data !  ;   ( as in `now host-interpret is interpret')

compiler
: ['data]  'data literal ;
: now  \f now  literal ;
: is   \ ['data]  \ ! ;
forth


( Number input)
variable dpl    ( location of , or . )
variable radix

: radixer  create  does>  radix ! ;

2 2* 2* dup 2* ( 16!)  radixer hex
dup            (  8!)  radixer octal
2 +            ( 10!)  radixer decimal
2                      radixer binary

decimal
( On and off)
: on  -1 swap !  ;
: off  0 swap !  ;

( Punctuation in numbers: sign, radix, decimal point, separators.)
: punct  (s a u ch - a' u' matched)
   over if ( still chars to process)  swap push  over c@  xor if
   ( no match)  pop 0 ^ then
   ( match)  pop 1 -1 v+  -1 ^  then
   ( end of input)  drop  pop drop  ( -1 throw) ;  ( XXX use throw!)

: ?sign  char - punct  if  -1 ^  then  0 ;

: ?hex  char " punct  if  hex ^  then
        char # punct  if  decimal ^  then
        char ' punct  if  octal ^  then
        char % punct  if  binary ^  then ;

( . resets dpl; others leave it unchanged; this means that embedding . in a
| number causes a double number to be pushed, and dpl set to the count of
| digits _after_ the _last_ . in the number.)
: ?dot  char . punct  if  dpl off ^  then
        char , punct  if   ^  then
        char - punct  if   ^  then
        char / punct  if   ^  then
        char : punct  if   ^  then
        char _ punct  if   ^  then   complain ;

: ?c-hex    char x  punct  if  hex ^  then
            char X  punct  if  hex ^  then   octal ;

: ?c-octal  char 0  punct  if  ?c-hex ^  then   ?hex ;

( 4-apr-2000. Added `C' style radices.)
( 29-apr-2000. Changeable forth-style and c-style radices. Having the C
| stuff always working is confusing because `hex 08' tries to convert the
| number in octal and fails.)

defer ?radix
: c-radices   now ?c-octal  is ?radix ;
: forth-radices   now ?hex  is ?radix ;   forth-radices

( This is scary.  We need a bunch of literals for `digit?'.)

: digit?    (s ch - digit T | junk F)
   char 0 -  [ 2 2* 2* 1+ ]  ( 9)   over u< if  ( !decimal)
          [ 2 2* 2* 2* 1+ ]  ( 17)  -
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, UPPERCASE)
          [ 2 2* 2* 2* 2* ]  ( 32)  -
     [ 2 1+  2* 2* 2*  1+ ]  ( 25)  over u< if  ( !hex, lowercase)
      ( junk)  0 ^
   then  then  ( hex) [ 2 2* 1+ 2* ]  ( 10) +  then  ( decimal)
   dup radix @  u<  ;

: @digit?   (s a - a digit T | a junk F)   dup c@  digit?  ;

: *digit  (s ud a digit - ud*base+digit a)
   swap push ( a)  swap ( lo dig hi)  radix @ um* drop  rot ( dig hi*radix lo)
   radix @ um*  d+  pop  dpl @ 0< 1+  dpl +!  ;

( 2002-mar-23. I still don't like how number parsing works. It seems
| clumsy. On the one hand, we know ahead of time exactly how many
| characters we have [in the token we are trying to convert]; on the other,
| the way the prefix [sign and radix] and embedded [. , - : /] characters
| work, we can't simply put them in a loop: there should be at most one sign
| and one radix at the beginning. Right now I have >number [which converts
| digits] and punct words _both_ checking if there are any characters left
| to process. This seems clumsy.
|
| And that "dpl!" in ?dot bugs me, too.)

( ANS compatible!)
: >number  (s ud1 a1 c1 - ud2 a2 c2)  ( a2 is first unconvertible char)
   =if  for  @digit?  while  *digit 1+ next  0 ^  then
                                drop  pop  then  ;

: fancy-number  (s a u - d)  ( was -: )
   2push  0 0  2pop  ?radix  ?sign push  dpl on
   begin  >number  =while ( still chars)  ?dot  repeat
   2drop  pop  if dnegate then  ;

( Now some help for the colon compiler. Note that the colon compiler now
| calls `number,' to convert-and-compile and calls `number' when interpreting.
| This is so that `number,' or `number' can reset dpl when they're done. We do
| this so that constants don't screw up fixed-point arithmetic conversion.
| Without this code, if you were to use a fixed-point number, 3.1415 eg, dpl
| would be set to 4. Then `0' pushes 0 on the stack but doesn't affect dpl,
| so Forth tries to convert it, and BOOM.)

: (number)  (s a u - d)
   radix @ push   ['] fancy-number  catch   pop radix !  throw  ;
( always reset the radix, even in case of error)

-: (number)  dpl @  0< if  drop literal ^  then  swap  literal literal ;
'number, !

-: (number)  dpl @  0< if  drop  then  ;
'number !

( Make it easy to call "number" and "number," from interpreter mode words.)
: number   'number  @execute ;
: number,  'number, @execute ;


( Basic character i/o.)

1024 constant #inbuf
#inbuf buffer inbuf  ( terminal input)
variable keybuf
variable emitbuf

variable fd-in
variable fd-out
: writes  fd-out ! ;
: reads   fd-in  ! ;
: <stdin   0 reads  ;
: >stdout  1 writes ;  <stdin  >stdout  ( sanity)
: >stderr  2 writes ;

: <key   (s fd - ch)                  keybuf 1 read  drop  keybuf c@ ;
: >emit  (s ch fd)  swap emitbuf c!  emitbuf 1 write ;

: key   (s - ch)   fd-in @  <key ;
: emit  (s ch)    fd-out @  >emit ;

: space  bl emit ;
: cr     ctrl J emit ;

: type                   fd-out @  -rot  write ;
: accept  (s a # - #in)   fd-in @  -rot  read ( 1-)  ;  ( ANS)
  ( chop trailing newline)

: typing  (s - a #)  inbuf dup [ #inbuf 2 - ] accept  ;  ( get a line of input)


( WARNING:  this is different from what the CPU would do;
| it ignores OVERFLOW, unlike the CPU's signed comparisons.  <' is useful
| for `modulo' less than -- it compare two numbers in the same half of the
| number space.  Useful for 32-bit clock operations [with monotonically
| increasing time] and for TCP sequence numbers.)

: <'      - 0<  ;  ( This violates what is -required- by FORTH-83 standard)
: >     swap <  ;
: min   2dup >  if swap then  drop  ;
: max   2dup <  if swap then  drop  ;
: not   0=  ;


( Pictured numeric output.)
: /digit   (s ud - udquot urem)
   0 radix @ um/mod  ( 0:hi / radix -> urhi uqhi)  push
   ( urhi:lo)  radix @ um/mod  ( urlo uqlo)  pop rot  ;

: >digit   (s n - ch)  ( convert 1 binary digit to char; hex to uppercase)
   9 over u<  7 and +  char 0 +  ;

: s->d  (s n - d)  dup 0<  ;  ( only works if true flag is all 1s!)

: abs   (s n - |n|)   s->d  if  negate then ;
: dabs  (s d - |d|)   s->d  if dnegate then ;

: spaces  (s n)  0 max  ?for  space  next  then  ;

( pad is where we convert numbers to ASCII. A double number is 2 cells -
| 64 bits - and in binary would take 64 characters to represent, plus a
| character for the sign. pad returns the address of the _end_ of the
| buffer, since conversion occurs right-to-left.)

: pad  [ 65 allot ram ] ;  ( 64 digits + sign + alignment)

variable hld
: hold   -1 hld +!  hld @ c! ;
: <#     pad hld !  ;
: #>     (s ud - a #)  2drop  hld @  pad over - ;
: sign   (s n -)   0< if  char - hold  then  ;

: #     (s ud - ud')   /digit  >digit  hold  ;
: #s    (s ud - 0 0)  begin  #  2dup or 0=  until  ;

: (ud.)   (s ud - a #)  <# #s #>  ;
: ud.     (s ud -)      (ud.)  type  space  ;

: (u.)    (s u - a #)   0  (ud.)  ;
: u.      (s u -)       (u.)  type  space  ;

: (d.)    (s d - a #)
          dup push ( sign)  dabs  <# #s  pop sign  #>  ;
: d.      (s d -)       (d.)  type  space  ;

: (.)     (s n - a #)   s->d  (d.)  ;
: .       (s n -)       (.)  type  space  ;

( This should truncate to field length. Actually, it shouldn't. Does it?)
: truncating-field   (s a c field - a' field)   tuck swap -  ( a field field-c)
   dup 0< if  drop ^  then  ?for  bl hold  next then  #>  ;

( Non-truncating field.)
: field   (s a c field - a c)  over - spaces  ;

:  (.r)   (s n field - a #)   push  (.)   pop  field  ;
:   .r    (.r)  type  ;

: (u.r)   (s u field - a #)   push  (u.)  pop  field  ;
:  u.r    (u.r)  type  ;

( Useful.)
: ?  @ .  ;

( XXX: wordlength-specific.)
: rotate  ( rotates _right_; without =if/then, rotates by 0 break on x86.)
  =if  2dup u>> push  negate bl ( 32) +  <<  pop xor ^ then drop ;


( : p  ctrl J parse  2dup  u. u. char | emit type char | emit ; XXX )


( String primitives.)

( 2003-dec-31!! Compiled strings have a cell-sized count and are referenced
| by pointing to the first character rather than to the count.
|
| I have also got rid of c" and now z" is the only string operator that
| returns a counted string. The z reminds us that it is also a
| null-terminated string.
|
| 2002-mar-18. All strings are compiled into data space and referenced by
| creating a normal literal with the string's address. Strings can then be
| used in an error or abort routine, or whatever. This is nice and postfix.
|
| It also means that if we want to, for example, return the address of
| the first character of the string - rather than of the count cell;
| eg, for strings used by the C library - we can calculate that
| address _before_ making a literal.  Again, this works because the
| string isn't compiled inline, so we don't need to jump over it.
|
| Things are _much_ simpler this way!)

( all compiled strings have a zero terminator.)
: copy-string   scrabble (s z") ;
: allot-string   cell- @  cell+ 1+  allot ;
: make-string   copy-string  dup  allot-string ;
: string,   (s ch - z")  parse   make-string ;
: token,       (s - z")  token   make-string ;
: count  (s z" - a u)  dup  cell- @ ;
: (.")  count type ;  ( no more jumping over strings at run-time!)

comment XXX
| : (warn")   (s f z")  swap  if
|    last-link cell+ @ ( link) cell+ count type ( name)  ." : "
|    count type ( warning)  ^ then  drop  ;
| : (error")  ; XXX

( Compiled strings.)
compiler
: z"   (s - z")   char " string,  literal ;  ( z means zero-terminated)
:  "   (s - a c)  \ z"  \ count ;
: ."             \ z"  \ (.") ;
: error"         \ z"  \ throw ;  ( compile a C-style string for throw'ing)
comment XXX
| : warn"          \ z"  \ (warn")   ; XXX

( Interpreted strings. Strings that return an address always get compiled!)
forth
: z"  (s - z")   char "  string, ;
:  "  (s - a c)  \f z" count  ;  ( ANS)
: ."    char " parse ( a #)  type  ;  ( not compiled)

( Words that do something with each word being defined.)
: being-defined  create  does> 'new-hook ! ;

( To warn of re-defining a word.)
-: ( a u)  2dup current @ find if  fd-out @ push >stderr
     drop  2dup type ."  again.  "  pop writes ^  then  2drop ;
being-defined -redef
-redef

( A useful list of words as they're being defined.)
-: ( a u)   current @ ( chain) . here .  2dup type  cr ;
being-defined -v  ( be verbose)

( You can only do one of these at a time! Is there an easy way to hook
| the hook?)


( Now that we have strings, let's make a more useful definition of
| undeferred, so that defer'ed words that never get set to anything will
| complain when used.)

-:  error" undefined deferred word" ;  undeferred !


( Ok. Tiny asm!)
comment do-this-but-later!
|
| ( These compile 1-4 bytes of machine code.)
| : asm,  create  does>  swap  here !  h +! ;
|    1 asm, 1,
|    2 asm, 2,
|    3 asm, 3,
|    4 asm, 4,
|
| variable offset  ( for effective memory addresses)
| variable sib     ( sib byte )
| variable immed
| variable variant
|
| octal
| ( regs)
| : a  300 ;  : sp  304 ;
| : b  303 ;  : bp  305 ;
| : c  301 ;  : si  306 ;
| : d  302 ;  : di  307 ;
|
| : 00r    7 and ;
| : m00  300 and ;
| : >0r0  00r  3 << ;
|
| ( These abbrevs are used in the following stack comments:
|   o = offset, b = base reg, i = index reg, s = scale, m = mod_rm, r = reg)
|
| : osize  (s o - m)
|    dup offset !  =if  200 + 400 u< if  100 ^ then  200 ^ then ;
|
| : bpfix  dup 005 xor if ^ then  100 xor ;  ( 005 -> 105)
| : md    (s o b     - m)  00r  swap osize xor ;
| : >sib  (s o b i s - m)  6 <<  swap >0r0 xor  over 00r xor  sib !  md ;
| : +sib  (s m - m')  m00  004 xor ;
|
| ( converts 004/xx5 -> 104/xx5; these are mod_rm/sib pairs)
| : ri)  (s o b i s - m)                >sib  bpfix  +sib ;
| : i)   (s o   i s - m)  bp -rot ( b)  >sib         +sib ;
| : r)   (s o b     - m)  dup sp xor if  md bpfix ^  then  sp 0 ri) ;
|
| : )   offset !  005 ;
| : $  (s imm)  immed !  cell variant ! ;
| : d-bit  (s r m | m r - m r d-bit)  dup m00 300 xor if  swap 0 ^  then  2 ;
|
| : md->osize
|    307 and  dup 005 xor if  dup 004 xor if  ^  then
|    sib @ 00r 5 xor if  ^  then  then  drop 200 ;
|
| : o8,   offset @ 1, ;
| : o32,  offset @ 4, ;
| : offset,
|    md->osize  6 >> jump  nope o8, o32, nope [
|
| : sib,  00r 004 xor if ^ then  sib @ 1, ;
| : ea,  (s m0r 0r0)  >0r0 xor dup 1,  dup sib, offset, ;
| : mov  d-bit  [ hex 89 octal ] xor 1,  ea, ;
| : addi    [ hex 83 ] 1,  0 ea,  1, ;
| compiler
| : time  [ hex 310f ] 2,  sp ) c mov  [ 8 negate ] sp ) addi
|    a [ 4 negate ] c r) mov     d [ 8 negate ] c r) mov ;
| forth
|
| ( a fun test)
| decimal
| : t time ;  ( contents of TSC: time since boot in processor clock ticks)
| ( : clockspeed  750000000 ;  ( on starbuck, a 750 M Athlon)
| : clockspeed  597070000 ;  ( on stubb, a 600 M Celeron/P3)
| : uptime  (s - s)  t clockspeed um/mod nip ;
|
| ( PCI bus scan!)
| : getsp  (s r)  sp ) swap mov ;
| : sp+    (s o)  sp ) addi ;
| : ret  "c3 1, ;
| create out  c getsp  0 c r) d mov  4 c r) a mov  "ef 1, 8 sp+  ret
| create in   c getsp  0 c r) d mov  "ed 1,  a 0 c r) mov  ret
| : north  "cf8 out  "cfc in ; ( FreeBSD won't let me!)
|
| hex
| ( here . ." start of assembler tests"  cr)
|
| a c mov
| 0 bp r) d mov
| 0 sp r) d mov
| si 4 negate sp r) mov
| c 0 c 2 i) mov
| c 0 bp c 2 ri) mov
|
| decimal
| : big  -1 -1 um*  1000000 for  2dup (ud.) 2drop next  2drop ;
| do-this-but-later!

comment asmXXX
| : ,s  for  1,  next ;
| : @sp     >0r0  [ octal -] 005 + 1,  sp 4, ;
| compiler ( should I join Chuck in calling this "macro"?)
| : sp->r  [ hex -] 8b 1,    @sp ;
| : +sp    [ hex -] 83 1,  0 @sp  1, ;
| : r->r/m  [ hex -] 89 1, ;
| forth
| asmXXX


( !!!!-------------------- Add changes below this line -------------------!!!!)

( Word listing. Putting this in as soon as possible. Needs `space'.)
: words   0  current @  ( count link)
  begin  @  =while  1 u+
            dup link> >name type space space  repeat
  drop  ." ("  . ." words)" ;


( XXX: should be primitive?)
: fill        (s a u n)  -rot  ?for  2dup c!    1+  next  then  2drop ;
: cell-fill   (s a u n)  -rot  ?for  2dup  ! cell+  next  then  2drop ;

: erase  (s a u)   0 fill  ;   ( easy, what?)
: blank  (s a u)  bl fill  ;


( Go forth and multiply ... and divide.
|
| These routines are all based on a handful of low-level primitives:
|    um* : u1 u2 - ud
|     m* : n1 n1 -  d
| um/mod : ud  u - urem uquot
| fm/mod :  d  n - mod quot  [floored division]
|
| Any word whose name starts with 'u' is unsigned, both in its arguments
| and its results; the others are signed.
|
| All of the */ variants calculate a double-length intermediate product.)

( To calculate a single-length signed product, calculate a double-length
| _unsigned_ product and drop the high-order word. Weird but true. And an
| extra-credit challenge: is "m* drop" always equal to "um* drop"? Why or
| why not? ;-)

: *       (s n1 n2 - n1*n2)   um*  drop  ;  ( what's in fig)

:  */mod  (s n1 n2 n3 - r q)  push   m*   pop           fm/mod ;
: u*/mod  (s u1 u2 u3 - r q)  push  um*   pop           um/mod ;

:  /mod   (s n1    n2 - r q)  push  s->d  pop ( d1 n2)  fm/mod ;
: u/mod   (s u1    u2 - r q)          0 swap ( ud1 u2)  um/mod ;

:  */     (s n1 n2 n3 - n1*n2/n3)   */mod  nip ;
: u*/     (s u1 u2 u3 - u1*u2/u3)  u*/mod  nip ;

:  /      (s n1 n2 - quot)    /mod  nip ;
: u/      (s u1 u2 - uquot)  u/mod  nip ;

:  mod    (s n1 n2 - mod)     /mod  drop ;
: umod    (s u1 u2 - umod)   u/mod  drop ;


( Within.)
: within  (s n lo hi - lo <= n < hi)  over - push  - pop u<  ;


( Character classifications - useful for ASCII dumps and keyboard input.)
: letter?         32 127 within  ;  ( excludes ctrls & DEL)
: graphic?  dup  160 256 within  if  drop -1 ^  then  letter? ;


( Useful stack dump.)
( These don't work! For subtle reasons...)
( : sp!  s0 sp ! ;   ( reset to an empty stack)
( : sp@     sp @ ;   ( get current stack position)
( : depth  s0 sp@ - cell/ 1- ; )

: .s  ( stack)
   depth  s0 cell- swap  ?for  cell- dup @ .  next then  drop  ;


comment %%
| ( Even more useful backtrace of return stack.)
| : rdepth  r0  rp@ -  cell/  1-  ;  ( remember: there's a return addr on R!)
|
| : where  ( ip - offset z" ip)  push  forth  0
|    begin  drop  @  =while  r@ over link> -
|    ( offset)  dup 0< 0= until  ( 'link offset) swap cell+  pop  ^
|    then  ( 'link = 0)  z" ????"  pop  ;
|
| : .where  ( offset z" ip)  hex  .a16  decimal
|    count type  ?dup if  cell/  ."  + "  u.  then  ;
|
| : backtrace  ( a n)
|    radix @ push
|    for  dup @  where  cr .where  cell+  next  drop  cr
|    pop radix !  ;
|
| ( The `push .s pop' removes the abort string from the stack dump.)
| : stacks  rp@ rdepth backtrace  ." Stack: "  push .s pop  cr  ;
| ( now stacks  is aborting)
|
| ( I was going to put `backtrace' into `better-error' but then realized that
|   `better-error' is called as the result of a `throw', so much of the return
|   stack info has been lost. Instead I put a hook into abort".)
| %%


( Conditional compilation)

( 30-aug-1998. Created.)
( 28-apr-1999. Added compiler word to create conditionals.)
( 27-apr-2000. Changed names to more standard [if] [else] [then] and added
|              the capability of nesting them.)
( 4-aug-2000. Added [with] and moved all conditional constants into
|         `conditional' vocab.)

( Compiler/interpreter modes.)
: mode   create  (s prompt interpret)  ram push , ,   pop  does>  state ! ;

( Defining new dictionary chains. These used to be in an array but are now
| independent of each other; now they are simply variables that point to the
| last-defined word on the chain.)
: chain  variable ;

chain .conditional.
: conditional   .conditional. definitions ;

-:  ."  (inside a conditional)"  ;
-:  .conditional. find  if  execute ^  then  2drop ;
mode eat

variable cond-nest
variable cond-save-state
: cond[   state @  cond-save-state !  cond-nest off  ;
: ]cond   cond-save-state @  state !  ;

compiler
: [else]   cond[  eat  ;
: [if]   (s f)  0= if  \ [else]  then  ;
: [then]  ;
: [with]   .forth. token' if  drop -1 ^  then  2drop 0 ;

conditional
: [if]     1 cond-nest +!  ;
: [else]                   cond-nest @  0=  if  ]cond  then  ;
: [then]  -1 cond-nest +!  cond-nest @  0<  if  ]cond  then  ;

forth
: [if]      \ [if]  ;
: [else]    \ [else]  ;
: [then]   ;
: [with]    \ [with]  ;

( A defining word that makes words that return -1)
: trues  create  -1 does> ;

( The defining word `with' for creating conditional compilation words.
| No matter what chain we are compiling into, define the word - using
| "trues" - in .forth.)

: with   current @  forth  trues  definitions  ;

( Now, the main reason for doing this is to have `debug' and `eprom'
| versions. The best way is to load the file `debug' or `eprom'!)


( A useful list of words as they're being defined.)
 0 [if]
( If we've got this far we can see what words are being defined)
-:  ( a u - a u)
   2dup current @
   find  if  >name type  ."  again.  "  ^  then  2drop  ;  drop

-:  ( z" #chain)  fd-out @ push
   >stderr  cr over count type  2 spaces  .s  pop writes  ;  is unique-hook
[then]

( Just for fun)
: 3*  dup 2* + ;     ( 3x = x + 2x)
: 5*  dup 2* 2* + ;  ( 5x = x + 4x)
: 10*  5* 2* ;

( Two useful sets of units; these adhere to SI and IEC guidelines. ;-)
: k   10* 10* 10* ;  ( "kilo": 10^3.)
: M   k k ;          ( "mega": 10^6.)
: G   k M ;          ( "giga": 10^9.)   ( too big)
: T   k G ;          ( "tera": 10^12.)  ( too big)

: Ki  10 << ;   ( "Kibi", or "kilobinary": 2^10.)
: Mi  Ki Ki ;   ( "Mebi", or "megabinary": 2^20.)
: Gi  Ki Mi ;   ( "Gibi", or "gigabinary": 2^30.)  ( too big)
: Ti  Ki Gi ;   ( "Tebi", or "terabinary": 2^40.)  ( too big)

( For loading, to see if we've left anything lying about.)
variable csp  ( what does this stand for? `check stack pointer'?)
: !csp   depth  csp !  ;
: ?csp   depth  csp @  swap - cell/
         =if  . ."  stack depth change"  hex  .s  then  drop  ;

( Bracket the contents of a file and check for stack depth change.)
: file[  (s a u)   >stderr  ." (( "  type  >stdout  !csp  ;
: ]file            >stderr  ." )) "        >stdout  ?csp  ;

( For counting the size of a loaded file.)
: file[#   (s a u)  file[  here  ;
: #]file   here  swap -  decimal  >stderr  .  ." bytes "  ]file  ;


( Time, timestamp.)
: "hold  (s a #)  dup negate  hld +!  hld @  swap cmove  ;
: ##   (s n)  0  # #  2drop  ;

( Separators)
: ":   char : hold  ;
: "-   char - hold  ;
: ".   char . hold  ;
: ||   bl hold  ;  ( a space)

: month"  (s n - a #)  ( n is 0--11)
   3*  z" janfebmaraprmayjunjulaugsepoctnovdec"  +  3  ;

( clock returns a count of seconds since 1970-jan-01 00:00:00 UTC,
| the Unix "epoch".)

: (date)   (s year month mday yday - 0 0)
   drop  ## "-  month" "hold "-  0 #s ( year)  ;

: hh:mm:ss  (s hms)  ## ":  ## ":  ## ;
: hh:mm     (s hms)  drop ( sec)  ## ":  ## ;
: (time")  (s year month mday yday hour min sec 'zone #zone - a #)
   radix @ push  decimal
   <#  "hold  ( zone)  || hh:mm:ss  ||  (date)  #>
   pop radix !  ;

: (short-time")  ( year month mday yday hour min sec 'zone #zone - a #)
   radix @ push  decimal
   <#  2drop ( zone)  hh:mm  ||  (date)  #>
   pop radix !  ;

: time"   (s epoch - a #)  local-time  (time")  ;
: utc"    (s epoch - a #)         utc  (time")  ;

( Better primitives? More elegant, certainly.)
: s->sm    (s s - s m)    60 u/mod ;
: s->smh   (s s - s m h)  s->sm  s->sm ;
: s->smhd  (s s - s m h d)  s->smh  24 u/mod ;
: sm->s    60 * + ;
: smh->s   sm->s  sm->s ;
: smhd->s  24 * +  smh->s ;

( If anyone had any idea how long a year really is, we could also define
| s->smhdy and smhdy->s. ;-)

: smhq->s  6 * +  smh->s ;  ( sec min hr quarter-day)
: smhdy->s  [ 365 3* 366 + ] * ( quarter-days/yr)  push 4 * pop +  smhq->s ;

( for command-line args)
: ld  token make-string  load-file ;
: -f  ( load file)  ld ;
: --file  -f  ;
: -d  ( define)  trues  ;
: --define  -d  ;


( Prompt, quit, and warm.)
compiler
: 'compiler-prompt  state @  cell+ ;
forth
-: ."  (compiling)"  'compiler-prompt  ;  !  ( bwa ha ha!)

: .mode-prompt   state @  cell+  @execute ;  ( secondary prompt)
: .Ok   ."  Ok"  ;
: prompt   .Ok  .mode-prompt  ;  ( ` Ok' then sub-prompt)


defer canonical  ( XXX: is this obsolete?)
-:  forth  \ [ ;  is canonical

: quit
   begin  cr  <stdin  >stdout  typing interpret  >stderr  prompt  again  [
   ( infinite loop, until error... )

( 2004-jun-26. error now expects a cell-length-prefixed compiled string.)
: error  parsed type space  count type  ( cr) ;
: carefully  catch  =if  error  sp!  ^  then  drop ;

( XXX: difference betw error and warning, so that, eg, "isn't defined"
| doesn't clear the stack.)

: banner
( Print banner.)
 ." muforth "  version count type ( space)
 ." , made "  build-time ( seconds since epoch)  time"  type  cr
 ." Copyright (c) 2002-2024 David Frech. All rights reserved."  cr cr
 ." muforth is free software; see the file LICENSE for details." cr ;

: warm
   >stderr banner
   >stdout command-line count  ['] interpret carefully
   begin  canonical  ['] quit carefully  again  [

( Identify ourselves.)
trues muforth

comment %%
| ( marker, empty)
| ( 1-may-2000. marker now saves current as well.)
| ( 2001-jan-23. remember is now marker, to be slightly less incompatible.)
| : marker
|    create
|      current  max-chains 1+ for  dup @ ,  cell-  next drop   ( save chains)
|    does>  ( from to)
|      current  max-chains 1+ for  push  @+  r@ !  pop cell-  next  drop
|       ( new `here')  h !  ;
|
| marker empty
| %%

(  here  pop -  constant startup-size)

