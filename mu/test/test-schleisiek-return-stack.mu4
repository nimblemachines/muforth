( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2018 David Frech. (Read the LICENSE for details.)


( Trying out, after all these years, the techniques that Klaus Schleisiek
  presented in 1984 [at FORML] and that I read about in 1993.

  The basic idea is that, in addition to return address pointers
  [saved IPs], there are stack frames on the return stack. These can be for
  any purpose, but we're interested here the following: trap frames, local
  variable storage, and "fluid" rebinding of variables - aka dynamic
  scoping.)

( Here is a picture of the return stack, with high memory towards the top of
  the page, and low memory further down:

  ^   |                    |
  |   +--------------------+
  |   |  prev return addr  |
  |   +--------------------+
  |   |        ...         |   several cells could be here; depends on the
  |   +--------------------+   type of frame
  |   |        ...         |
  |   +--------------------+
  |   |   cfa of cleanup   |
  |   +--------------------+
  +---+     prev frame     |<--- fp
      +--------------------+
      |    ip of remove    |<--- rp      remove just calls unlink
      +--------------------+                                          )

variable fp    ( the "top" - most recently pushed - frame)
               ( fp points to a frame ptr, which pts to a frame ptr...)

( link creates a new frame. It fetches the cfa of the following word and
  pushes it onto the return stack. This is the cleanup routine. Then it
  links this frame into the list rooted at fp, and then returns to its
  caller, skipping the following cfa. link is called by a word that builds
  a new stack frame.)

: link     r> dup @  >r         ( fetch following cfa & push to r)
           fp @ >r  rp@ fp !    ( link this frame to previous)
           cell+ >r             ( skip fetched cfa) ;

( unlink undoes what link did. It unlinks the frame from the list rooted at
  fp, and then runs the cleanup routine, which will do whatever is
  necessary to de-allocate the frame and undo any state changes made by the
  word that called link.)

: unlink   r>  ( save return address)
           fp @ rp!  r> fp !    ( unlink frame)
           r> execute           ( execute cleanup word)
           >r  ( restore return address) ;

( unwind is useful in the context of exceptions. It starts at fp and
  unlinks each frame in turn until fp points to a frame with a zero link.)

: unwind   r>  ( save return address)
           -- begin  fp @ @  while  unlink  repeat
           begin  fp @  while  unlink  repeat
           >r  ( restore return address) ;


create remove  -]  unlink ;   ( remove pushes IP when executed!)


( Now some interesting applications.)

-- -----------------------------------------------------------------------
-- Dynamic binding
-- -----------------------------------------------------------------------
( Restore saved value of a variable.)
: restore
   r> ( ra)   r> r>  ( value addr) !   >r ( ra) ;

( Preserve the value of a variable for the duration of the execution of the
  calling word.)

: preserve  ( addr)  ( address of variable)
   r> ( ra)
   over ( addr) >r  swap @  ( value)  >r
   link restore ( push cleanup)
   remove >r    ( normal return - unlink and cleanup)
   >r ( ra) ;


-- -----------------------------------------------------------------------
-- Local variable frames
-- -----------------------------------------------------------------------
( Deallocate local variables.)
: unroom
   r> ( ra)
   r> ( #cells)  rp+!  ( rp+! takes cell count!)
   >r ( ra) ;

( Allocate space for local variables.)
( NOTE: do -not- try to use a for loop to push cells! It doesn't work! The
  return stack is being used to store the loop index, but you're busy
  pushing stuff there! All hell breaks loose! If you absolutely want to
  zero locals as they are allocated, do a begin/until loop with the count
  on the data stack.)

: room  ( #cells)
   r> ( ra)

   ( choose one! mark, zero, allocate)
   -- swap dup  begin  "55aa55aa >r  1-  dup 0= until  drop  ( mark)
   -- swap dup  begin          0 >r  1-  dup 0= until  drop  ( zero)
   swap dup  negate rp+!  ( allocate)

   ( #cells)  >r
   link unroom
   remove >r  ( normal return - unlink and cleanup)
   >r ( ra) ;

-- -----------------------------------------------------------------------
-- Trap handlers
-- -----------------------------------------------------------------------

( Here is a picture of the return stack, with high memory towards the top of
  the page, and low memory further down:

  ^   |                    |
  |   +--------------------+
  |   |  prev return addr  |    ... trap <trap-type> <handler>  ...
  |   +--------------------+         |
  |   | ip of call to trap |---------+
  |   +--------------------+
  |   |     saved sp       |
  |   +--------------------+
  |   |  trap type <pfa>   |
  |   +--------------------+
  |   |    cfa of nope     |   cleanup operation is to do nothing
  |   +--------------------+
  +---+     prev frame     |<--- fp
      +--------------------+
      |    ip of untrap    |<--- rp
      +--------------------+                                          )

( pop trap type, sp, and ip)
( Like remove, untrap pushes its IP when executed.)
create untrap  -]  unlink  shunt shunt shunt ;

( trap: creates a new trap type, uniquely defined because the value it
  compiles is its own dictionary address. At runtime it "raises" this trap
  type, and unwinds the stack to find a matching handler, printing an error
  message if nothing matched. If it finds a handler, it calls it, but
  leaves the IP on the return stack that points to the code that -set- the
  trap, so the whole thing is re-executed until it exits successfully - ie,
  returns normally without trapping.)

: trap:  create  does>
         begin  fp @  0= if error" trapped" then
                unlink  dup r> =  until  ( matches trap type)
         drop  r> sp!  r@ cell+ cell+  ( skip to handler)  @execute ;

( trap is followed in the definition by a trap type word, and a handler.)
: trap   r> ( ra)
         dup cell- >r  ( resume address: call ourselves again!)
         sp@ cell+ >r  ( sp at time trap set; cell+ to ignore ra)
         dup @ >body >r  ( fetch and push trap type)
         link nope       ( null cleanup action; untrap cleans up)
         untrap >r       ( does the unlink and cleanup on normal return)
         ( ra)  cell+ cell+ >r  ( skip trap type and handler and return)
         ;


-- -----------------------------------------------------------------------
-- Goofy test code
-- -----------------------------------------------------------------------
( Jump to the outermost frame and "return" to it.)
: undo  r>  fp @  cell- rp!  >r ;

( Let's talk to the user while these stack frames are set up, so we can
  dump and debug them.)

trap: undefined-token
trap: overflow
trap: ate-the-stack
trap: abort

: test-frames
   ( allocate a bunch of stuff)
   radix preserve  binary
   radix preserve  hex
    5  6  7  trap undefined-token  0
   10 11 12  trap ate-the-stack   -1
   30 40 50  trap overflow         1
   4 room
   -- token number
   quit
   ( dealloc) ;

: tt   test-frames ;
: ff   rp@  4 rp+!  rp@  -4 rp+!  ;
: gg   ff ;
: uw   rp@  unwind  rp@ radix @ ;

