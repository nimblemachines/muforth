( This file is part of muforth: https://muforth.nimblemachines.com/

  Copyright 2002-2022 David Frech. (Read the LICENSE for details.)

-- loading Command-line history editing

( Need tty support.)
.ifndef tty
   ld lib/tty.mu4
.then

comment ansi-sequences

These sequences are generated by my (Linux) console:
Up     ESC [   A
Down   ESC [   B
Right  ESC [   C
Left   ESC [   D
Home   ESC [ 1 ~
Ins    ESC [ 2 ~
Del    ESC [ 3 ~
End    ESC [ 4 ~
PgUp   ESC [ 5 ~
PgDn   ESC [ 6 ~

Backspace key could generate DEL rather than BS, so be prepared for this. ;-)

When output, BS and cursor motions do _not_ go past screen edges; we need
to do this ourselves. What ANSI sequences move the cursor quickly, eg to
EOL?

Cursor movement
Insert  ESC [ <n> @        <n> is count of blanks to insert; def to 1
Del     ESC [ <n> P        <n> is count of char to delete; def to 1
Up      ESC [ <n> A        <n> is rows/colums to move; defaults to 1
Down    ESC [ <n> B
Right   ESC [ <n> C
Left    ESC [ <n> D

DownCR  ESC [ <n> E     like B, but also go to column 1
UpCR    ESC [ <n> F     like A, but also go to column 1

Go      ESC [       <col> G     defaults to col 1
GoYX    ESC [ <row> <col> H     origin at (1,1); both default to 1

Erase (ie, _replace with blanks_); cursor stays put
erase-chars     ESC [ <n> X   <n> can be omitted; defaults to 1
erase-to-eol    ESC [   K
erase-from-bol  ESC [ 1 K
erase-line      ESC [ 2 K

erase-to-eos    ESC [   J     erase from cursor to end of screen
erase-from-bos  ESC [ 1 J     erase start of screen to cursor
erase-screen    ESC [ 2 J

On Linux, console_codes(4) has all the details. It should be interesting to
see where OSX and BSD console drivers diverge (to say nothing of xterms,
etc). Should I be using (n)curses? Probably. ;-)

ansi-sequences

: curs-bol         #CR emit ;
: curs-to-x        ." ["  radix preserve decimal  (u.) type  char G emit ;
: curs-eol         ( len idx - len idx)  over 1+ curs-to-x ;
: curs-ins         ." [@" ;
: curs-del         ." [P" ;
: curs-right       ." [C" ;
: curs-left        ." [D" ;
: curs-erase-eol   ." [K" ;

256 buffer cl  ( One line only! Generously making it 256 bytes for wide ttys!)

( Make space in cl for one char at idx, then store char there.)
: cl-ins  ( len idx ch - len+1 idx+1)
   push   2dup - ( count)  push  dup cl +  dup dup 1+ pop cmove
   pop swap c!  1 1 v+ ;

( Remove char at idx from cl.)
( NOTE: len > idx, otherwise: BOOM!)
: cl-del  ( len idx - len-1 idx)
   -1 u+  2dup - push ( count)  dup cl +  dup 1+ swap pop cmove ;

stderr >width @  constant cl-width

create cl-root  here dup , ,  0 ,  ( prev/next point to cl-root, initially)

variable cl-cur   ( points to cl that we're editing)

( We store command line history at the _end_ of the heap, so we don't
  interfere with pad, colon definitions in progress, etc. NOTE: We
  calculate the end of the heap here. This code _must_ be kept in sync with
  the allocation code in dict.c!)

variable cl-last  ( points to last cl saved; history grows down in memory)
h0 1 Ki Ki cells +  cl-last !

( We're about to evaluate it; link cl into history)

: cl>history  ( len)
   =if  255 min  push
      ( Make room: prev, next, byte-sized count, string, padding)
      cl-last @  r@  1+ aligned  [ 2 cells #] +  -  dup cl-last !  ( cl-new)
      cl-root @ over !+ ( prev=root.prev)
      cl-root   swap !+ ( next=root)  ( cl-new 'count)
      r@ swap c!+  cl swap  pop cmove  ( copy chars)
      dup cl-root !  ( root.prev=new)  dup @ cell+ ! ( new.prev.next=new)  ^
   then  drop ;

: cl-show  ( a len)
   tuck  cl swap  cmove
   curs-bol  curs-erase-eol  cl swap type ;

: >cl  ( 'cl - len idx)
   dup cl-cur !  [ 2 cells #] +  c@+ swap  ( a len)  tuck  cl-show  dup ;

: cl-key-up  ( len idx - len' idx')
   2drop  cl-cur @        @ ( prev)  >cl ;

: cl-key-dn  ( len idx - len' idx')
   2drop  cl-cur @  cell+ @ ( next)  >cl ;

: cl-left?   ( len idx - len idx flag)  ( can we move left?)     dup ;
: cl-right?  ( len idx - len idx flag)  ( can we move right?)   2dup swap u< ;

: cl-left   ( len idx - len idx-1)  curs-left  1- ;
: cl-right  ( len idx - len idx+1)  curs-right 1+ ;

: cl-key-left   ( len idx - len' idx')  cl-left?  if  cl-left   then ;
: cl-key-right  ( len idx - len' idx')  cl-right? if  cl-right  then ;

: cl-key-del  ( len idx - len' idx')  ( ^D)
   cl-right? if  curs-del  cl-del  then ;

: cl-key-bs   ( len idx - len' idx')  ( ^H or DEL)
   cl-left? if  cl-left  cl-key-del  then ;

: cl-key-home  ( len idx - len idx)  curs-bol  drop 0 ;
: cl-key-end   ( len idx - len idx)  curs-eol  drop dup ;

: cl-key-erase  ( len idx - 0 0)  curs-bol  curs-erase-eol  2drop  0 0 ;

: cl-key-ret  ( len idx - addr len)
   curs-eol  space  drop
   dup 1+ [ stderr >col #] !
   dup cl>history  cl swap ;

: cl-key-add  ( len idx ch - len' idx')
   push  over cl-width 1- u< if
      curs-ins  r@ emit  pop cl-ins  ^  then
   rdrop ;

: read-esc-seq   key
   char [ = if  key
      dup char A = if  ( cursor up)     drop  cl-key-up     ^ then
      dup char B = if  ( cursor down)   drop  cl-key-dn     ^ then
      dup char C = if  ( cursor right)  drop  cl-key-right  ^ then
      dup char D = if  ( cursor left)   drop  cl-key-left   ^ then
      digit> dup 10 u< if  key  char ~ = if
         dup 1 = if  ( Home)  drop  cl-key-home  ^  then
         dup 4 = if  ( End)   drop  cl-key-end   ^  then
      then  then  drop
   then ;

( What to do with unmatched control character?)
defer cl-key-unmatched
-: ( len idx key - len' idx' exit?)
   drop  0 ;  is cl-key-unmatched  ( default is to ignore)

: process-key   ( len idx - len' idx' 0 | a u -1)  key
   dup  #ESC =     if  drop  read-esc-seq  0 ^  then
   dup  #BS  =
   over #DEL = or  if  drop  cl-key-bs    0 ^  then
   dup  ctrl D =   if  drop  cl-key-del   0 ^  then
   dup  #CR  =     if  drop  cl-key-ret  -1 ^  then
   dup  ctrl U =   if  drop  cl-key-erase 0 ^  then
   31 over  u<     if        cl-key-add   0 ^  then
                             cl-key-unmatched ;

: editline  ( - addr len)
   cl-root cl-cur !
   0 0  begin  process-key  until ;

: typing  ( - addr len)
   <stdin  >stderr  tty user-raw  editline  tty cooked ;
